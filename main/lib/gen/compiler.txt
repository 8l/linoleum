(

    ==========================================================================
    L.in.oleum Universal Compiler
    L.in.oleum Version 1.14 - multiplatform/ml-enabled
    ==========================================================================

	The contents of this archive are subject to the WTOF Public License;
	you may not use this archive except in full compliance with the
	License. You should have received a copy of the License within
	this archive; if not, you may obtain a copy of the License at
	http://anywherebb.com/wpl/wtof_public_license.html

	This archive, and related source code,
	is Copyright 2001-2004 by Alessandro Ghignola,
	Home Sweet Pixel software

	All Rights Reserved.

	----------------------------------------------------------------------

	This file is a READ-ONLY SOURCE CODE archive licensed under WTOF P.L.
	For full legal terms, see the included license, wpl.htm.

				      - IN SHORT -

	YOU ARE ALLOWED TO CONSULT, FREELY REDISTRIBUTE, AND KEEP COPY OF IT.
	YOU ARE FORBIDDEN, UNDER ANY CIRCUMSTANCES, TO SELL IT FOR PROFIT.

	You are forbidden, in any circumstances, and unless authorized by the
	copyright holder, to change this file in whole or in part, no matter
	if the changes are intended for personal use or public redistribution.
	Should you like to contribute to this project with your suggested
	changes, you might contact the copyright holder, Alessandro Ghignola,
	to communicate your intentions and request for authorization.
	This limitation is made with the sole purpose of "forking" prevention.

	Before reflecting on possible improvements, you should consider that:
	- I'm quite stubborn;
	- this is mostly a low-level, unstructured, untyped language;
	- this language is supposed to be 100% portable, in ALL its effects:
	  imagine how your changes could be ported to different hardware, to
	  different operating systems, to different processors, and unless you
	  are rather confident they might be portable, avoid suggesting them;
	- OOP is considered to be neither a fact, nor a possibility, here.

	----------------------------------------------------------------------

	Compile THIS program with your platform's binary of THIS program. Heh!

	----------------------------------------------------------------------

	Porting this compiler is relatively easy: you may use a prototype of a
	run-time module, for the target platform, which only has to concretely
	support file access. This program, in fact, only makes isocalls to the
	file group of the RTM control variables; in particular, only commands:

	SET DIR
	GET DIR
	TEST
	READ
	WRITE
	DESTROY
	GET FIRST FILE
	GET NEXT FILE

	are effectively used.
	There is, then, a couple calls to the READ TIME command of the timer
	group but that's only for execution time report: your prototype of the
	run-time module might simply put some effort in NOT crashing when such
	a READ TIME isocall happens, but it wouldn't really need to return the
	actual time. That done, you could compile this program and obtain some
	perfectly functional compiler to test stuff with, later in the porting
	of the rest of the RTM commands.

    ==========================================================================
    Including the compiler as a library in your applications:
    ==========================================================================

	Yep, you can eventually give a tool of yours the ability to internally
	compile a L.in.oleum application, by PHYSICALLY integrating the whole
	compiler's source code into the application, as if it was a library.
	You barely have to write:

	  "libraries"
	    gen/compiler;

	on top of your source code.
	The usage of this compiler in such a situation, called from a program,
	is trivial: you simply fill up the [command line] string with the name
	of the source code file to compile, and the required parameters, then
	you make a call to the only public entry of this file, in practice...

	    ...
	    => compile;
	  ? ok -> program was compiled successfully;
	  ? failed -> there were errors either in parameters or in the source;
	    ...
	  "there were errors either in parameters or in the source"
	    [the error log is located at] = errorlog name;
	    ...
	  "program was compiled successfully"
	    [the symbols map is located at] = smblsmap name;
	    [the executable file is located at] = executable name;
	    [string holding textual statistics report] = compiler report;
	    ...

	it's as simple as that, and your program becomes also a compiler.
	Yeah Peterpaul, I suppose it'd be nice to have it in your text editor.
	When included as a library and called this way, the compiler preserves
	all registers and the work path of the main application, so its duties
	might be perfectly transparent to your main application.

    ==========================================================================
    Routines you may freely copy from here and paste into your own programs:
    ==========================================================================

	The following general-purpose subroutines may be also copied to your
	applications for using them there: as they are declared here, they are
	not accessible from outside this source code file, because this file
	is globally hashed to keep its symbols from interfering with the host
	application's symbols, but the compiler will so allow you to redeclare
	these routines along with all of their needed support variables.
	Oh, most of them are declared near the end of this source code file.

      * generic string converters:

	- atofb 	Ascii-to-FourByte
	- fbtoa 	FourByte-to-Ascii
	- atoui 	Ascii-to-Unsigned Integer
	- uitoa 	Unsigned Integer-to-Ascii
	- strlwr	STRing to LoWeRcase
	- strupr	STRing to UPpeRcase

      * generic string constructors:

	- strlen	STRing LENgth
	- strcmp	STRing CoMPare
	- strpcmp	STRing Partial CoMPare
	- strcpy	STRing CoPY
	- strcat	STRing ConCAtenate
	- strstr	STRing search within STRing

      * generic file constructors:

	- fcpy		File CoPY
	- fcat		File ConCAtenate

      * utilities:

	- unpack	unpack static data bitstream - requires "bits" library
	- swap endian	reverse order of all bytes of all units of an area

	...but the rest of this program might remain HERE, and UNCHANGED.
	Again, remember that this file is licensed under WPL, not under LGPL.
	I repeat, it has to be so, to keep L.in.oleum from forking: it isn't
	a program that could allow itself to fork too easily. And nevermind,
	the rest of the routines and the code not mentioned in the above list
	wouldn't probably fit your case: it's very specific to this compiler.

    ==========================================================================
    Command-line parameters:
    ==========================================================================

    * synopsys:

      compiler [--option]--src:/myvolume/mypath/../myfile.txt[--option] ...

    * options:

      --src:... required: universal path to the source code file to compile
      --env:... required: universal path to where cpu, sys, lib folders are
      --sys:... required: target system pack name, eg. --sys:win32
      --cpu:... required: target processor name, eg. --cpu:i386
      --ext:... required: final executable file's extension, eg. --ext:.exe
      --del:#	optional: n. of machine cycles to leave between instructions

    * typical command line layout for the Win32 package:

      --env:/c/linoleum/main--cpu:i386--sys:win32--ext:.exe--src:/c/myprog.txt

    * options may be ordered in any ways in the cmd line, and none of those
      arguments require spaces as separators; however, spaces may be placed
      within the arguments' values;
    * system-specific pathnames for the --src and --env parameter are allowed,
      however if you can use L.in.oleum universal syntax for paths, you might;
    * both the --env parameter and the path to the main source code file have
      to be absolute paths, specifying their destinations starting from the
      system root directory, and when using universal syntax, they'd have to
      both begin by a forward slash;
    * the --ext parameter is required to appear in the command line, but then
      it may be left void if the target executable file name must not have an
      extension: note, thought, that the executable file name is given by the
      file name of the main source code file, minus the eventual 3-characters
      extension which is typically ".txt", plus the --ext parameter; because
      the source file name is allowed to have no extension, if you left --ext
      void the compiler would attempt in such a case, to overwrite the source
      code to save the binary;
    * the --del parameter must be used in place of the deprecated "cpu delay"
      director tag, which is no longer parsed as a director tag: if --del is
      a positive decimal value and not zero or void, a delay approximately
      corresponding to that value in machine cycles, will be streamed between
      each and every instruction forming the compiled program's code: it will
      uniformly slow down the application, simulating execution with a slower
      processor; however, note that this won't slow down the run-time module,
      so an isocall to retrace the display, for instance, would still reflect
      the speed of the host system, not of the one you're trying to simulate;
    * all file paths and names involved in the compiler's duties can be upto
      1024 characters long, but if they're longer, the limit isn't checked in
      all points and the compiler will overrun its buffers, just so you know:
      this includes paths mounted by recursing the directory tree for library
      names and file names of parts of the stockfile.

    ==========================================================================
    Inconsistences based on legacy BC++ MS-DOS version of the compiler:
    ==========================================================================

    * command line options:
      this compiler allows the following options:
	--env
	--cpu
	--sys
	--ext
	--del
      the legacy compiler allows the following options...
	--cpu
	--sys
      ...and assumes:
	--env = <directory where compiler.exe is placed>
	--ext = .exe
	--del = 0
      also, the legacy compiler considers defaults for --cpu and --sys, while
      this compiler requires their explicit specification; finally, the legacy
      compiler requires the main source file name to be MS-DOS compatible and
      be passed as the first argument to "compiler.exe", while this compiler
      requires the main source file name to be quoted, but for the rest given
      in either system-specific or universal path, and placed anywhere within
      the command line string.

    * symbol hashing:
      only this compiler allows globally hashing symbols in source code files,
      that is, allows use of the <symbol hash> director tag: the symbols' hash
      is a special string made of valid symbol characters, which will be used
      to compute a global 64-bit hash to make all of the symbols declared into
      the hashed source file -uniquely accessible from within that source- and
      not visible from anywhere else; this indirectly allows eventually using
      the same names for symbols like constants, variables, workspace labels,
      and code labels, within different files having different global hashing.
      the global hash established with a "symbol hash = my hash string;" could
      be overridden using the <shared> prefix upon declaring a symbol's name,
      for example:
	"directors"
	    symbol hash = this is my library and so this is my hash string;
	"constants"
	    shared pi = 3.14159f;
	    this constant will be private = 12345678h;
	"variables"
	    shared myvariable = 12345;
	    this variable will be private = 100;
	"workspace"
	    shared myarea = 1000;
	    this area will be private = 25;
	"programme"
	  "shared mysubroutinename"
	    leave;
	  "this subroutine will be private"
	    leave;
      also note: <shared> prefix must be granted precedence over "vector",
      "matrix", "array" and "service", but not over "pragma"; more examples:
	"variables"
	    shared array myarray = 1; 2; 3; 4; 5; { yep }; 6; 7; 8; null;
	"programme"
	  "shared service myroutinethatdoesnothing"
	    leave;
      finally, remember that symbol hashing only affects symbols declared past
      the "directors" period, so stockfile compound names are always globally
      shared, and so are their corresponding "sizeof..." constants: it's quite
      obvious that the stockfile is accessible by the whole application so its
      symbols cannot be hashed.
      ah, ps., of course, the following conventions apply to hash strings:
      - lowercase and uppercase letters are the same, the case doesn't count;
      - the hash string can't contain signs, only alphanumeric characters;
      - blank spaces and text formatters don't count, either;
      - using the same hash string in more than a source file "joins" sources
	so that one of the files can globally access the other file's symbols,
	and vice-versa.

    * expression syntax:
      the only inconsistence is in a particular case where a variable could be
      called "ided" and used in a linear expression right after the short form
      of the tag "divided" where this compiler would get the whole as a simple
      occurrence of "divided"; the legacy compiler would decode that case if a
      blank space was used to separate "div" from "ided": this of course would
      apply also to variables beginning by an "ided-" prefix; however, legacy
      compiler is the wrong one: L.in.oleum official syntax specifications say
      that blank spaces never count, so it's normal that such an expression is
      not resolved correctly; here's a table considering all possible cases:

      symbol suffix followed by tag:
	  -asbytesiz e-tag	  no e-tags
	  -plu s-tag		  no s-tags
	  -minu s-tag		  no s-tags
	  -mt p-tag		  p-tags: plus, so now checking...
	   -m tp-tag		  no tp-tags
	  -multiplie d-tag	  d-tags: div, divided, so now checking...
	   -multipli ed-tag	  no ed-tags
	  -di v-tag		  no v-tags
	  -divide d-tag 	  error: "divide" contains "div"
	  -relatin g-tag	  no g-tags

      tag followed by symbol prefix:
	  asbytesize ?- 	  no tags begin by "asbytesize"
	  plus ?-		  no tags begin by "plus"
	  minus ?-		  no tags begin by "minus"
	  mtp ?-		  no tags begin by "mtp"
	  multiplied ?- 	  no tags begin by "multiplied"
	  div ided-		  no solution
	  divided ?-		  no tags begin by "divided"
	  relating ?-		  no tags begin by "relating"

      ...within "parse operand" subroutines there are special checks for the
      only two cases of legal symbol names, "mt" and "multiplie" which would
      effectively generate a wrong match.

    * expression syntax:
      other than the <plus|minus|multiplied|divided|relating> constructors,
      this compiler acknowledges a new tag, which is not a constructor: it's
      a transformer and it's typically spelled: <as byte size|as bytesize>;
      the "as byte size" tag transforms the value of the expression so far, by
      dividing it for the constant "bytes per unit" and adding 1 to the result
      if the remainder of that division is not null; pratically, it calculates
      the size, in units, of an area of memory which original size is measured
      in bytes; typically, for instance, you will want to use this transformer
      to allocate the smallest area of the workspace for loading a stockfile
      compound; in legacy source code, such an area had to be allocated as:
	myarea = size of myfile divided bytes per unit plus 1;
      ...which would lead to wasting a unit of memory if the size of the file
      was a multiple of the unit; using this compiler, you can allocate it as:
	myarea = size of myfile as byte size;
      ...which would divide the constant "size of myfile" by the bytes forming
      an unit [4], round the value in excess, and never waste that extra unit;
      this transformer works also when it's not at the end of the expression:
	myarea = size of myfile as byte size plus 1;
      ...would unconditionally allocate 1 extra unit past the area that would
      perfectly contain that file: however you might not want to do this last
      thing, I'm just giving it as an example.

    * array prefix:
      this compiler acknowledges the "array" tag to make pointable static data
      addresses, the legacy compiler doesn't; "pointable" means that addresses
      declared as <vector|matrix|array>, and code labels declared as <service>
      may be loaded and used as immediate operands without generating warning
      messages like "this is the address of the <first|second> operand".

    * general syntax:
      this compiler checks for the following error condition:
	  some instruction without terminal semicolon
	"a code label"
      by reporting an error message, namely "extra input before label";
      the legacy compiler does not realize the mistake, but does not assemble
      the unterminated instruction preceeding the code label [ouch!].

    * general syntax:
      this compiler allows relative compound paths upto 1024 characters, the
      legacy compiler only allows 256 characters; this compiler also limits
      the maximum library nidification level to 25, the legacy compiler does
      not apply limits but it would overrun the stack past a certain point.

    * general syntax:
      this compiler allows implicitly unlabeled workspace areas, as in:
	myarea = 10; 5;
      ...which would allocate 10 units, assign symbol "myarea" to the address
      of the first allocated unit, and then allocate 5 more unlabeled units;
      the legacy compiler only allows to specify <no label> to allocate such
      unlabeled areas in the "workspace" period, but can't do it implicitly.

    * general syntax:
      the legacy compiler allowed using the following data alignment tags:
      - extend upto: <# of units>
      - align at: <# units boundary>
      this compiler allows the above two tags, and also the "make" tag:
      - make: <bits|nybbles|compact strings|bytes|words|doublewords|quadwords>
      ...where:
	bits - 1 bit
	nybbles - 4 bit
	compact strings - 7 bit
	bytes - 8 bit
	words - 16 bit
	doublewords - 32 bit
	quadwords - 64 bit
      - make: <arbitrary # of bits per value, decimal integer, from 1 to 64>
	e.g. "make: 5;" for 5-bit records, "make: 41;" for 41-bit records etc.
      ...which are means to concatenate static data into the application file
      without aligning each value [or the bytes of a text string] to take one
      unit; normal unit-based streaming is restored with a "make: units;" tag,
      however, when declaring a labeled symbol, even if the data paragraph was
      declared as something different than a stream of units, the symbol will
      have to be associated to an address, so the compiler will re-align that
      symbol's first bit to the next unit boundary, automatically. oh, and of
      course the programmer must consider that non-unit-aligned data will have
      to be specifically decoded by the program: when you cast a 7-bit ASCII
      string within your static data, you'll have to remember to process that
      string with the "gen/bits" library or some equivalent code, and read 7
      bits per character starting from the unit-based address of the string:
      ah, yes, placing a certain text string within a data paragraph framed by
      "make: compact strings;" and "make: units;" can generate one such string
      which will supposingly take less space into the application file, e.g.
       make: compact strings;
	my compact string = { hello_this_is_encoded_in_7_bit_per_character };
	another compact string = { some_more_text };
       make: units;
	this is no longer a compact string = { unit-based_string };
      however before abusing this way to reduce the application file size, be
      aware that unit-based text compresses very well, and surely better than
      with such a cheap compression method, when submitted to some Lempel-Ziv
      compression mechanism, such as ZIP or Lizzie. in a nutshell, when using
      7-bit ASCII for texts, some uncompressed application file could be much
      more compact, but the same file would compress much worse than normal:
      the best solution for text is, most probably, wrapping strings in data
      paragraphs beginning with a "make: bytes;", they'd be longer than 7-bit
      strings but might still be compressed pretty well by external programs.
      oh, postscript: you may wonder which is the difference between a "make:
      units;" and a "make: doublewords;": so, they both create 32-bit values,
      but "make: units;" realigns the top-of-the-workspace, and so the address
      of the next labeled symbol, to a unit's boundary, before streaming next
      data value.

    * symbols map:
      the initial state of the symbols map is <off> in this compiler, while it
      was <on> in the legacy compiler; furthermore, turning symbols map on has
      the effect of logging all -subsequently declared- symbols, but not those
      declared previously, in eventual libraries; to log symbols from a given
      library, the programmer needs to specify "symbols map = on;" within the
      directors period of the said library.

    * object code:
      floating-point immediate values encoded by this version are computed via
      32-bit single precision calculations, slightly differing - 1 bit more or
      less - from the 64-bit double precision calcs. used by the DOS compiler.

    * object code:
      using CPU delays, leaving an open program that the compiler will forcely
      close by inserting an "end" tag at the end of the object code there will
      be no CPU delay after that virtual "end" tag in programs compiled by the
      legacy compiler, differently from programs compiled with this compiler.

    * SID hashes:
      SID hashes are 64-bit here, but they were 40-bit in the legacy compiler:
      chanches are that this compiler will disambiguate symbols' names better
      than the legacy compiler, however the hash calculation is different and
      it could, in extremely rare occurrences, fail to disambiguate symbols
      that the legacy compiler was correctly distinguishing as being different
      symbol names; in such cases this compiler will give the error message of
      a "symbol already declared", but that'd be incorrect and could be fixed
      by slightly changing the name of the symbol causing that problem.

    * behavior:
      CPU delay is a command line option, and not acknowledged as a director.

    * behavior:
      this compiler will resolve an infinite number of forward references, the
      legacy compiler could resolve upto 4 levels, because it's limited to 4
      passes; this compiler, instead, performs an adaptive number of passes:
      there's only one reference that none of the compilers could ever resolve
      because it's a paradox, and it's described here as "causal ring"; causal
      rings happen when the programmer attempts to set a constant to keep the
      address of a static data symbol [variable or workspace area label], but
      constants can be involved in determining the address of such static data
      symbols, and that fact closes the causal ring; yet, it's possible to set
      constants to point at code label addresses.

    * behavior:
      this compiler disregards the following warning situations, which were
      instead checked and reported in the errors log by the legacy compiler:
      - Floating-point value used as pointer will have unpredictable effects!
      - Constant assumed to mean immediate constant?!
      - Nonsensical use of pointers.
      - CPU IS BEING INTENTIONALLY DELAYED FOR APPLICATION STRESSING PURPOSES!
      - Symbols map previously disabled. Cannot enable NOW.
      - ONE OR MORE TEST FLAGS ACTIVE...
      - Directive has no effect.
      - IGNORED: Coupled semicolons and nothing between.
      the design of this compiler was in fact planned to log as little warning
      messages as possible, on an "only where the warning might count" basis.

    ==========================================================================
    Change log:
    ==========================================================================

    * Wednesday February 25th, 2004:
      - changed commandline syntax, here and in the visual compiler, to accept
	source file name to compile as a --src:... argument, and no longer in
	the middle of doublequotes; both this and the visual extension would
	trim doublequotes from each end of the filename, however, should they
	find them there. The doublequotes were stripped when the compiler was
	compiled for Linux: that's the reason for this change. But in the end,
	I think the new command line layout is more uniform and elegant...

    * Monday February 23rd, 2004:
      - uh-oh... the piece of code labeled "cs tag character" was effectively
	forgetting to reload [dlen] before entering "cat data"; I've corrected
	it and, to try and avoid future cases, I've created a wrapper around
	the "cat data" routine, "cat unit", that sets [dlen] to 1 and proceeds
	with the rest: "cs tag character" was used when, in a text string, an
	incomplete tag was marked by a backslash, so the point where this was
	happening in "linodoc" was Peterpaul's "cmdline" library:
	  str backslash = {\};
	this caused "cs tag character" to be called, because the backslash was
	found, but then it wasn't marking any cs, cr, lf, ta, us tags, and the
	"cat string" routine used that to stream the single backslash: pity it
	was at that point forgetting to load [dlen] with 1. Ok, now it's using
	the "cat unit" wrapper, and works. Such a silly error remained in the
	code because until a few days ago that subroutine was working slightly
	differently, and wasn't needing to set [dlen]: after changes, I forgot
	to update it, while updating the same thing in many other spots. I had
	tested strings with unterminated tags before introducing that mistake,
	that's why I was supposing no errors were there...

    * Sunday February 22nd, 2004:
      - generally revised code around calls to "cat data" and "cat byte", for
	possible extra-long looping conditions [like zero counts], attempting
	to fish out the problem that caused Peterpaul's "linodoc" to compile
	as a 700 megabyte application after the compiler seemed to hang: well
	I found nothing wrong, apparently, but there was a mistake involving
	the [stack waste] parameter for "cat data" - from the main flow of
	execution, which includes period parsers, "cat data" must be called
	with [stack waste] assigned to zero; I was assigning it to 1, and it
	was an error, ok, but it would have simply truncated the compiler's
	execution in case a file system error occured when streaming the data
	cache to the application file, about once every 64 Kb of static data,
	so it surely wasn't the problem. the problem was most probably a loop
	of a more subtle kind, for which I've given details just after label
	"sp null tcfp"...

    * Saturday February 21st, 2004:
      - aaah! it's incredible but two days ago I wrote this:
	  tgxivided = { idived };
	instead of this:
	  tgxivided = { ivided };
	causing the compiler to FAIL interpreting the divided tag at all; the
	astounding fact is that I didn't notice it because I normally use the
	short form <div>.
      - added shared "compiler report" to returned informations for visual
	extensions and other calling applications' use: it logs statistics
	even if the symbols map is not requested.

    * Friday February 20th, 2004:
      - fixed double-doublequoting possible glitch detailed in the comments
	following the "no cpu delay requested" label, in the main flow;
      - fixed forgotten <-multiplie + d-tag> conflict, in linear expressions,
	for which I added a detailed table of combinations in comments above;
      - fixed Peterpaul's bug detailed in the comments to "po ptgxsbytesize",
	also applying to "ptgxultipled,ptgxtp,ptgxivided,ptgxiv,ptgxelating";
      - after "last pass j1", I had happily written:
	  [block size] = 8 mtp 8 plus 1 mtp bytesperunit;
	to read the header of the SYS pack: pity it should have been 8 PLUS 8
	and not 8 MTP 8, which of course caused a buffer overrun altering the
	value of [ipof], marking the position of the initialization paragraph
	and declared after that buffer, and consequentially silly failures to
	read using that dirty value as a start position for the "fcpy" call.

    * Thrusday February 19th, 2004:
      main/lib/gen/compiler.txt - L.in.oleum compiler version 1.14 released.

)

"libraries"

	bits;
	bytes;



"directors"

	unit		= 32;
	display width	= 0;
	display height	= 0;

       (when compiled as a program, the application's name is as follows...)

	program name	= { L.in.oleum_Universal_Compiler_v1.14 };

       (when included as a library, hash all symbols except the <shared> ones)

	symbol hash	= hsp linoleum compiler 114;

       (the High Performance Timer isn't needed by the compiler, and the part
	of the runtime module that times the CPU's HPT would last about half a
	second; this compiler needs to be very fast because L.in.oleum doesn't
	like to make use of precompiled libraries, so that half second can be
	annoying, even if it's only a half second, and so...)

	test flags	= disable hpt;



"constants"

    (global)

	last pass = 1000000 1; (map symbols, select RTM var, create app file)
	data pass = 1000000 2; (stream all static data to application file)
	code pass = 1000000 3; (stream all code)
	stck pass = 1000000 4; (stream stock file contents)

	scache size =  65536; (source code cache size, bytes)
	dcache size = 524288; (static data cache size, bits)
	bcache size =  65536; (binary code cache size, bytes)

	pre symbols =	288; (total number of predefined symbols)
	max symbols = 50288; (maximum number of definable symbols)
	symbol size = 4;     (units taken by a single symbol record)

	sidlo = 0; (symbol record: low unit of symbol id)
	sidhi = 1; (symbol record: high unit of symbol id)
	value = 2; (symbol record: symbol's associated value)
	flags = 3; (symbol record: symbol's type flags)

	constant  =  1; (symbol flags: symbol is a simple constant value)
	fp	  =  2; (symbol flags: symbol value is of floating-point type)
	static	  =  4; (symbol flags: symbol is a workspace data address)
	address   =  8; (symbol flags: symbol is a pointable data address)
	codelabel = 16; (symbol flags: symbol is the address of a code label)
	suspended = 32; (symbol flags: symbol value is temporarily suspended)
	not suspended = greatest unsigned integer minus suspended; (negation)

	li sigunit1 case1 = 4D 4C 4E 4Ch; ("LNLM" signature in four versions)
	li sigunit1 case2 = 49 4D 4C 4Eh; (to reflect the 4 possibilities of)
	li sigunit1 case3 = 6E 49 4D 4Ch; (byte-to-unit alignment in blocks)
	li sigunit1 case4 = 69 6E 49 4Dh; (read via the "fcpy" subroutine...)

    (parser-related)

	levels = 24; (maximum number of nidification levels between sources)

	unkn = minus 1; (period identificators: for "prid" to be assigned to)
	libs = 0;
	stck = 1;
	dirs = 2;
	cons = 3;
	vars = 4;
	wksp = 5;
	prog = 6;

	tabulation	  =   9; (common ASCII codes)
	line feed	  =  10;
	carriage return   =  13;
	blank		  =  32;
	open parenthesis  =  40;
	close parenthesis =  41;
	open bracket	  =  91;
	close bracket	  =  93;
	open brace	  = 123;
	close brace	  = 125;
	semicolon	  =  59;
	quotes		  =  34;
	cross		  =  43;
	hyphen		  =  45;
	quote		  =  39;
	comma		  =  44;
	colon		  =  58;
	exclaim 	  =  33;
	question mark	  =  63;
	dollar		  =  36;
	percent 	  =  37;
	greater than	  =  62;
	less than	  =  60;
	equal		  =  61;
	bar		  = 124;
	slash		  =  47;
	backslash	  =  92;
	at		  =  64;
	ampersand	  =  38;
	hash		  =  35;
	asterisk	  =  42;
	tilde		  = 126;
	underscore	  =  95;
	dot		  =  46;
	caret		  =  94;
	exp		  = 101;

	regb string signal  =	1; (flag/parsing a string)
	regb label signal   =	2; (flag/parsing a label)
	regb closed string  =	4; (flag/a string was just closed)
	regb insymbol	    =	8; (flag/parsing symbol in code string)
	regb innybble	    =  16; (flag/actual code byte awaits next nybble)
	regb make relative  =  32; (flag/about to stream relative address)

	regb cs recache     =  64; (flag/on exiting "cat string" reload cache)
	regb cs programname = 128; (flag/use "cat string" to fill programname)

	first operand  = zero; (operands' offsets relating "pces")
	second operand = 2048;
	third operand  = 4096;

    (parse operand)

	IEEE0	= 00000000h; (IEEE short float [dword] corresponding zero)
	IEEE01	= 3DCCCCCDh; (IEEE short float [dword] approximating 1e-1)
	IEEE1	= 3F800000h; (IEEE short float [dword] approximating 1e+0)
	IEEE10	= 41200000h; (IEEE short float [dword] approximating 1e+1)

	regb mod val = 1; (flag: value found to parse)
	regb mod xtp = 2; (flag: multiplied/mtp expression modifiers used)
	regb mod xiv = 4; (flag: divided/div expression modifiers used)
	regb mod abs = 8; (flag: "as byte size" expression modifier used)

	immediate = 1; (operand types)
	direct	  = 2;
	register  = 3;
	indirect  = 4;

    (fcpy and fcat)

	sizeof ffun cache = 16384; (units, meaning 64 Kb here)

    (CPU pack header fields)

	bea imm =  1; (Big Endian Activation - immediate values)
	bea dis =  2; (Big Endian Activation - workspace displacements)
	bea rel =  4; (Big Endian Activation - relative addresses)
	bea dat =  8; (Big Endian Activation - static data)
	bea ini = 16; (Big Endian Activation - initialization paragraph)

	acc reverse jumps = 1; (Accessory flags: reverse jumps offsets)
	acc reverse stack = 2; (Accessory flags: reverse stack references)



"variables"

    (global)

	default program name = { L.in.oleum_runtime };

	errlog name = { errorlog.txt }; (name of error log file)
	symaps name = { smblsmap.txt }; (name of symbols map file)

	path junction = { / };	  (a single forward slash, of course)
	txt extension = { .txt }; (duh)

	src option = { --src: }; (from cmd line, e.g. "/C/myprogram.txt")
	env option = { --env: }; (from cmd line, typically "/C/linoleum/main")
	cpu option = { --cpu: }; (from cmd line, e.g. "i386")
	sys option = { --sys: }; (from cmd line, e.g. "win32", "linux")
	ext option = { --ext: }; (from cmd line, typically ".exe")
	del option = { --del: }; (from cmd line, numeric, typically omitted)

	env junction = { /lib  }; (appended to --env, default libs. root)
	cpu junction = { /cpu/ }; (appended to --env, prepended to --cpu)
	sys junction = { /sys/ }; (appended to --sys, prepended to --sys)

	bin extension = { .bin }; (it's what it expects as SYS/CPU packs ext.)

    (global report)

	rep passes  = { passes_performed:_______ };
	rep lines   = { compiled_lines:_________ };
	rep instrs  = { instructions_assembled:_ };
	rep symbols = { user_symbols_defined:___ };

	rep stock   = { stockfile_size:_________ };
	rep data    = { static_data:____________ };
	rep ramtop  = { ramtop:_________________ };
	rep codesz  = { code_size:______________ };
	rep applsz  = { application_file_size:__ };
	bytestring  = {_bytes\cr\lf };

	rep extime  = { execution_time:_________ };
	msec string = { _ms. };

    (predefined symbol: the only variable, which must be at address zero)

	str codeorigin = { codeorigin };

    (predefined symbols: constants,
     106 null-terminated strings, plus one value, 7 bits per value)

    make: compact strings;

      packed pr cons =

	(constant name) 		 (value)  (record #)

	{ force888		    };	       1; (0)
	{ force565		    };	       2; (1)
	{ disablehpt		    };	       4; (2)
	{ disablepd		    };	       8; (3)

	{ network		    };	       1; (4)
	{ audioplayback 	    };	       2; (5)
	{ printer		    };	       4; (6)

	{ idle			    };	       0; (7)
	{ retrace		    };	       1; (8)
	{ setcooperativemode	    };	       2; (9)
	{ setexclusivemode	    };	       3; (10)
	{ getdataoffset 	    };	       4; (11)
	{ playonce		    };	       5; (12)
	{ playcontinuously	    };	       6; (13)
	{ pause 		    };	       7; (14)
	{ unpause		    };	       8; (15)
	{ stop			    };	       9; (16)
	{ getconsoleinput	    };	      10; (17)
	{ clearconsolebuffer	    };	      11; (18)
	{ readpointer		    };	      12; (19)
	{ test			    };	      13; (20)
	{ read			    };	      14; (21)
	{ write 		    };	      15; (22)
	{ setsize		    };	      16; (23)
	{ destroy		    };	      17; (24)
	{ run			    };	      18; (25)
	{ setdir		    };	      19; (26)
	{ getdir		    };	      20; (27)
	{ mkdir 		    };	      21; (28)
	{ rmdir 		    };	      22; (29)
	{ getfirstfile		    };	      23; (30)
	{ getnextfile		    };	      24; (31)
	{ getfirstdir		    };	      25; (32)
	{ getnextdir		    };	      26; (33)
	{ readtime		    };	      27; (34)
	{ readutctime		    };	      28; (35)
	{ readcounts		    };	      29; (36)
	{ queryapdlines 	    };	      30; (37)
	{ readapdline		    };	      31; (38)
	{ printpage		    };	      32; (39)
	{ endprocess		    };	      33; (40)
	{ failprocess		    };	      34; (41)
	{ sleep 		    };	      35; (42)
	{ gethostbyname 	    };	      36; (43)
	{ gethostbyaddr 	    };	      37; (44)
	{ getpeerbysocket	    };	      38; (45)
	{ cancelrequest 	    };	      39; (46)
	{ netopen		    };	      40; (47)
	{ netclose		    };	      41; (48)
	{ netconnect		    };	      42; (49)
	{ netlisten		    };	      43; (50)
	{ netsend		    };	      44; (51)
	{ netrecv		    };	      45; (52)
	{ netisreadable 	    };	      46; (53)
	{ netiswritable 	    };	      47; (54)
	{ netisexcepted 	    };	      48; (55)
	{ kread 		    };	      49; (56)
	{ kwrite		    };	      50; (57)
	{ kdestroy		    };	      51; (58)
	{ getclipsize		    };	      52; (59)
	{ readclip		    };	      53; (60)
	{ writeclip		    };	      54; (61)

	{ verylowpriority	    };	       0; (62)
	{ lowpriority		    };	       1; (63)
	{ normalpriority	    };	       2; (64)
	{ highpriority		    };	       3; (65)
	{ veryhighpriority	    };	       4; (66)

	{ middle		    };	 1048577; (67)
	{ voidregion		    }; FFFFFFFFh; (68)
	{ wholedisplay		    };	       0; (69)
	{ cooperative		    };	       0; (70)
	{ exclusive		    };	       1; (71)
	{ active		    };	       2; (72)

	{ bycoordinate		    };	       0; (73)
	{ bydelta		    };	       1; (74)
	{ pdpresent		    };	       1; (75)
	{ pdinsight		    };	       2; (76)
	{ pdleftbuttondown	    };	       4; (77)
	{ pdrightbuttondown	    };	       8; (78)
	{ pdmiddlebuttondown	    };	      16; (79)

	{ paused		    };	       2; (80)

	{ stockfile		    };	       0; (81)

	{ ready 		    };	       1; (82)
	{ error 		    };	       2; (83)
	{ permittoread		    };	       4; (84)
	{ permittowrite 	    };	       8; (85)

	{ godeaf		    };	       2; (86)
	{ netsuccess		    };	       4; (87)
	{ netfailure		    };	       8; (88)

	{ releasenumber 	    };	     114; (89)
	{ cpuunit		    };	      32; (90)
	{ bytesperunit		    };	       4; (91)

	{ no			    };	       0; (92)
	{ off			    };	       0; (93)
	{ null			    };	       0; (94)
	{ zero			    };	       0; (95)
	{ false 		    };	       0; (96)
	{ inactive		    };	       0; (97)

	{ on			    };	       1; (98)
	{ yes			    };	       1; (99)
	{ true			    };	       1; (100)

	{ undefined		    }; 3F3F3F3Fh; (101)
	{ greatestunsignedinteger   }; FFFFFFFFh; (102)
	{ greatestsignedinteger     }; 7FFFFFFFh; (103)
	{ smallestunsignedinteger   }; 00000000h; (104)
	{ smallestsignedinteger     }; 80000000h; (105)

      packed pr cons finish = 0 *** 0; (end of data marker)

    (predefined symbols: workspace,
     180 null-terminated strings, 7 bits per value)

      packed pr wksp =

	(workspace label)	       (record #)	(size 1 unit except)

	{ isokernel		    }; (0)
	{ ramtop		    }; (1)
	{ priority		    }; (2)

	{ commandline		    }; (3)		(size 32768 units)

	{ displaycommand	    }; (4)
	{ displaystatus 	    }; (5)
	{ displayorigin 	    }; (6)
	{ displaywidth		    }; (7)
	{ displayheight 	    }; (8)
	{ displayphysicalwidth	    }; (9)
	{ displayphysicalheight     }; (10)
	{ displayxposition	    }; (11)
	{ displayyposition	    }; (12)
	{ displayliveregion	    }; (13)

	{ pcmdatacommand	    }; (14)
	{ pcmdatastatus 	    }; (15)
	{ pcmdatachannels	    }; (16)
	{ pcmdatabitspersample	    }; (17)
	{ pcmdatasamplespersec	    }; (18)
	{ pcmdatasilencethreshold   }; (19)
	{ pcmdataorigin 	    }; (20)
	{ pcmdataoffset 	    }; (21)
	{ pcmdatasize		    }; (22)

	{ consolecommand	    }; (23)
	{ consoleinput		    }; (24)

	{ keya			    }; (25)
	{ keyb			    }; (26)
	{ keyc			    }; (27)
	{ keyd			    }; (28)
	{ keye			    }; (29)
	{ keyf			    }; (30)
	{ keyg			    }; (31)
	{ keyh			    }; (32)
	{ keyi			    }; (33)
	{ keyj			    }; (34)
	{ keyk			    }; (35)
	{ keyl			    }; (36)
	{ keym			    }; (37)
	{ keyn			    }; (38)
	{ keyo			    }; (39)
	{ keyp			    }; (40)
	{ keyq			    }; (41)
	{ keyr			    }; (42)
	{ keys			    }; (43)
	{ keyt			    }; (44)
	{ keyu			    }; (45)
	{ keyv			    }; (46)
	{ keyw			    }; (47)
	{ keyx			    }; (48)
	{ keyy			    }; (49)
	{ keyz			    }; (50)

	{ key0			    }; (51)
	{ key1			    }; (52)
	{ key2			    }; (53)
	{ key3			    }; (54)
	{ key4			    }; (55)
	{ key5			    }; (56)
	{ key6			    }; (57)
	{ key7			    }; (58)
	{ key8			    }; (59)
	{ key9			    }; (60)

	{ keyf1 		    }; (61)
	{ keyf2 		    }; (62)
	{ keyf3 		    }; (63)
	{ keyf4 		    }; (64)
	{ keyf5 		    }; (65)
	{ keyf6 		    }; (66)
	{ keyf7 		    }; (67)
	{ keyf8 		    }; (68)
	{ keyf9 		    }; (69)
	{ keyf10		    }; (70)
	{ keyf11		    }; (71)
	{ keyf12		    }; (72)
	{ keyf13		    }; (73)
	{ keyf14		    }; (74)
	{ keyf15		    }; (75)
	{ keyf16		    }; (76)
	{ keyf17		    }; (77)
	{ keyf18		    }; (78)
	{ keyf19		    }; (79)
	{ keyf20		    }; (80)
	{ keyf21		    }; (81)
	{ keyf22		    }; (82)
	{ keyf23		    }; (83)
	{ keyf24		    }; (84)

	{ keybackspace		    }; (85)
	{ keytab		    }; (86)
	{ keyreturn		    }; (87)
	{ keyescape		    }; (88)
	{ keyspacebar		    }; (89)

	{ keyinsert		    }; (90)
	{ keydelete		    }; (91)
	{ keyhome		    }; (92)
	{ keyend		    }; (93)
	{ keypgup		    }; (94)
	{ keypgdn		    }; (95)
	{ keyup 		    }; (96)
	{ keydown		    }; (97)
	{ keyleft		    }; (98)
	{ keyright		    }; (99)

	{ key0n 		    }; (100)
	{ key1n 		    }; (101)
	{ key2n 		    }; (102)
	{ key3n 		    }; (103)
	{ key4n 		    }; (104)
	{ key5n 		    }; (105)
	{ key6n 		    }; (106)
	{ key7n 		    }; (107)
	{ key8n 		    }; (108)
	{ key9n 		    }; (109)
	{ keyslash		    }; (110)
	{ keyasterisk		    }; (111)
	{ keyhyphen		    }; (112)
	{ keycross		    }; (113)
	{ keydot		    }; (114)

	{ keyshift		    }; (115)
	{ keycontrol		    }; (116)
	{ keyalternate		    }; (117)
	{ keypause		    }; (118)
	{ keynumlock		    }; (119)
	{ keycapslock		    }; (120)
	{ keyscrolllock 	    }; (121)
	{ keyunclassified	    }; (122)

	{ pointercommand	    }; (123)
	{ pointermode		    }; (124)
	{ pointerstatus 	    }; (125)
	{ pointerdeltax 	    }; (126)
	{ pointerdeltay 	    }; (127)
	{ pointerdeltaz 	    }; (128)
	{ pointerxcoordinate	    }; (129)
	{ pointerycoordinate	    }; (130)
	{ pointerzcoordinate	    }; (131)

	{ filecommand		    }; (132)
	{ filestatus		    }; (133)
	{ blockpointer		    }; (134)
	{ blocksize		    }; (135)
	{ filename		    }; (136)
	{ filesize		    }; (137)
	{ fileposition		    }; (138)

	{ timercommand		    }; (139)
	{ year			    }; (140)
	{ month 		    }; (141)
	{ day			    }; (142)
	{ dayofweek		    }; (143)
	{ hour			    }; (144)
	{ minute		    }; (145)
	{ second		    }; (146)
	{ milliseconds		    }; (147)
	{ counts		    }; (148)
	{ countspermillisecond	    }; (149)

	{ apdcommand		    }; (150)
	{ apdline		    }; (151)
	{ apdlines		    }; (152)
	{ apdstatus		    }; (153)
	{ apdxmeter		    }; (154)
	{ apdymeter		    }; (155)
	{ apdzmeter		    }; (156)

	{ printercommand	    }; (157)
	{ pageorigin		    }; (158)
	{ pagewidth		    }; (159)
	{ pageheight		    }; (160)

	{ processcommand	    }; (161)
	{ sleeptimeout		    }; (162)

	{ netcommand		    }; (163)
	{ netstatus		    }; (164)
	{ socket		    }; (165)
	{ hostname		    }; (166)
	{ hostaddress		    }; (167)
	{ port			    }; (168)
	{ netblockpointer	    }; (169)
	{ netblocksize		    }; (170)
	{ maxconnections	    }; (171)
	{ connections		    }; (172)
	{ clients		    }; (173)

	{ globalkcommand	    }; (174)
	{ globalkname		    }; (175)
	{ globalkdata		    }; (176)

	{ clipcommand		    }; (177)
	{ clipsize		    }; (178)
	{ clipstring		    }; (179)

	{ appdata		    }; (180)		(size 0 units, marker)

      packed pr wksp finish = 0 *** 0; (end of data marker)

    make: units;

    (parser-related)

	libs string = { ibraries }; (strings giving period names, but after)
	stck string = { tockfile }; (first letter's comparison, because the)
	dirs string = { irectors }; (first letter is checked before the rest)
	cons string = { onstants };
	vars string = { ariables };
	wksp string = { orkspace };
	prog string = { rogramme };

	junc string = { ,_     }; (strings' accessories)
	vjun string = { _=_    };
	file string = { file:_ };
	line string = { line:_ };
	eol	    = { \cr\lf };

	args string = { ,_commandline_error:_ }; (errors classification)
	perr string = { ,_parse_error:_       };
	synt string = { ,_syntax_error:_      };
	decl string = { ,_declaration_error:_ };
	intr string = { ,_internal_problem:_  };
	fser string = { ,_file_system_error:_ };
	link string = { ,_linker_error:_      };
	warn string = { ,_warning:_	      };

	pfx sizeof  = { sizeof	}; (stockfile symbols' "sizeof" prefix)
	pfx nolabel = { nolabel }; ("no label" pfx. for variables & workspace)
	pfx vector  = { vector	}; ("vector" pfx. for variables)
	pfx matrix  = { matrix	}; ("matrix" pfx. for variables)
	pfx array   = { array	}; ("array" pfx. for variables - post 1.14)
	pfx service = { service }; ("service" pfx. for code labels)
	pfx shared  = { shared	}; ("shared" pfx. for all symbols - post 1.14)

	tag extend upto     = { extendupto }; (static data alignment tags)
	tag align at	    = { alignat };
	tag make	    = { make };
	tag bits	    = { bits };
	tag nybbles	    = { nybbles };
	tag compact strings = { compactstrings };
	tag bytes	    = { bytes };
	tag words	    = { words };
	tag doublewords     = { doublewords };
	tag quadwords	    = { quadwords };
	tag units	    = { units };

	op isokernel = { [isokernel]   }; (implicit operand of an isocall)
	tag isocall  = { isocall       }; (instruction tags)
	tag leave    = { leave	       };
	tag end      = { end	       };
	tag fail     = { fail	       };
	tag showregs = { showregisters };
	tag nop      = { nop	       };
	tag ok	     = { ok	       };
	tag failed   = { failed        };

	cls constant = { ,_con:_ }; (symbols classification, for mapping)
	cls variable = { ,_var:_ };
	cls wrkspace = { ,_ptr:_ };
	cls usrlabel = { ,_lab:_ };

	lnk string = { link:_ }; (used in symbols map to log compound names)

    (compiler's error messages)

      make: bytes;

	msg missing env argument =
	  { missing_env_argument.\cr\lf };
	msg missing cpu argument =
	  { missing_cpu_argument.\cr\lf };
	msg missing sys argument =
	  { missing_sys_argument.\cr\lf };
	msg missing ext argument =
	  { missing_ext_argument.\cr\lf };
	msg error reading cpu pack =
	  { error_reading_cpu_pack.\cr\lf };
	msg invalid cpu pack =
	  { invalid_cpu_pack.\cr\lf };
	msg out of memory reading cpu pack =
	  { out_of_memory_reading_cpu_pack.\cr\lf };
	msg read error =
	  { read_error.\cr\lf };
	msg emission to unknown period =
	  { emission_to_unknown_period.\cr\lf };
	msg misplaced string declaration =
	  { misplaced_string_declaration.\cr\lf };
	msg syntax error in code string =
	  { syntax_error_in_code_string.\cr\lf };
	msg need code label for relative address streaming =
	  { need_code_label_for_relative_address_streaming.\cr\lf };
	msg value out of specified operand size range =
	  { value_out_of_specified_operand_size_range.\cr\lf };
	msg label too long =
	  { label_too_long.\cr\lf };
	msg extra input before label =
	  { extra_input_before_label.\cr\lf };
	msg invalid compound specification =
	  { invalid_compound_specification.\cr\lf };
	msg too many signs =
	  { too_many_signs.\cr\lf };
	msg operand too long =
	  { operand_too_long.\cr\lf };
	msg too many operands =
	  { too_many_operands.\cr\lf };
	msg misplaced period =
	  { misplaced_period.\cr\lf };
	msg unknown period or misplaced user code label =
	  { unknown_period_or_misplaced_user_code_label.\cr\lf };
	msg extra input after string =
	  { extra_input_after_string.\cr\lf };
	msg unit director must be specified =
	  { unit_director_must_be_specified.\cr\lf };
	msg unable to access sys pack =
	  { unable_to_access_sys_pack.\cr\lf };
	msg wrong number of runtime module variants =
	  { wrong_number_of_runtime_module_variants.\cr\lf };
	msg no initialization paragraph found in runtime module =
	  { no_initialization_paragraph_found_in_runtime_module.\cr\lf };
	msg could not write initialization paragraph =
	  { could_not_write_initialization_paragraph.\cr\lf };

	msg too much nidification =
	  { too_much_nidification.\cr\lf };
	msg cannot read from library =
	  { cannot_read_from_library.\cr\lf };
	msg library not found =
	  { library_not_found.\cr\lf };

	msg stockfile compound not found =
	  { stockfile_compound_not_found.\cr\lf };
	msg cannot access compound =
	  { cannot_access_compound.\cr\lf };
	msg cannot include two compounds having same name =
	  { cannot_include_two_compounds_having_same_name,_
	    or_compounds_having_predefined_symbol_names.\cr\lf };
	msg failed to concatenate compound to stockfile =
	  { failed_to_concatenate_compound_to_stockfile.\cr\lf };

	msg wrong director statement =
	  { wrong_director_statement.\cr\lf };
	msg there can be only one hash string =
	  { there_can_be_only_one_hash_string.\cr\lf };
	msg invalid symbol hash =
	  { invalid_symbol_hash.\cr\lf };
	msg director can only hold immediate value =
	  { director_can_only_hold_immediate_value.\cr\lf };
	msg incompatible unit =
	  { incompatible_unit.\cr\lf };
	msg negative cpu delay =
	  { negative_cpu_delay.\cr\lf };
	msg unsupported modular extension =
	  { unsupported_modular_extension.\cr\lf };
	msg invalid thread priority =
	  { invalid_thread_priority.\cr\lf };
	msg invalid display coordinate =
	  { invalid_display_coordinate.\cr\lf };
	msg invalid display dimension =
	  { invalid_display_dimension.\cr\lf };
	msg invalid display mode =
	  { invalid_display_mode.\cr\lf };
	msg invalid pointer mode =
	  { invalid_display_mode.\cr\lf };
	msg unsupported test flag =
	  { unsupported_test_flag.\cr\lf };
	msg unknown director tag =
	  { unknown_director_tag.\cr\lf };
	msg program name is longer than 39 characters =
	  { program_name_is_longer_than_39_characters.\cr\lf };

	msg wrong declaration of constant =
	  { wrong_declaration_of_constant.\cr\lf };
	msg constant needs immediate value =
	  { constant_needs_immediate_value.\cr\lf };
	msg causal ring =
	  { causal_ring.\cr\lf };

	msg could not stream static data to application file =
	  { could_not_stream_static_data_to_application_file.\cr\lf };
	msg wrong declaration of variable =
	  { wrong_declaration_of_variable.\cr\lf };
	msg variable initialization needs immediate value =
	  { variable_initialization_needs_immediate_value.\cr\lf };
	msg duplications count needs immediate value =
	  { duplications_count_needs_immediate_value.\cr\lf };
	msg negative duplications count =
	  { negative_duplications_count.\cr\lf };
	msg unknown alignment directive =
	  { unknown_alignment_directive.\cr\lf };
	msg alignment directive needs immediate value =
	  { alignment_directive_needs_immediate_value.\cr\lf };
	msg illegal value for make directive =
	  { illegal_value_for_make_directive.\cr\lf };
	msg last labeled symbol is longer than that =
	  { last_labeled_symbol_is_longer_than_that.\cr\lf };
	msg invalid alignment =
	  { invalid_alignment.\cr\lf };
	msg useless declaration =
	  { useless_declaration.\cr\lf };

	msg wrong declaration of workspace area label =
	  { wrong_declaration_of_workspace_area_label.\cr\lf };
	msg workspace area allocation needs immediate units count =
	  { workspace_area_allocation_needs_immediate_units_count.\cr\lf };

	msg could not stream code to application file =
	  { could_not_stream_code_to_application_file.\cr\lf };
	msg this is the address of first operand =
	  { this_is_the_address_of_first_operand.\cr\lf };
	msg need code label as destination for jump or call =
	  { need_code_label_as_destination_for_jump_or_call.\cr\lf };
	msg this is the address of second operand =
	  { this_is_the_address_of_second_operand.\cr\lf };
	msg need label as destination of state check directive =
	  { need_label_as_destination_of_state_check_directive.\cr\lf };
	msg need label as destination of integer loop =
	  { need_label_as_destination_of_integer_loop.\cr\lf };
	msg nonsensical code =
	  { nonsensical_code.\cr\lf };
	msg extra operands to instruction =
	  { extra_operands_to_instruction.\cr\lf };
	msg wrong usage of comparison directive =
	  { wrong_usage_of_comparison_directive.\cr\lf };
	msg need label as destination of comparison directive =
	  { need_label_as_destination_of_comparison_directive.\cr\lf };
	msg nonsensical split using same operand =
	  { nonsensical_split_using_same_operand.\cr\lf };
	msg unsupported instruction syntax =
	  { unsupported_instruction_syntax.\cr\lf };
	msg unrecognized instruction =
	  { unrecognized_instruction.\cr\lf };
	msg open program =
	  { open_program,_been_forcing_an_"end"_tag.\cr\lf };

	msg could not retrieve final size of application file =
	  { could_not_retrieve_final_size_of_application_file.\cr\lf };

	msg expression syntax error =
	  { expression_syntax_error.\cr\lf };
	msg value is not integer =
	  { value_is_not_integer.\cr\lf };
	msg misplaced register in indirection =
	  { misplaced_register_in_indirection.\cr\lf };
	msg extra input after standalone register =
	  { extra_input_after_standalone_register.\cr\lf };
	msg undeclared symbol or illegal immediate value =
	  { undeclared_symbol_or_illegal_immediate_value.\cr\lf };
	msg xivision by zero in linear expression =
	  { division_by_zero_in_linear_expression.\cr\lf };

	msg void symbol name =
	  { void_symbol_name.\cr\lf }; (typically a void label)
	msg illegal symbol name =
	  { illegal_compound_or_symbol_name.\cr\lf }; (applies to comps. too)
	msg too many symbols =
	  { too_many_symbols.\cr\lf }; (internal problem)
	msg symbol already declared =
	  { symbol_already_declared.\cr\lf };

      make: units;

    (parse operand)

	tgpragm      = { pragma };    (searched at beginning of expression)
	tgxultiplied = { ultiplied }; (string's rest of tag "multiplied")
	tgxinus      = { inus };      (string's rest... etc...)
	tgxtp	     = { tp };
	tgxelating   = { elating };
	tgxivided    = { ivided };
	tgxiv	     = { iv };
	tgxlus	     = { lus };
	tgxsbytesize = { sbytesize };

    (put symbol)

	ftpragm      = { pragma };     (searched within symbol names)
	ftxultiplied = { multiplied };
	ftxinus      = { minus };
	ftxtp	     = { mtp };
	ftxelating   = { relating };
	ftxivided    = { didived };
	ftxiv	     = { div };
	ftxlus	     = { plus };
	ftxsbytesize = { asbytesize };

    (service dirs parser)

	dir unit	      = { unit };
	dir modularextensions = { modularextensions };
	dir programname       = { programname };
	dir threadpriority    = { threadpriority };
	dir displayxposition  = { displayxposition };
	dir displayyposition  = { displayyposition };
	dir displaywidth      = { displaywidth };
	dir displayheight     = { displayheight };
	dir displaymode       = { displaymode };
	dir pointermode       = { pointermode };
	dir symbolsmap	      = { symbolsmap };
	dir testflags	      = { testflags };
	dir symbolhash	      = { symbolhash };

    ( instruction patterns index, 609 records, 3x5 bits per record

      destination operand type to match variant
	|
	|	      source operand type to match variant
	|		|
	|		|		      number of variants,
	|		|		      complessively 6241
	|		|			|
	|		|			| )

    make: 5;

    vector packed ip records =

	( assignment )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( unconditioned jump )

	immediate;	null;			1;
	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( jump to subroutine )

	immediate;	null;			1;
	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( CPU delay loop, used mostly for application stressing )

	immediate;	null;			1;

	( push on stack )

	immediate;	null;			1;
	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( pop from stack )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( integer increment )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( integer decrement )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( integer loop until zero )

	register;	immediate;		5;
	direct; 	immediate;		1;
	indirect;	immediate;		5;

	( jump if subroutine was successful )

	immediate;	null;			1;

	( jump if subroutine failed )

	immediate;	null;			1;

	( return from FAILED subroutine )

	null;		null;			1;

	( return from SUCCESSFUL subroutine or quit main program )

	null;		null;			1;

	( return from subroutine without state report [just return] )

	null;		null;			1;

	( integer addition )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer subtraction )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise AND )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise inclusive OR )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise exclusive OR )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise unsigned shift right )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise unsigned shift left )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if equal [signed/unsigned] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if not equal [signed/unsigned] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer signed multiplication )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer signed division )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer signed remainder )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise NOT )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( add to stack pointer )

	immediate;	null;			1;
	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( subtract from stack pointer )

	immediate;	null;			1;
	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( floating-point sine )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( floating-point cosine )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( floating-point square root )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( integer negation )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( floating-point negation )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( integer absolute value )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( floating-point absolute value )

	register;	null;			5;
	direct; 	null;			1;
	indirect;	null;			5;

	( assignment from stack [with immediate relative displacement] )

	register;	immediate;		5;
	direct; 	immediate;		1;
	indirect;	immediate;		5;

	( assignment to stack space [with immediate relative displacement] )

	immediate;	immediate;		1;
	immediate;	register;		5;
	immediate;	direct; 		1;
	immediate;	indirect;		5;

	( bitwise signed shift right )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise rotate right )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise rotate left )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer unsigned multiplication )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer unsigned division )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer unsigned remainder )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point addition )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point subtraction )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point multiplication )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point division )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( convert floating-point to signed integer )

	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( convert signed integer to floating-point )

	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise test and jump if zero )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( bitwise test and jump if not zero )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if greater [unsigned] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if lower [unsigned] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if greater or equal [unsigned] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if lower or equal [unsigned] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if greater [signed] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if lower [signed] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if greater or equal [signed] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer compare and jump if lower or equal [signed] )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point compare and jump if equal )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point compare and jump if not equal )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point compare and jump if greater )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point compare and jump if lower )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point compare and jump if greater or equal )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point compare and jump if lower or equal )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point partial remainder )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( floating-point partial arc tangent )

	register;	immediate;		5;
	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	immediate;		1;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	immediate;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( NOP )

	null;		null;			1;

	( integer unsigned split )

	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( integer signed split )

	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

	( push all registers )

	null;		null;			1;

	( pop all registers )

	null;		null;			1;

	( exchange values )

	register;	register;	       25;
	register;	direct; 		5;
	register;	indirect;	       25;
	direct; 	register;		5;
	direct; 	direct; 		1;
	direct; 	indirect;		5;
	indirect;	register;	       25;
	indirect;	direct; 		5;
	indirect;	indirect;	       25;

    make: units;

    ( instruction patterns quick reference, 74 records, 9 units per record

 courtesy markers, for <extend upto> tag starting points and other references
   |
   |   symbolic instruction code, 7 units per string, max = 6 chars. + null
   |	 |
   |	 |			   number of patterns
   |	 |			     |
   |	 |			     | number of index units in above vector
   |	 |			     |	 |
   |	 |			     |	 | )

    ip quickreference =

       { =	}; extend upto: 7; 132; 36;
 q01 = { ->	}; extend upto: 7;  12; 12;
 q02 = { =>	}; extend upto: 7;  12; 12;
 q03 = { ---	}; extend upto: 7;   1;  3; (CPU delay, undocumented)
 q04 = { -->	}; extend upto: 7;  12; 12;
 q05 = { <--	}; extend upto: 7;  11;  9;
 q06 = { +	}; extend upto: 7;  11;  9;
 q07 = { -	}; extend upto: 7;  11;  9;
 q08 = { ^	}; extend upto: 7;  11;  9;
 q09 = { ?:)->	}; extend upto: 7;   1;  3; (jump on success, internal code)
 q10 = { ?:(->	}; extend upto: 7;   1;  3; (jump on failure, internal code)
 q11 = { \\/\\	}; extend upto: 7;   1;  3; (fail, internal code)
 q12 = { /\\/	}; extend upto: 7;   1;  3; (end, internal code)
 q13 = { (/	}; extend upto: 7;   1;  3; (leave, internal code)
 q14 = { +	}; extend upto: 7; 132; 36;
 q15 = { -	}; extend upto: 7; 132; 36;
 q16 = { &	}; extend upto: 7; 132; 36;
 q17 = { |	}; extend upto: 7; 132; 36;
 q18 = { #	}; extend upto: 7; 132; 36;
 q19 = { >	}; extend upto: 7; 132; 36;
 q20 = { <	}; extend upto: 7; 132; 36;
 q21 = { ?=->	}; extend upto: 7; 132; 36;
 q22 = { ?!=->	}; extend upto: 7; 132; 36;
 q23 = { *	}; extend upto: 7; 132; 36;
 q24 = { /	}; extend upto: 7; 132; 36;
 q25 = { %	}; extend upto: 7; 132; 36;
 q26 = { !	}; extend upto: 7;  11;  9;
 q27 = { $+	}; extend upto: 7;  12; 12;
 q28 = { $-	}; extend upto: 7;  12; 12;
 q29 = { ~	}; extend upto: 7;  11;  9;
 q30 = { ~~	}; extend upto: 7;  11;  9;
 q31 = { /~	}; extend upto: 7;  11;  9;
 q32 = { +-	}; extend upto: 7;  11;  9;
 q33 = { ++--	}; extend upto: 7;  11;  9;
 q34 = { ||	}; extend upto: 7;  11;  9;
 q35 = { ||||	}; extend upto: 7;  11;  9;
 q36 = { =$:	}; extend upto: 7;  11;  9;
 q37 = { $:=	}; extend upto: 7;  12; 12;
 q38 = { >>	}; extend upto: 7; 132; 36;
 q39 = { @>	}; extend upto: 7; 132; 36;
 q40 = { <@	}; extend upto: 7; 132; 36;
 q41 = { *'	}; extend upto: 7; 132; 36;
 q42 = { /'	}; extend upto: 7; 132; 36;
 q43 = { %'	}; extend upto: 7; 132; 36;
 q44 = { ++	}; extend upto: 7; 132; 36;
 q45 = { --	}; extend upto: 7; 132; 36;
 q46 = { **	}; extend upto: 7; 132; 36;
 q47 = { //	}; extend upto: 7; 132; 36;
 q48 = { =,	}; extend upto: 7; 121; 27;
 q49 = { ,=	}; extend upto: 7; 121; 27;
 q50 = { ?-->	}; extend upto: 7; 132; 36;
 q51 = { ?+->	}; extend upto: 7; 132; 36;
 q52 = { ?'>->	}; extend upto: 7; 132; 36;
 q53 = { ?'<->	}; extend upto: 7; 132; 36;
 q54 = { ?'>=-> }; extend upto: 7; 132; 36;
 q55 = { ?'<=-> }; extend upto: 7; 132; 36;
 q56 = { ?>->	}; extend upto: 7; 132; 36;
 q57 = { ?<->	}; extend upto: 7; 132; 36;
 q58 = { ?>=->	}; extend upto: 7; 132; 36;
 q59 = { ?<=->	}; extend upto: 7; 132; 36;
 q60 = { ??=->	}; extend upto: 7; 132; 36;
 q61 = { ??!=-> }; extend upto: 7; 132; 36;
 q62 = { ??>->	}; extend upto: 7; 132; 36;
 q63 = { ??<->	}; extend upto: 7; 132; 36;
 q64 = { ??>=-> }; extend upto: 7; 132; 36;
 q65 = { ??<=-> }; extend upto: 7; 132; 36;
 q66 = { %%	}; extend upto: 7; 132; 36;
 q67 = { ^/	}; extend upto: 7; 132; 36;
 q68 = { /-/	}; extend upto: 7;   1;  3; (nop, internal code)
 q69 = { /%'	}; extend upto: 7; 121; 27;
 q70 = { /%	}; extend upto: 7; 121; 27;
 q71 = { ---->	}; extend upto: 7;   1;  3;
 q72 = { <----	}; extend upto: 7;   1;  3;
 q73 = { <>	}; extend upto: 7; 121; 27;



"workspace"

    (global)

    success = 1;		(compiler return state flag on library call)
    stacked regs = 1;		(false if application, true if library call)

    path save = 1024;		(used in library calls to save/restore path)

    shared errorlog name   = 1024; (returned to calling applications)
    shared smblsmap name   = 1024; (returned to calling applications)
    shared executable name = 1024; (returned to calling applications)

    global data start = 0;	(marker)

	mcmd = 1024;		(name of main source file, from cmd. line)
	main = 1024;		(name of main source file, translated)
    no label = 1024 mtp levels; (additional filename buffers, for recursion)
	rcfp = 1024;		(relative compund file path)
    no label = 1024 mtp levels; (additional RCFPs, for recursion)
	levl = 1;		(actual nidification level, main=zero)
	path = 1024;		(path to main source file)

	env setting = 1024;	(environment setting from command line)
	cpu setting = 9;	(CPU pack name, from command line)
	sys setting = 9;	(SYS pack name, from command line)
	ext setting = 9;	(EXT parameter, from command line)
	del setting = 11;	(DEL temporary, from command line)

	baselib = 1024; 	(default libraries root directory)
	basecpu = 1024; 	(formed by: --env + /cpu/ + --cpu)
	basesys = 1024; 	(formed by: --env + /sys/ + --sys)
	applic name = 1024;	(made of main source name + --ext)

	start time = 1; 	(compiler start - milliseconds past midnight)
	stop  time = 1; 	(compiler stop	- milliseconds past midnight)

	text = scache size
	 div bytes per unit;	(source file read cache)
	tpos = 1;		(actual position to read from in source file)
	sccs = 1;		(actually filled portion of cache, in bytes)

	sfbp = 1;		(StockFile Byte Position, global counter)
	atbp = 1;		(Already Tried Base Path for compound, flag)
	sfcs = 1;		(StockFile Compound Size, holder)
	tcfp = 1024;		(Temporary Compound File Path)
	comp = 1024;		(stockfile COMPound file name buffer)
	cpbk = 1024;		(backup of "comp", see notes where used)
	tfsb = 1024;		(Temporary File Search Buffer)

	base dpos = 1;		(base address of user initialized workspace)
	base wpos = 1;		(base address of user "rest of the workspace")
	dpos = 1;		(actual top of initialized workspace)
	wpos = 1;		(actual top of "rest of the workspace")
	prws = 1;		(final top of init. workspace and ptr to rest)

	data = dcache size
	 div 32;		(static data write cache)
	make = 1;		(current value size, in bits, 0 = unit)
	natu = 1;		(flag: streaming data Not Aligned To Unit)
	dbss = 1;		(data bits written since start of cache)
	duss = 1;		(data units written since start of cache)
	dval = 1;		("cat data" routine: data value to stream)
	dlen = 1;		("cat data" routine: data units to stream,
				 "cat unit" wrapper: [dlen] is implicitly 1)

	bins = bcache size
	 div bytes per unit;	(object code write cache)
	bpos = 1;		(actual instruction pointer)
	bbss = 1;		(binary bytes written since start of cache)
	byte = 1;		("cat byte" routine: byte to write)

	stab = max symbols
	 mtp symbol size;	(internal symbols table)
	nods = 1;		(number of defined symbols)
	noss = 1;		(number of support symbols: library names)

	errlog fpos = 1;	(actual position to write to error log file)
	symaps fpos = 1;	(actual position to write to symbols map file)

	unit = 1;		(if set to yes, unit director was specified)
	cpud = 1;		(cpu delay director value)
	smap = 1;		(symbols map - requested if nonzero)
	rtmv = 1;		(run-time module variant to use for link)

	sys header =
	  8 plus 8 plus 1;	(sys header: 8 positions, 8 sizes, 1 counter)
	ipof = 1;		(init. paragraph offset in application file)

    (LNLMInit - Run-Time Module initialization paragraph)

     li 		= null; (void label - marks beginning of structure)
     li app name	= 40 as byte size; (40 bytes, ASCII characters)
     li app ws size	= 1;	(size of initialized workspace, in units)
     li app code size	= 1;	(size of all code, in units)
     li app code entry	= 1;	(position of main "programme" period, units)
     li phys ws entry	= 1;	(physical workspace entry/size of RTM, bytes)
     li phys app size	= 1;	(physical executable file size, in bytes)
     li default ramtop	= 1;	(total size of the workspace, in units)
     li app code pri	= 1;	(thread's priority level, in the range 0 to 4)
     li lfb x atstartup = 1;	(display x position at startup, in pixels)
     li lfb y atstartup = 1;	(display y position at startup, in pixels)
     li lfb w atstartup = 1;	(display width at startup, in pixels)
     li lfb h atstartup = 1;	(display height at startup, in pixels)
     li pointer mode	= 1;	(initial pointing device operating mode, 0/1)
     li test flags	= 1;	(debug and test flags, bitmask, range 0 to 15)
     li display mode	= 1;	(initial display operating mode, 0=coop/1=exc)
     li ends		= null; (void label - marks end of structure)

    (unpack)

	up source = 1;		(ptr to packed data source bitstream)
	up target = 1;		(ptr to unpacked data area)
	up length = 1;		(number of values to unpack)
	up bitspervalue = 1;	(self-explanatory)

    (unpacked data areas)

	pr cons 	= packed pr cons finish minus packed pr cons
			  mtp cpu unit div 7 plus 1;
	pr wksp 	= packed pr wksp finish minus packed pr wksp
			  mtp cpu unit div 7 plus 1;
	ip records	= 609 mtp 3;

    (parser-related)

	prid = 1;		(period ID, starts at -1, for unknown period)
	sssp = 1;		(flag: Suspended Symbols Still Present)
	errs = 1;		(n. of errors: > 0 breaks only between passes)

	pass = 1;		(parser's actual pass number)
	tpss = 1;		(Total PaSseS, to be reported in symbols map)

	flns = 1;		(lines compiled so far in current file)
	fins = 1;		(instructions assembled so far, current file)
	tlns = 1;		(lines compiled so far in all files)
	tins = 1;		(instructions assembled in all files)
	rtlc = 1;		(Reported Total Lines Counter)

	pces = 3 mtp 2048;	(text pieces found between signs, ie operands)
	pnow = 1;		(piece being noted now, multiplied by 2048)
	cnow = 1;		(dest. character offset within current piece)
	inst = 7;		(instruction string buffer, signs in sequence)
	inow = 1;		(dest. character offset within instr. string)
	lnow = 1;		(dest. character offset within current label)
	shlo = 1;		(low unit of symbol hash for current source)
	shhi = 1;		(high unit of symbol hash for current source)
	stst = 1;		(string start marker: 1st byte in source file)
	strd = 1;		(if !=0, [stst] string was the source operand)
	nybb = 1;		(actual value of code nybble, being defined)
	snow = 1;		(dest. character offset within symbol string)
	perp = 1;		(period-specific parser subroutine address)

	temp symbol = 2048;	(used by stockfile parser to assemble sizeof)
	pnbc = 1;		(Program Name Byte Counter, for "cat string")

	lkea = 1;		(Last Known Effective Address, for alignments)
	cd stack waste = 1;	(units to discard in stack on cat data return)

	opx error = 1;		(prevents double error, see prog parser notes)
	op1 class = 1;		(operand #1 class in code instructions parser)
	op2 class = 1;		(operand #2 class in code instructions parser)
	op3 class = 1;		(operand #3 class in code instructions parser)
	op1 regid = 1;		(operand #1 RegID in code instructions parser)
	op2 regid = 1;		(operand #2 RegID in code instructions parser)
	op3 regid = 1;		(operand #3 RegID in code instructions parser)
	op1 value = 1;		(operand #1 value in code instructions parser)
	op2 value = 1;		(operand #2 value in code instructions parser)
	op3 value = 1;		(operand #3 value in code instructions parser)
	dlyd	  = 1;		(strobe flag, to know when to add a CPU delay)
	endt	  = 1;		(flag: if true program is, apparently, closed)
	esav	  = 1;		(register E SAVing, in LM code building loops)
	pp return point = 1;	(variable return point of service prog parser)

    (parse operand)

	po class = 1;		(operand type class)
	po flags = 1;		(operand type flags - composite of expression)
	po error = 1;		(flag: asserted for illegal/suspended values)
	po value = 1;		(operand's expression value)
	po regid = 1;		(operand's involved register ID)
	po float = 1;		(expressions' floating-point presence flag)
	po addrx = 1;		(flag: expression depends on variable/s addr.)
	po inman = 1;		(internal flag: processed mantissa, wait exp.)
	po inexp = 1;		(internal flag: processing exponent)
	po start = 1;		(internal ptr used to mark beginning of value)
	po brkts = 1;		(internal brackets presence flag)
	po pragm = 1;		(operand's "pragma" statement presence flag)

    (parse value)

	pv value = 1;		(converted value string)
	pv modif = 1;		(internal, save of reg B holding modifiers)
	pv point = 1;		(internal, flag: the f-p point has been found)
	pv prtag = 1;		(internal, memory for reg D holding tag)
	pv prmod = 1;		(internal, memory for reg B holding modifiers)

    (get symbol)

	gsgs = 1;		(global search flag: well, "get symbol" will
				 internally run two searchs for each symbol,
				 the first one using the local file hash, if
				 an hash was specified with a "symbol hash"
				 director; the second one, and unless there's
				 no local hashing, using the global file hash,
				 which is a bare null hash; this way, it will
				 resolve both local and globally shared names,
				 granting precence and faster search to local
				 names, typically the most frequently used...)

	symbol name = 1;	(ptr to symbol name string)
	gs symbol record = 1;	(on success, pointer to symbol record)

    (put symbol)

	pshlo = 1;		(internally set to [shlo] for private symbols)
	pshhi = 1;		(internally set to [shhi] for private symbols)

	isfilename = 1; 	(flag: if true "put symbol" accepts any names)
	ps symbol record = 1;	(on success, pointer to new symbol record)

    (log error)

	err string  = 1;	(error string pointer)
	cls string  = 1;	(msg description: parse error, warning etc...)
	line number = 11;	(line number's uitoa destination)

    (log symbol)

	sym string   = 1;	(symbol name pointer)
       (cls string)		(that of "log error", used for symbol class)
	sym value    = 1;	(as input, binary version of symbol's value)
	symbol value = 11;	(as output, symbol value's uitoa destination)

    (log error, log symbol, log report)

	log output = 2048;	(output message buffer)
	log revert = 1000;	(for reverting ASCII strings to fourbyte)

	shared compiler report = 10000; (string buffer, is returned to caller,
					 made out of the last 10 lines of the
					 symbols' map, and void on error)

    (strlen, atofb, fbtoa, strcmp, strcpy, strcat, atoui, uitoa)

	source string = 1;	(pointer to source string)
	target string = 1;	(pointer to destination string)
	string length = 1;	(units or bytes in source string)

    (autoui, uitoa)

	string binary = 1;	(string's numerical result/input)

    (uitoa)

	uitoa helping = 9;	(uitoa helper, transient buffer)

    (fcpy and fcat)

	source file = 1;	(pointer to source file's name string)
	source fpos = 1;	(byte from which starting reading)
	target file = 1;	(pointer to target file's name string)
	target fpos = 1;	(byte from which starting writing)
	transf size = 1;	(size of transfer, full file if negative)
	fcpy verify = 1;	(internal counter - for writes verify)

	fcpy callback = 1;	(callback parser, thought for this compiler)

	ffun cache = sizeof ffun cache; (fcpy/fcat data transfer buffer)

    (swap endian)

	area to swap = 1; (ptr to memory area to swap bytes in)
	size of area to swap = 1; (number of doublewords in that area)

    (cpu pack fields)

	cpp algn = 1;		(instruction patterns alignment)
	cpp ter1 = 1;		(instruction patterns termination byte #1)
	cpp ter2 = 1;		(instruction patterns termination byte #2)
	bea = 1;		(Big Endian Activation bitmask)
	acc = 1;		(cpu's ACCessory flags bitmask)

    (cpu pack block)

	cpu pack = 6241 (total number of patterns to read in this buffer)
	  mtp 256 as byte size (support upto maximum 256-byte alignment)
	  plus 2; (plus the header, which is assumed to be 2 units)

    global data finish = 0;	(marker)



"programme"

    (standalone application starter)

	-> start;

    (public entry: save regs and path, clean up global data)

      "shared compile"
	a -->;
	b -->;
	c -->;
	d -->;
	e -->;
	[stacked regs] = true;
	[success] = false;
	a = global data start;
	b = global data finish minus global data start;
      "gd cleanup"
	[a] = null; a +;
	b ^ gd cleanup;
	[file command] = get dir;
	[file name] = path save;
	isocall;

    (take start time)

      "start"
	[timer command] = read time;
	isocall;
	[hour]	 * 3 600 000;
	[minute] *    60 000;
	[second] *     1 000;
	[start time] = [hour];
	[start time] + [minute];
	[start time] + [second];
	[start time] + [milliseconds];

    (extract source file path - fail silently if not specified or empty)

	[source string] = commandline;
	[target string] = src option;
	=> strstr;
      ? failed -> allstop;
	b = mcmd;
	d = 1023;
	=> copy option;
      ? [mcmd] = null -> allstop;

    (filter mcmd string, eventually trimming doublequotes from each end:
     oh, yes, register B was left to point at the null terminator of mcmd
     from the above call to "copy option", and because of the above check,
     the string can't be void here, so [b minus 1] is always part of mcmd...)

      ? [b minus 1] != quotes -> no final dblquote;
	[b minus 1] = null;
	b -; (reg B is needed after this operation to point at null term.)
      "no final dblquote"
      ? [mcmd] != quotes -> no initial dblquote;
      (the following strcpy works, beware, only because I know the loop used
       in "strcpy" proceeds forward, from left to right in the string: it
       wouldn't be able to shift the string to the right...)
	[source string] = mcmd plus 1;
	[target string] = mcmd;
	=> strcpy; (copy to itself, shifting everything one char. to the left)
	b -; (update reg B, must still point to null terminator)
      "no initial dblquote"

    (extract path from source file name parameter:
     this is theoretically system-specific, however the compiler will consider
     as part of the path whatever character is not an alphanumeric sign, not a
     blank space, not an underscore, and not a dot: it scans the "main" string
     in backwards, and later it will copy to the "path" string buffer all the
     characters preceeding the very first occurrence of a possible delimiter:
     if more can be done, then I don't know how...)

      "getpath"
      "gp no sign"
	b -;
      ? b > mcmd -> gp continue;
	d = mcmd; (point reg D at file name: void path case)
	-> gp void path;
      "gp continue"
	c = [b];
      ? c > 122 -> gp is sign; (beyond lowercase letters)
      ? c > 096 -> gp no sign; (within lowercase letters)
      ? c > 090 -> gp is sign; (beyond uppercase letters)
      ? c > 064 -> gp no sign; (within uppercase letters)
      ? c < 048 -> gp is sign; (before all digits 0 to 9)
      ? c < 058 -> gp no sign; (within all digits 0 to 9)
      "gp is sign"
      ? c = dot -> gp no sign; (filename accessory)
      ? c = blank -> gp no sign; (filename accessory)
      ? c = underscore -> gp no sign; (filename accessory)
	d = b; (point reg D at file name: non-void path case)
	d +;
      "gp void path"
	a = b;
	a - mcmd;
	a + path;
	[a] = null;
      "copy path"
      ? a = path -> copied path;
	a -;
	b -;
	[a] = [b];
	-> copy path;
      "copied path"

    (reach the work path of the main source code to compile:
     if you can't, fail silently - there can't be error logs outside the path)

	[filecommand] = set dir;
	[filename] = path;
	isocall;
      ? failed -> allstop;

    (this "get dir" is only for having the system-specific run-time module
     convert the path to the main source file to L.in.oleum universal file
     system syntax: often not necessary, but it's for coherence in logs)

	[filecommand] = get dir;
	[filename] = path;
	isocall;
	[source string] = path;
	[target string] = main;
	=> strcpy;
      ? d = mcmd -> no junction for void path;
	[source string] = path junction;
	=> strcat;
      "no junction for void path"
	[source string] = d;
	=> strcat;

    (mount application file name:
     - it's given by the source file name;
     - if that file has .txt extension, in applic name it's removed;
     - after that, the extension given as --ext is appended.)

	[source string] = commandline;
	[target string] = ext option;
	=> strstr;
      ? ok -> ext given;
	[err string] = msg missing ext argument;
	[cls string] = args string;
	=> log error;
	-> allstop;
      "ext given"
	b = ext setting;
	d = 8;
	=> copy option;

	[source string] = main;
	[target string] = applic name;
	=> strcpy;
	=> strlen;
	a = [string length];
      ? a < 4
	  -> no extension given in main source file name;
      ? [a minus 4 relating applic name] != dot
	  -> no extension given in main source file name;
	[a minus 4 relating applic name] = null;
      "no extension given in main source file name"
	[source string] = ext setting;
	=> strcat;

    (cleanup possibly existing output files)

	[filecommand] = destroy;
	[filename] = errlog name;
	isocall;
	[filecommand] = destroy;
	[filename] = symaps name;
	isocall;
	[filecommand] = destroy;
	[filename] = applic name;
	isocall;

    (extract other command line options)

	[source string] = commandline;
	[target string] = env option;
	=> strstr;
      ? ok -> env given;
	[err string] = msg missing env argument;
	[cls string] = args string;
	=> log error;
	-> allstop;
      "env given"
	b = env setting;
	d = 1023;
	=> copy option;
	[source string] = env setting;
	[target string] = baselib;
	=> strcpy;
	[source string] = env junction;
	=> strcat;

	[source string] = commandline;
	[target string] = cpu option;
	=> strstr;
      ? ok -> cpu given;
	[err string] = msg missing cpu argument;
	[cls string] = args string;
	=> log error;
	-> allstop;
      "cpu given"
	b = cpu setting;
	d = 8;
	=> copy option;
      ? [cpu setting] = null -> allstop;
	[source string] = env setting;
	[target string] = basecpu;
	=> strcpy;
	[source string] = cpu junction;
	=> strcat;
	[source string] = cpu setting;
	=> strcat;
	[source string] = bin extension;
	=> strcat;

	[source string] = commandline;
	[target string] = sys option;
	=> strstr;
      ? ok -> sys given;
	[err string] = msg missing sys argument;
	[cls string] = args string;
	=> log error;
	-> allstop;
      "sys given"
	b = sys setting;
	d = 8;
	=> copy option;
      ? [sys setting] = null -> allstop;
	[source string] = env setting;
	[target string] = basesys;
	=> strcpy;
	[source string] = sys junction;
	=> strcat;
	[source string] = sys setting;
	=> strcat;
	[source string] = bin extension;
	=> strcat;

	[source string] = commandline;
	[target string] = del option;
	=> strstr;
      ? failed -> no cpu delay requested;
	b = del setting;
	d = 10;
	=> copy option;
	[source string] = del setting;
	=> atoui;
      ? [string binary] < zero -> no cpu delay requested;
	[cpud] = [string binary];
      "no cpu delay requested"

    (load up non-zero defaults in initialization paragraph)

	[li app code pri]     = normal priority;
	[li lfb x at startup] = middle;
	[li lfb y at startup] = middle;
	[li lfb w at startup] = 256;
	[li lfb h at startup] = 192;
	[li display mode]     = cooperative;
	[li pointer mode]     = by coordinate;

	[source string] = default program name;
	[target string] = li app name;
	=> fbtoa;

    (declare all predefined constants)

      (unpack predefined constants)
	[up source] = packed pr cons;
	[up target] = pr cons;
	[up length] = packed pr cons finish minus packed pr cons
		      mtp cpu unit div 7 plus 1;
	[up bitspervalue] = 7;
	=> unpack;
      (begin constants declaration)
	a = pr cons; (record pointer)
	b = zero;    (record number)
	c = 106;     (records to loop for)
      "pr cons loop"
      (declare symbol, get symbol record pointer)
	=> put symbol; d = [ps symbol record];
      (advance A after the end of the symbol name string)
	[source string] = a; => strlen; a + [string length];
      (route for special cases of values that couldn't pack properly)
      ? b = 067 -> pr cons rec067;
      ? b = 068 -> pr cons rec068;
      ? b = 101 -> pr cons rec101;
      ? b = 102 -> pr cons rec102;
      ? b = 103 -> pr cons rec103;
      ? b = 105 -> pr cons rec105;
      (set value in all the other cases)
	e = [a plus 1];
	-> pr cons set;
      (special cases list)
      "pr cons rec067" e =  1048577d; -> pr cons set;
      "pr cons rec068" e = ffffffffh; -> pr cons set;
      "pr cons rec101" e = 3f3f3f3fh; -> pr cons set;
      "pr cons rec102" e = ffffffffh; -> pr cons set;
      "pr cons rec103" e = 7fffffffh; -> pr cons set;
      "pr cons rec105" e = 80000000h;	"pr cons set"
      (set value and flags in symbol record)
	[d plus value] = e;
	[d plus flags] = constant;
      (advance pointers:
       add 2 to A to skip null string terminator and the value field,
       increase B as the record number to distinguish special cases,
       loop until C as the remaining records counter gets to zero)
	a + 2;
	b +;
	c ^ pr cons loop;

    (declare [CodeOrigin], take <base dpos> to address user variables)

	a = str codeorigin;
	=> put symbol;
	a = [ps symbol record];
	[a plus value] = zero; (fixed address, beginning of workspace)
	[a plus flags] = static; (it's a simple variable)
	[base dpos] = 32; (declared only one 32-bit variable)

    (declare predefined workspace, take <base wpos> to address user workspace)

      (unpack predefined workspace labels)
	[up source] = packed pr wksp;
	[up target] = pr wksp;
	[up length] = packed pr wksp finish minus packed pr wksp
		      mtp cpu unit div 7 plus 1;
	[up bitspervalue] = 7;
	=> unpack;
      (begin workspace declaration)
	a = pr wksp; (record pointer)
	b = zero;    (record number)
      "pr wksp loop"
      (declare symbol, get symbol record pointer)
	=> put symbol; d = [ps symbol record];
      (advance A after the end of the symbol name string)
	[source string] = a; => strlen; a + [string length];
      (route for special cases of sizes that couldn't pack properly)
      ? b = 003 -> pr wksp rec003;
      ? b = 180 -> pr wksp rec180;
      (set 1 unit size and <static> flag in all the other cases)
	[d plus value] = [base wpos];
	[d plus flags] = static;
	[base wpos] +;
	-> pr wksp next;
      (special case: commandline vector [32768 units])
      "pr wksp rec003"
	[d plus value] = [base wpos];
	[d plus flags] = static plus address;
	[base wpos] + 32768;
      (advance pointers:
       increase A to skip null string terminator,
       increase B as the record number to distinguish special cases)
      "pr wksp next"
	a +;
	b +;
	-> pr wksp loop;
      (special case: appdata [legacy marker, end of loop])
      "pr wksp rec180"
	[d plus value] = [base wpos];
	[d plus flags] = static;

    (unpack instruction patterns index records)

	[up source] = vector packed ip records;
	[up target] = ip records;
	[up length] = 609 mtp 3;
	[up bitspervalue] = 5;
	=> unpack;

    (load up CPU pack)

      (read header, extract fields)
	[file command] = read;
	[file name] = basecpu;
	[file position] = zero;
	[block pointer] = cpu pack;
	[block size] =
	  6241	  (total number of patterns)
	  mtp 256 (upto supporting 256-byte alignment)
	  plus 8; (plus the header, which is assumed to be 2 units)
	isocall;
      ? ok -> cpp j1;
	[err string] = msg error reading cpu pack;
	[cls string] = fser string;
	=> log error;
	-> allstop;
      "cpp j1"
	[cpp algn] = [cpu pack plus 0];
	[cpp algn] & FFh; (insulate patterns alignment byte in first unit)
      ? [cpp algn] > zero -> cpp j2;
	[cpp algn] = 256; (instruction patterns alignment = zero means 256)
      "cpp j2"
      (this is an actual limit of the compiler; it uses a fixed-size buffer to
       load the CPU pack, but it couldn't do it differently for two reasons:
       - it might be functional using only file group functions of the RTM;
       - it can be a library and might not interfere with main program ramtop.
       so, this is to check if there's enough memory to hold the CPU pack...)
      ? [file size] <=
	  6241	  (total number of patterns)
	  mtp 256 (upto supporting 256-byte alignment)
	  plus 8  (plus the header, which is assumed to be 2 units)
	    -> cpp j3;
	[err string] = msg out of memory reading cpu pack;
	[cls string] = intr string;
	=> log error;
	-> allstop;
      "cpp j3"
      (this is a validity check for the CPU pack: the whole file whose size is
       always returned by active file operations such as the above <read>, has
       to be exactly <alignment * 6241 + 8> bytes in size, not more, not less)
	a = [cpp algn];
	a * 6241;
	a + 8;
      ? a = [file size] -> cpp j4;
	[err string] = msg invalid cpu pack;
	[cls string] = intr string;
	=> log error;
	-> allstop;
      "cpp j4"
	[cpp ter1] = [cpu pack plus 1];
	[cpp ter1] & FFh; (insulate termination code byte #1)
	[cpp ter2] = [cpu pack plus 1];
	[cpp ter2] > 8;
	[cpp ter2] & FFh; (insulate termination code byte #2)
	[bea] = [cpu pack plus 1];
	[bea] > 16;
	[bea] & FFh; (insulate Big Endian Activation bitmask)
	[acc] = [cpu pack plus 1];
	[acc] > 24;
	[acc] & FFh; (insulate cpu's ACCessory flags bitmask)

    (begin compiling)

	[pass] = 1;	      (this is the first pass)
	[sfbp] = 0;	      (reset stockfile byte pos. counter)
	[bpos] = 0;	      (reset instruction pointer)
	[dpos] = [base dpos]; (reset top of workspace)
	[wpos] = [base wpos]; (reset top of rest of workspace)
	[sssp] = false;       (assume no suspended symbols remaining)
	=> parse;
      ? failed -> allstop;	  (parse error)
      ? [errs] > zero -> allstop; (error in source code)

    (adaptive number of passes resolving infinite forward references)

      ? [sssp] = false -> all symbols resolved;

      "reparse"
	[pass] +;	      (doing a new pass)
	[dpos] = [base dpos]; (reset top of workspace)
	[wpos] = [base wpos]; (reset top of rest of workspace)
	[sssp] = false;       (assume no suspended symbols remaining)
	=> parse;
      ? failed -> allstop;	  (parse error)
      ? [errs] > zero -> allstop; (error in source code)
      ? [sssp] = true -> reparse; (adaptive number of passes control)

      "all symbols resolved"
	[tpss] = [pass]; (remember how many adaptive passes were needed)

    (workspace areas address adjustment)

      (consider possible misaligned end of static data)
	=> realign tow;
      (preserve final [dpos] as the final top of the initialized workspace,
       which is also the pointer to the rest of the workspace, ie. "prws":
       the <last pass> will take care of updating all workspace area labels
       found in the source code, but still...)
	[prws] = [dpos];
	[prws] > 5;
      (...you have to update predefined workspace addresses, which were not
       declared in the source code of course, and were globally declared.)
	[shlo] = null;
	[shhi] = null;
	a = pr wksp;
	b = 180;
      "pr wksp update loop"
      (get existing symbol record for predefined workspace label)
	[symbol name] = a; => get symbol; c = [gs symbol record];
      (advance A to point at the null terminator ending the label's string)
	[source string] = a;
	=> strlen;
	a + [string length];
      (update workspace label address in symbols map)
	[c plus value] + [prws];
      (skip null terminator at end of label's string)
	a +;
      (loop for the 180 records forming "pr wksp")
	b ^ pr wksp update loop;

    (continue compiling)

      (last pass: map symbols, select RTM variant, create application file)
	[tpss] +;	      (count extra pass)
	[dpos] = [base dpos]; (reset top of workspace)
	[wpos] = [base wpos]; (reset top of rest of workspace)
	[pass] = last pass;   (signal last pass)
	=> parse;
      ? failed -> allstop;	  (parse error)
      ? [errs] > zero -> allstop; (error in source code)

    (interpass code concerning last pass)

      (check unit specification presence)
      ? [unit] = yes -> last pass j1;
	[err string] = msg unit director must be specified;
	[cls string] = decl string;
	=> log error;
	-> allstop;
      "last pass j1"
      (read sys pack header)
	[file command] = read;
	[file name] = basesys;
	[file position] = zero;
	[block pointer] = sys header;
	[block size] = 8 plus 8 plus 1 mtp bytesperunit;
	isocall;
      ? ok -> last pass j2;
	[err string] = msg unable to access sys pack;
	[cls string] = link string;
	=> log error;
	-> allstop;
      "last pass j2"
      (verify sys pack header)
      ? [sys header] = 8 -> last pass j3;
	[err string] = msg wrong number of runtime module variants;
	[cls string] = link string;
	=> log error;
	-> allstop;
      "last pass j3"
      (select RTM variant and copy that to application file)
	[ipof] = minus 1;
	a = [rtmv]; (preload)
	[source file] = basesys; (copy from here)
	[source fpos] = [a plus 1 relating sys header]; (variant offset)
	[source fpos] + 8 plus 8 plus 1 mtp bytesperunit; (to skip the header)
	[target file] = applic name; (copy here)
	[target fpos] = zero; (offset zero in target: beginning of executable)
	[transf size] = [a plus 8 plus 1 relating sys header]; (variant size)
	[fcpy callback] = pragma last pass j3a;
	=> fcpy;
      ? ok -> last pass j4;
	[err string] = msg unable to access sys pack;
	[cls string] = link string;
	=> log error;
	-> allstop;
      "last pass j3a"
      (this is a callback function parsing the data blocks read by "fcpy",
       which is used here to scan for the L.in.oleum Initialization Paragraph
       signature within the RTM variant - the signature is "LNLMInit", which
       preceeds the initialization paragraph: it's an ASCII signature, where
       each character is 1 byte, not 1 unit... so to make it simple, this is
       not checking for the exact signature of 8 bytes, but only for its four
       initial bytes, "LNLM", after all I think they're quite sufficient...
       oh, and after the first match the routine "disables" itself by zeroing
       its [fcpy callback] pointer which was for fcpy to call...)
	a = ffun cache;
	b = [block size];
      "lpj3 loop"
	c = [a];
	a +;
      ? c = li sigunit1 case1 -> lpj3 case1;
      ? c = li sigunit1 case2 -> lpj3 case2;
      ? c = li sigunit1 case3 -> lpj3 case3;
      ? c = li sigunit1 case4 -> lpj3 case4;
      "lpj3 cont"
	b - 4;
      ? b > zero -> lpj3 loop;
	leave;
      "lpj3 case1" b = 4;  -> lpj3 getip;
      "lpj3 case2" b = 5;  -> lpj3 getip;
      "lpj3 case3" b = 6;  -> lpj3 getip;
      "lpj3 case4" b = 7; (-> lpj3 getip;)
      "lpj3 getip"
	[ipof] = a;
	[ipof] - ffun cache;
	[ipof] < 2;
	[ipof] + [target fpos];
	[ipof] + b;
	[fcpy callback] = null;
	leave;
      "last pass j4"
      ? [ipof] != minus 1 -> last pass j5;
	[err string] = msg no initialization paragraph found in runtimemodule;
	[cls string] = link string;
	=> log error;
	-> allstop;
      "last pass j5"
      (set RTM size in initialization paragraph to last fcpy transfer size)
	[li phys ws entry] = [transf size]; (size of RTM, bytes)
      (calculate initialized workspace size and default ramtop)
	a = [prws];
	[li app ws size] = a; (size of initialized workspace, in units)
	a + [wpos];
	[li default ramtop] = a; (total size of the workspace, in units)
      (stream all predefined variables to application file)
	[make] = 32;	      (making 32-bit units)
	[natu] = false;       (stream aligned to units boundaries)
	[dval] = zero;	      (conventional initial value of [CodeOrigin])
	[cd stack waste] = 0; (we're using "cat data" from the main flow)
	=> cat unit;	      (stream one 32-bit value)

    (continue compiling)

      (data pass: stream all static data to application file)
	[tpss] +;	      (count extra pass)
	[dpos] = [base dpos]; (reset top of workspace)
	[pass] = data pass;   (signal data pass)
	=> parse;
      ? failed -> allstop;	  (parse error)
      ? [errs] > zero -> allstop; (error in source code)

    (interpass code concerning data pass)

      (consider possible misaligned end of static data)
	=> realign tow;
      (save whatever remains to stream from the data cache)
	=> flush data cache;
      ? ok -> data pass j1;
	[err string] = msg could not stream static data to application file;
	[cls string] = fser string;
	=> log error;
	-> allstop;
      "data pass j1"

    (continue compiling)

      (code pass: log all code labels, stream all code to application file)
	[tpss] +;	    (count extra pass)
	[tlns] = 0;	    (reset total lines counter)
	[tins] = 0;	    (reset total instructions counter)
	[bpos] = 0;	    (reset instruction pointer for proper logging)
	[smap] = no;	    (only log labels since where specified)
	[pass] = code pass; (signal code pass)
	=> parse;
      ? failed -> allstop;	  (parse error)
      ? [errs] > zero -> allstop; (error in source code)

    (interpass code concerning code pass)

      (update Reported Total Lines Counter)
	[rtlc] = [tlns];
      (check if the program has been "closed": it isn't really a way to see if
       the program is capable of stopping execution without getting out of its
       effective code, it simply checks if tags like "end", "fail", "leave" or
       "show registers", have been used at least ONCE in the main program, and
       if they haven't been, it forces one "end" tag at the end of the code in
       an attempt to keep a program, written by a complete beginner, to scare
       the said beginner away by locking up due to no proper end of the code.)
      ? [endt] = yes -> pprp just below here;
	[err string] = msg open program;
	=> log warning;
	[inst plus 0] = slash;
	[inst plus 1] = backslash;
	[inst plus 2] = slash;
	[inst plus 3] = null;
	[op1 class] = null;
	[op2 class] = null;
	[pp return point] = pragma pprp just below here;
	-> pp common stack behavior;
      "pprp just below here"
      (align end of code to next unit boundary)
	a = [bpos];
      "code pass j1"
      ? a - 3 -> code pass j2; (if A is divisible by 4, where 4=bytesperunit)
	[byte] = null;
	=> cat byte; (fill with null bytes until next unit)
	a +;
	-> code pass j1;
      "code pass j2"
      (calculate code size)
	a > 2; (/ bytesperunit)
	[li app code size] = a; (size of all code, in units)
      (save whatever remains to stream from the code cache)
	=> flush code cache;
      ? ok -> code pass j3;
	[err string] = msg could not stream code to application file;
	[cls string] = fser string;
	=> log error;
	-> allstop;
      "code pass j3"
      (retrieve effective size of application before adding the stockfile)
	[file command] = test;
	[file name] = applic name;
	isocall;
      ? ok -> code pass j4;
	[err string] = msg could not retrieve final size of application file;
	[cls string] = fser string;
	=> log error;
	-> allstop;
      "code pass j4"
	[li phys app size] = [file size]; (phys. executable file size, bytes)

    (continue compiling)

      (stck pass: stream stockfile contents to application file;
       note: this pass is entirely superseeded if the stockfile,
       as measured in pass 1, results to be void...)
      ? [sfbp] = 0 -> skip stck pass;
	[tpss] +;	    (count extra pass)
	[sfbp] = 0;	    (reset byte position counter to log constants)
	[pass] = stck pass; (signal stck pass)
	=> parse;
      ? failed -> allstop;	  (parse error)
      ? [errs] > zero -> allstop; (error in source code)
      "skip stck pass"

    (write initialization paragraph to application file's runtime module)

      ? [bea] - bea ini -> ip write as is;
	[area to swap] = li;
	[size of area to swap] = li ends minus li;
	=> swap endian;
      "ip write as is"
	[file command] = write;
	[file name] = applic name;
	[file position] = [ipof];
	[block pointer] = li;
	[block size] = li ends minus li mtp bytesperunit;
	isocall;
      ? ok -> ip written successfully;
	[err string] = msg could not write initialization paragraph;
	[cls string] = fser string;
	=> log error;
	-> allstop;
      "ip written successfully"

    (end compiler - write report to symbols map)

      (a blank line so to leave some space)
	[source string] = eol;
	[target string] = log output;
	=> strcpy;
	=> log report;
      (total passes performed)
	[target string] = line number;
	[string binary] = [tpss];
	=> uitoa;
	[source string] = rep passes;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = eol;
	=> strcat;
	=> log compiler report;
      (total compiled lines)
	[target string] = line number;
	[string binary] = [rtlc];
	[string binary] +;
	=> uitoa;
	[source string] = rep lines;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = eol;
	=> strcat;
	=> log compiler report;
      (total code instructions assembled)
	[target string] = line number;
	[string binary] = [tins];
	=> uitoa;
	[source string] = rep instrs;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = eol;
	=> strcat;
	=> log compiler report;
      (total USER symbols defined)
	[target string] = line number;
	[string binary] = [nods];
	[string binary] - [noss];
	[string binary] - pre symbols;
	=> uitoa;
	[source string] = rep symbols;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = eol;
	=> strcat;
	=> log compiler report;
      (stockfile size)
	[target string] = line number;
	[string binary] = [sfbp];
	=> uitoa;
	[source string] = rep stock;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = bytestring;
	=> strcat;
	=> log compiler report;
      (static data size)
	[target string] = line number;
	[string binary] = [li app ws size];
	[string binary] < 2;
	=> uitoa;
	[source string] = rep data;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = bytestring;
	=> strcat;
	=> log compiler report;
      (default ramtop)
	[target string] = line number;
	[string binary] = [li default ramtop];
	[string binary] < 2;
	=> uitoa;
	[source string] = rep ramtop;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = bytestring;
	=> strcat;
	=> log compiler report;
      (code size)
	[target string] = line number;
	[string binary] = [li app code size];
	[string binary] < 2;
	=> uitoa;
	[source string] = rep codesz;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = bytestring;
	=> strcat;
	=> log compiler report;
      (application file size)
	[target string] = line number;
	[string binary] = [li phys app size];
	[string binary] + [sfbp];
	=> uitoa;
	[source string] = rep applsz;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = bytestring;
	=> strcat;
	=> log compiler report;

    (take stop time)

	[timer command] = read time;
	isocall;
	[hour]	 * 3 600 000;
	[minute] *    60 000;
	[second] *     1 000;
	[stop time] = [hour];
	[stop time] + [minute];
	[stop time] + [second];
	[stop time] + [milliseconds];

    (report execution time, unless across midnight - nevermind that)

	[stop time] - [start time];
      ? [stop time] < 0 -> allstop;
	[target string] = line number;
	[string binary] = [stop time];
	=> uitoa;
	[source string] = rep extime;
	[target string] = log output;
	=> strcpy;
	[source string] = line number;
	=> strcat;
	[source string] = msec string;
	=> strcat;
	=> log compiler report;

    (stop compiler, end of main program)

	[success] = true;

      "allstop"
      ? [errs] = zero -> not stopped for source errors;
	[filecommand] = destroy;
	[filename] = symaps name;
	isocall;
	[filecommand] = destroy;
	[filename] = applic name;
	isocall;
      "not stopped for source errors"
      ? [stacked regs] = false -> no library call;
      (return path and name of error log file)
	[source string] = path;
	[target string] = errorlog name;
	=> strcpy;
	[source string] = path junction;
	=> strcat;
	[source string] = errlog name;
	=> strcat;
      (return path and name of symbols map file)
	[source string] = path;
	[target string] = smblsmap name;
	=> strcpy;
	[source string] = path junction;
	=> strcat;
	[source string] = symaps name;
	=> strcat;
      (return path and name of executable file)
	[source string] = applic name;
	[target string] = executable name;
	=> strcpy;
      (restore entry path)
	[file command] = set dir;
	[file name] = path save;
	isocall;
      (restore all registers, report state)
	<-- e;
	<-- d;
	<-- c;
	<-- b;
	<-- a;
      ? [success] = true -> no library call;
	fail;
      "no library call"
	end;

    (end main flow)

    "parse"
    (source code parser: recursive, fails on fatal/parse errors)
	[flns] = 0;    (reset current file's lines counter)
	[fins] = 0;    (reset current file's instructions counter)
	[prid] = unkn; (assume unknown period until a period is declared)
	[tpos] = 0;    (restart from beginning of file)
	[pnow] = 0;    (assume first piece)
	[cnow] = 0;    (assume first character in piece)
	[inow] = 0;    (assume first character of instruction string)
	[lkea] = minus 1; (set LKEA to minus 1: means no data labels declared)
	[shlo] = null; (assume global symbol hash until proper director found)
	[shhi] = null; (assume global symbol hash until proper director found)
	b      = 0;    (assume we're not parsing a string or label: clr. mask)
	d      = 0;    (assume we're not in any comment: d = comm. nid. level)
	e      = 0;    (empty source file cache, because e = bytes before end)
      "parse reset"
	[first	operand relating pces] = null;
	[second operand relating pces] = null;
	[third	operand relating pces] = null;
      "parse loop"
      (read 1 character, fail if you can't, return if there's nothing to read)
	=> read char;
      ? failed -> err read error;	(fatal, couldn't read from source)
      ? c = null -> parse stop; 	(got to the end of source file)
      (check for newline codes to increment source lines counter:
	1. if it's a newline [10], increment and skip it
	2. if it's a carriage return [13], read another character
	3. later, if the character read at point 2 is a newline, skip it
       this code is compatible with DOS, Windows, Unix and Macintosh, because:
	DOS/Win = CR+LF
	Unix = LF only
	Mac = CR only
       and now let's wait for the first one genius who will pour out LF+CR...
       may God bless ASCII, or at least its 32 to 126 part, save our souls...)
      ? c != 10 -> p nolfline;
	[flns] +;
	-> parse loop;
      "p nolfline"
      ? c != 13 -> p nocrline;
	[flns] +;
	=> read char;
      ? failed -> err read error;
      ? c = null -> parse stop;
      ? c = 10 -> parse loop;
      "p nocrline"
      (check if it's all in a comment)
      ? d > zero -> parse comment;
      (ignore any ASCII codes below 033)
      ? c < 033 -> parse loop;
      (ignore any ASCII codes above 126)
      ? c > 126 -> parse loop;
      (check if it's already parsing a string)
      ? b + regb string signal -> continue string;
      (check if it did parse a string, and complain if there's something more)
      ? b - regb closed string -> p not after string;
      ? c = open parenthesis -> nidify comment; (ok: comment after string)
      ? c = semicolon -> parse instruction;	(ok: semicolon after string)
	-> err extra input after string;	(otherwise complain)
      "p not after string"
      (finding a brace here opens a string)
      ? c = open brace -> open string;
      (opening a parenthesis here opens a level-1 comment block)
      ? c = open parenthesis -> nidify comment;
      (since we're not in a string, begin forcing lower case on everything)
      ? c > 90 -> p not uppercase; (most frequent, checked first)
      ? c < 65 -> p not uppercase; (less frequent, checked later)
	c + 32;
      "p not uppercase"
      (check if it's already parsing a label)
      ? b + regb label signal -> continue label;
      (finding quotes here marks the beginning of a label)
      ? c = quotes -> open label;
      (see if we didn't find any periods declarations so far)
      ? [prid] = unkn -> err emission to unknown period; (fatal)
      (ok, begin looking for common modular syntax)
      ? c > 122 -> p is sign; (beyond lowercase letters)
      ? c > 096 -> p no sign; (within lowercase letters)
      ? c < 048 -> p is sign; (before all digits 0 to 9)
      ? c < 058 -> p no sign; (within all digits 0 to 9)
      "p is sign"
      ? [prid] > stck -> p common; (use plain common syntax after "stockfile")
      ? c = slash -> p no sign; (slash, in libs and stck, is paths' delimiter)
      ? c = semicolon -> parse instruction; (it terminates compound name here)
	-> err invalid compound specification; (any other sign's invalid here)
      "p common"
      ? c = open bracket  -> p no sign; (may be part of symbol, indirection)
      ? c = close bracket -> p no sign; (may be part of symbol, indirection)
      ? c = dot -> p no sign; (may be part of symbol specification, FP values)
      (it's a key sign: will divide operands)
      ? c = semicolon -> parse instruction;
      (unless it was a semicolon, add the sign to the instruction string)
	a = [inow];
      ? a = 6 -> err too many signs; (fatal)
	[a relating inst] = c;
	[inow] +;
      (now, if there were one or more non-signs before this sign...)
      ? [cnow] = 0 -> parse loop;
      (...terminate the piece that contains them...)
	a = [cnow];
	a + [pnow];
	[a relating pces] = null;
      (...and begin with the next piece - unless it's the 4th piece, = error)
	[pnow] + 2048;
      ? [pnow] = 3 mtp 2048 -> err too many operands; (fatal)
	[cnow] = 0;
	-> parse loop;
      "p no sign"
      (it's no key sign: will be concatenated to current piece/operand)
	a = [cnow];
      ? a = 2047 -> err operand too long; (fatal)
	a + [pnow];
	[a relating pces] = c;
	[cnow] +;
	-> parse loop;
      "parse stop"
      (return to main program flow)
	[tlns] + [flns];
	[tins] + [fins];
	end;

    "parse instruction"
      (remember and remove, if present, string close flag)
	[strd] = b;
	[strd] & regb closed string;
	b & FFFFFFFFh minus regb closed string;
      (terminate instruction string, and prepare to re-fill that buffer later)
	a = [inow];
	[a relating inst] = null;
	[inow] = 0;
      (terminate current piece, and prepare to restart from piece #1 later)
	a = [cnow];
	a + [pnow];
	[a relating pces] = null;
	[cnow] = 0;
	[pnow] = 0;
      (route to period-specific parser)
	-> [perp];

    "parse comment"
      ? c = open parenthesis  -> nidify comment;
      ? c = close parenthesis -> exit comment;
	-> parse loop;

    "nidify comment"
	d +;
	-> parse loop;

    "exit comment"
	d -;
	-> parse loop;

    "open string"
      (no text or machine language strings can be declared:
       - misplaced: outside "directors", "variables" and "programme";
       - emitted to uhknown period: before having declared any periods.)
	a  = [prid];
      ? a  = unkn -> err emission to unknown period; (fatal)
      ? a  = dirs -> may open string;
      ? a  = vars -> may open string;
      ? a != prog -> err misplaced string declaration; (fatal)
      "may open string"
      (set parser flag indicating that it's within a string)
	b # regb string signal;
      (calculate current character position to mark the string's beginning, as
       [stst] = [tpos] - e, that is: string_start = cache_end - cache_to_read)
	[stst] = [tpos];
	[stst] - e;
	-> parse loop;

    "continue string"
      (see if the string closes here, else totally ignore the character...)
      ? c = close brace -> exit string;
      (...unless it's in the programme period, where code strings go:
       note programme periods are parsed only in pass 1 and in code pass)
      ? [prid] != prog -> parse loop;
      ? c = open parenthesis -> nidify comment;
      ? c = less than -> ccs open symbol;
      ? c > 090 -> ccs uppercase;
      ? c < 064 -> ccs uppercase;
	c + 32;
      "ccs uppercase"
      ? b - regb insymbol -> ccs get nybbles;
      ? c > 122 -> ccs is sign; (beyond lowercase letters)
      ? c > 096 -> ccs no sign; (within lowercase letters)
      ? c < 048 -> ccs is sign; (before all digits 0 to 9)
      ? c < 058 -> ccs no sign; (within all digits 0 to 9)
      "ccs is sign"
      ? c = greater than -> ccs exit symbol;
      ? c = hyphen -> ccs no sign;
      ? c != cross -> err syntax error in code string;
      "ccs no sign"
	a = [snow];
	[snow] +;
      ? a >= 2047 -> err operand too long;
	[a relating pces] = c;
	-> parse loop;
      "ccs get nybbles"
	c - 48; ("0" -> 0h)
      ? c < 0h -> err syntax error in code string;
      ? c < Ah -> ccs new nybble;
	c - 87 minus 48; ("a" -> Ah)
      ? c > Fh -> err syntax error in code string;
      "ccs new nybble"
	b # regb innybble;
      ? b - regb innybble -> ccs low nybble;
	c < 4;
	[nybb] = c;
	-> parse loop;
      "ccs low nybble"
	[bpos] +;
      ? [pass] != code pass -> parse loop;
	[nybb] + c;
	[byte] = [nybb];
	=> cat byte;
	-> parse loop;

      "ccs open symbol"
      (found a less than in a code string)
      ? b + regb insymbol plus regb innybble
	  -> err syntax error in code string;
	b + regb insymbol;
	[snow] = zero;
	-> parse loop;

      "ccs exit symbol"
      (found a greater than in a code string: parse and stream the expression
       enclosed within <...> specification; it will be treaten as an immediate
       value if the first character of the specification is neither + nor -,
       otherwise it will be streamed as a relative label address, typically
       for a relocable jump instruction: beware that absolute jumps need the
       code origin pointer from [CodeOrigin] to work properly, although you
       may stream a label's address as absolute by omitting the +/- signs...)
      ? b - regb insymbol -> err syntax error in code string;
	b - regb insymbol;
	a = [snow];
      ? a < 2 -> err syntax error in code string;
	[a relating pces] = null;
      ? [pces] = hyphen -> ccs check relative drift;
      ? [pces] != cross -> ccs no relative drift indication;
      "ccs check relative drift"
      ? a < 4 -> err syntax error in code string;
	a = pces plus 3;
	-> ccs stream symbol;
      "ccs no relative drift indication"
	a = pces plus 1;
      "ccs stream symbol"
	=> parse operand;
      ? [po class] != immediate -> err syntax error in code string;
	b & FFFFFFFFh minus regb make relative;
      ? [pces] = hyphen -> ccs make relative;
      ? [pces] != cross -> ccs assume scalar;
      "ccs make relative"
	b | regb make relative;
      ? [pass] = 1 -> ccs pragmize warning;
      ? [po flags] + codelabel -> ccs pragmize warning;
      ? [po pragm] = yes -> ccs pragmize warning;
	[err string] = msg need code label for relative address streaming;
	=> log warning;
      "ccs pragmize warning"
	c = [pces plus 1];
	[po value] - [bpos];
	c - 48; ("0" -> 0)
      ? c < zero -> err syntax error in code string;
      ? c < 10 -> ccs accept drift;
	c - 87 minus 48; ("a" -> 10, "z" -> 35)
      ? c > 35 -> err syntax error in code string;
      "ccs accept drift"
	[po value] - c;
      "ccs assume scalar"
	c = [a minus 1];
	a = bea imm;
      ? b - regb make relative -> ccs is scalar;
	a = bea rel;
      "ccs is scalar"
      ? c =  98 -> ccs stream byte;
      ? c = 119 -> ccs stream word;
      ? c = 100 -> ccs stream doubleword;
      ? c = 113 -> ccs stream quadword;
	-> err syntax error in code string;
      "ccs stream byte"
	[bpos] +;
      ? [pass] = 1 -> parse loop;
	c = [po value];
       |c|;
      ? c '<= FFh -> ccs sb skip warning;
	[err string] = msg value out of specified operand size range;
	=> log warning;
      "ccs sb skip warning"
	[byte] = [po value];
	=> cat byte;
	-> parse loop;
      "ccs stream word"
	[bpos] + 2;
      ? [pass] = 1 -> parse loop;
	c = [po value];
       |c|;
      ? c '<= FFFFh -> ccs sw skip warning;
	[err string] = msg value out of specified operand size range;
	=> log warning;
      "ccs sw skip warning"
      ? [bea] + a -> ccs sw big endian;
	c = [po value];
	[byte] = c; => cat byte;
	c > 8;
	[byte] = c; => cat byte;
	-> parse loop;
      "ccs sw big endian"
	c = [po value];
	c <@ 24;
	[byte] = c; => cat byte;
	c <@ 8;
	[byte] = c; => cat byte;
	-> parse loop;
      "ccs stream quadword"
	[bpos] + 8;
      ? [pass] = 1 -> parse loop;
      ? [bea] + a -> ccs sq big endian;
	c = [po value];
	[byte] = c; => cat byte;
	c > 8;
	[byte] = c; => cat byte;
	c > 8;
	[byte] = c; => cat byte;
	c > 8;
	[byte] = c; => cat byte;
	[byte] = zero;
	=> cat byte;
	=> cat byte;
	=> cat byte;
	=> cat byte;
	-> parse loop;
      "ccs sq big endian"
	[byte] = zero;
	=> cat byte;
	=> cat byte;
	=> cat byte;
	=> cat byte;
	-> ccs sd sq be reentry;
      "ccs stream doubleword"
	[bpos] + 4;
      ? [pass] = 1 -> parse loop;
      "ccs sd sq be reentry"
      ? [bea] + a -> ccs sd big endian;
	c = [po value];
	[byte] = c; => cat byte;
	c > 8;
	[byte] = c; => cat byte;
	c > 8;
	[byte] = c; => cat byte;
	c > 8;
	[byte] = c; => cat byte;
	-> parse loop;
      "ccs sd big endian"
	c = [po value];
	c <@ 8;
	[byte] = c; => cat byte;
	c <@ 8;
	[byte] = c; => cat byte;
	c <@ 8;
	[byte] = c; => cat byte;
	c <@ 8;
	[byte] = c; => cat byte;
	-> parse loop;

    "exit string"
      ? b + regb insymbol plus regb innybble
	  -> err syntax error in code string;
      (remove parser flag indicating that it's within a string)
	b # regb string signal;
      (the flag mentioned below won't be asserted for code strings)
      ? [prid] = prog -> parse loop;
      (the following is a special flag to remind the parser that it's just
       coming out of a string declaration: because there are no constructs
       considering a text string as something to be placed before the last
       operand, this will cause the parser to output a parse error in case
       anything that's not a semicolon is found after closing the string,
       well, anything apart from comments of course...)
	b | regb closed string;
	-> parse loop;

    "open label"
      (nothing should remain unparsed before opening a label)
      ? [cnow] > 0 -> err extra input before label; (fatal)
      ? [pnow] > 0 -> err extra input before label; (fatal)
      ? [inow] > 0 -> err extra input before label; (fatal)
      (set parser flag indicating that it's within a label)
	b # regb label signal;
      (void label buffer, set offset to zero)
	[lnow] = 0;
	-> parse loop;

    "continue label"
      (see if the label closes here)
      ? c = quotes -> exit label;
      (else concatenate this character to the label)
	a = [lnow];
      ? a = 2047 -> err label too long; (fatal)
	[a relating pces] = c;
	[lnow] +;
	-> parse loop;

    "exit label"
      (remove parser flag indicating that it's within a label)
	b # regb label signal;
      (terminate the first piece, which is used as the label buffer)
	a = [lnow];
	[a relating pces] = null;
      (when in prog period, don't mind periods' names, only get code labels)
      ? [prid] < prog -> period identification;
      (the above condition is false and lets the flow get here only in pass 1
       and in code pass: in pass 1, the label is registered as a symbol and
       associated to the physical instruction pointer address, which will in
       effects never change for the code doesn't vary its size between passes;
       in code pass, the label is logged to the symbols map)
      ? [pass] = code pass -> log label;
	a = pces;
	=> put symbol;
	a = [ps symbol record];
	[a plus value] = [bpos];
	[a plus flags] = codelabel;
	[source string] = pces;
	[target string] = pfx shared;
	=> strpcmp;
      ? failed -> examine secondary prefix;
	[source string] + 6;
      "examine secondary prefix"
	[target string] = pfx service;
	=> strpcmp;
      ? failed -> parse reset; (user code label declared)
	[a plus flags] | address;
	-> parse reset; (pointable user code label declared)
      "log label"
      (log full name, include all prefixes for best clearance)
	[sym string] = pces;
	[cls string] = cls usrlabel;
	[sym value]  = [bpos];
	=> log symbol;
	-> parse reset; (user code label logged)
      "period identification"
      (preload first character of first piece, for quick comparisons)
	a = [pces];
      (check if this period reads "libraries", and react)
      ? a != 108 -> not libs; (lowercase L must be first letter)
	[source string] = pces plus 1;
	[target string] = libs string;
	=> strcmp;
      ? failed -> not libs;
      ? [prid] > unkn -> err misplaced period;
	[prid] = libs;
      ("libraries" is always parsed, in all passes)
	[perp] = service libs parser;
	-> parse reset;
      "not libs"
      (check if this period reads "stockfile", and react)
      ? a != 115 -> not stck; (lowercase S must be first letter)
	[source string] = pces plus 1;
	[target string] = stck string;
	=> strcmp;
      ? failed -> not stck;
      ? [prid] > libs -> err misplaced period;
	[prid] = stck;
      ("stockfile" is parsed only in pass 1 and in stck pass)
      ? [pass] = 1 -> parse stck;
      ? [pass] != stck pass -> ignore this period;
      "parse stck"
	[perp] = service stck parser;
	-> parse reset;
      "not stck"
      (check if this period reads "directors", and react)
      ? a != 100 -> not dirs; (lowercase D must be first letter)
	[source string] = pces plus 1;
	[target string] = dirs string;
	=> strcmp;
      ? failed -> not dirs;
      ? [prid] > stck -> err misplaced period;
	[prid] = dirs;
      ("directors" is parsed in all passes for symbol hashing, but mostly:
       - in last pass, to resolve all the other directors' values;
       - in code pass, because the "symbols map" director determines
	 since which file code labels might be logged...)
	[perp] = service dirs parser;
	-> parse reset;
      "not dirs"
      (check if this period reads "constants", and react)
      ? a != 099 -> not cons; (lowercase C must be first letter)
	[source string] = pces plus 1;
	[target string] = cons string;
	=> strcmp;
      ? failed -> not cons;
      ? [prid] > dirs -> err misplaced period;
	[prid] = cons;
      ("constants" is parsed only in adaptive passes and in last pass)
      ? [pass] > last pass -> ignore this period;
	[perp] = service cons parser;
	-> parse reset;
      "not cons"
      (check if this period reads "variables", and react)
      ? a != 118 -> not vars; (lowercase V must be first letter)
	[source string] = pces plus 1;
	[target string] = vars string;
	=> strcmp;
      ? failed -> not vars;
      ? [prid] > cons -> err misplaced period;
	[prid] = vars;
      ("variables" is parsed before data pass - and in data pass)
      ? [pass] > data pass -> ignore this period;
	=> realign tow;
	[make] = 32;
	[natu] = false;
	[perp] = service vars parser;
	-> parse reset;
      "not vars"
      (check if this period reads "workspace", and react)
      ? a != 119 -> not wksp; (lowercase W must be first letter)
	[source string] = pces plus 1;
	[target string] = wksp string;
	=> strcmp;
      ? failed -> not wksp;
      ? [prid] > vars -> err misplaced period;
	[prid] = wksp;
      ("workspace" is parsed only in adaptive passes and in last pass)
      ? [pass] > last pass -> ignore this period;
	[perp] = service wksp parser;
	-> parse reset;
      "not wksp"
      (check if this period reads "programme", and react)
      (lowercase P must be first letter)
      ? a != 112 -> err unknown period or misplaced user code label;
	[source string] = pces plus 1;
	[target string] = prog string;
	=> strcmp;
      ? failed -> err unknown period or misplaced user code label;
	[prid] = prog;
      ("programme" is parsed only in pass 1 and in code pass: furthermore,
       "programme" is followed by no other periods, so when we're to ignore
       this period, we quit the parser at all to not waste time processing
       all the instructions that a typical "programme" period may host...)
      ? [pass] = 1 -> parse prog;
      ? [pass] = code pass -> parse prog;
      (quit the whole parser for this file: yeah this way [tlns], the total
       number of lines counter, isn't updated as if we jumped to "parse stop",
       but there's no need to, because the compiler's main program is aware of
       this "break", and [tlns] is no longer considered for the final report
       after the code pass... well, in effects there's only one pass after the
       code pass, the stck pass, but the code pass is obligatory so you can be
       sure that the total lines' counter will be correct.)
	end;
      "parse prog"
      (when you find "programme" at library nidification level zero, which is
       the level of the main source code, fix the program's code entry point,
       where execution will being; the RTM requires this to be given in units
       and measured from the beginning of the code area, so use current [bpos]
       instruction pointer, after aligning [bpos] to the next unit... oh, and
       all this can only happen when actually streaming the code, so don't do
       this if you're not doing code pass...)
      ? [levl] > zero -> parsing library code;
	a = [bpos];
      "align code"
      ? a - 3 -> code aligned; (if A is divisible by 4, where 4=bytesperunit)
      ? [pass] != code pass -> align ip only;
	[byte] = null;
	=> cat byte; (fill with null bytes until next unit)
      "align ip only"
	a +;
	-> align code;
      "code aligned"
	[bpos] = a;
	a > 2; (/ bytesperunit)
	[li app code entry] = a; (position of main "programme" period, units)
      "parsing library code"
	[perp] = service prog parser;
	[pp return point] = pragma parse reset;
	-> parse reset;
      "ignore this period"
      (this is used to skip a period's instructions when not needed for pass)
	[perp] = pragma parse loop;
	-> parse loop;

    "read char"
    (reads a single ASCII character from the actual source code file,
     assuming the file name is 1024-byte entry #levl from vector "main":
     returns the resulting ASCII code within register c,
     returns c=null when the end of the source file has been reached,
     fails if there's a file read error - on failures, disregard c)
      ? e > zero -> rc return;
	[filecommand] = read;
	[filename] = [levl];
	[filename] < 10;
	[filename] + main;
	[fileposition] = [tpos];
	[blockpointer] = text;
	[blocksize] = scache size;
	isocall;
      ? failed -> rc error;
	[sccs] = [blocksize];
	[tpos] + [blocksize];
	e = [blocksize];
      ? e > zero -> rc return;
	c = null;
	end;
      "rc return"
	[pb stream] = text;
	[pb offset] = [sccs];
	[pb offset] - e;
	=> get progressive byte;
	c = [pb bvalue];
	e -;
	end;
      "rc error"
	fail;

    (common points loading error message parameters - code size optimization)

    "log warning"
	[cls string] = warn string;
	-> log error;

    "log parse error" (and fail parser, not to be used otherwise)
	[cls string] = perr string;
	=> log error;
	fail;

    "log syntax error" (and fail parser, not to be used otherwise)
	[cls string] = synt string;
	=> log error;
	fail;

    "log declaration error" (and fail parser, not to be used otherwise)
	[cls string] = decl string;
	=> log error;
	fail;

    (fatal parser error messages: the following routines must all directly
     fail after having streamed their due message to the errors' log file)
    "err read error"
	[err string] = msg read error;
	-> log parse error;
    "err emission to unknown period"
	[err string] = msg emission to unknown period;
	-> log parse error;
    "err misplaced string declaration"
	[err string] = msg misplaced string declaration;
	-> log parse error;
    "err syntax error in code string"
	[err string] = msg syntax error in code string;
	-> log syntax error;
    "err label too long"
	[err string] = msg label too long;
	-> log parse error;
    "err extra input before label"
	[err string] = msg extra input before label;
	-> log parse error;
    "err invalid compound specification"
	[err string] = msg invalid compound specification;
	-> log parse error;
    "err too many signs"
	[err string] = msg too many signs;
	-> log parse error;
    "err operand too long"
	[err string] = msg operand too long;
	-> log parse error;
    "err too many operands"
	[err string] = msg too many operands;
	-> log parse error;
    "err misplaced period"
	[err string] = msg misplaced period;
	-> log parse error;
    "err unknown period or misplaced user code label"
	[err string] = msg unknown period or misplaced user code label;
	-> log declaration error;
    "err extra input after string"
	[err string] = msg extra input after string;
	-> log parse error;

    ("libraries" - specific period parser)
    "service libs parser"
      (see if there's room for a further nidification level, fail if not)
      ? [levl] = levels -> err too much nidification; (fatal)
	[levl] +;
      (pces's first part, of upto 2048 bytes, holds the string found in the
       "libraries" period, which is supposed to be a library's name, here:
       a first check, to see if the name begins with a forward slash: if it
       does, the RCFP for this level will be emptied, to mean absolute path,
       and the searched file will be based at pces[1] to skip that slash)
	a = pces;
      ? [a] != slash -> lp relative;
	a +;
	b = [levl];
	b < 10;
	[b relating rcfp] = null;
	-> lp absolute;
      "lp relative"
      (if the path is relative, with no forward slash prepended to it, then
       copy the previous level's rcfp onto this level's rcfp, because the
       path is in fact meant to be appended to the current path)
	[source string] = [levl];
	[source string] -;
	[source string] < 10;
	[source string] + rcfp;
	[target string] = [source string];
	[target string] + 1024;
	=> strcpy;
      "lp absolute"
      (at this point reg. A points to the path to the file to include, but
       it still has to be separated from the file's name, so scan the string
       pointed by A backwards, stopping as soon as you meet a forward slash
       or of course the beginning of the string, which would mean there's
       no path indication and the file is supposed to be found in the current
       directory; b will hold the pointer to the first character of the name
       and after the last slash of the path, but it needs to distinguish the
       case where the path is void because there'd be no such slashes to skip;
       in the end, the following piece also places a null unit at the end of
       the path part, if the path is not void, to later cat the string to the
       actual level's rcfp)
	[source string] = a;
	=> strlen;
	b = a;
	b + [string length];
      "lp scan for path"
      ? b = a -> lp voidpath;
	b -;
      ? [b] != slash -> lp scan for path;
      (terminate path pointed by A)
	[b] = null;
      (append path to current rcfp)
	[source string] = a;
	[target string] = [levl];
	[target string] < 10;
	[target string] + rcfp;
	=> strcat;
      (skip slash to point B at the file name)
	b +;
      "lp voidpath"
      (ok, ready to mount the absolute path+name of the .txt file to look for:
       absolute here means in the point of view of the whole file system... as
       a first attempt, look for a file starting from the main source code's
       path, so...)
	[atbp] = no; (clear [atbp] flag - first attempt)
	[source string] = path; (the path to main source)
      "lp reopen" (reentry point, assumes [source string] already loaded)
	[target string] = [levl];
	[target string] < 10;
	[target string] + main; (the actual filename slot in recursion stack)
	=> strcpy; (copy the main source's path)
      ? [path] = null -> lp null path;
	[source string] = path junction;
	=> strcat; (cat a junction, if path is not void)
      "lp null path"
	[source string] = [levl];
	[source string] < 10;
	[source string] + rcfp;
	=> strcat; (cat the rcfp of current level)
	a = [source string];
      ? [a] = null -> lp null rcfp;
	[source string] = path junction;
	=> strcat; (cat a junction, if rcfp is not void)
      "lp null rcfp"
	[source string] = b;
	=> strcat; (cat the file name)
	[source string] = txt extension;
	=> strcat; (cat the extension for a L.in.oleum source file)
      (test if the file is present and readable)
	[filecommand] = test;
	[filename] = [target string];
	isocall;
      ? [filestatus] - error -> lp found;
      (not here? well, maybe it's in the default libraries' folder...)
      ? [atbp] = yes -> err library not found; (fatal)
	[atbp] = yes; (set this flag for you to fail, next time you get here)
	[source string] = baselib; (the path to the default libraries' folder)
	-> lp reopen; (jump above, to rebuild the <path+filename> and re-test)
      (file was found: not readable = not acceptable, else proceed)
      "lp found"
      ? [filestatus] - permit to read -> err cannot read from library; (fatal)
      (see if this library was already parsed in this pass: the check is made
       on the whole file name, complete with its absolute path, because there
       may be libraries having the same name but placed in different folders,
       and they might be assumed not to be the same library...)
	[symbol name] = [levl];
	[symbol name] < 10;
	[symbol name] + main;
	=> get symbol;
      ? failed -> lp not yet parsed; (never, not even in pass 1)
	a = [gs symbol record];
      ? [a plus value] = [pass] -> lp already parsed; (in this pass)
	[a plus value] = [pass]; (update pass number of library name-symbol)
	-> lp go reparse;
      "lp not yet parsed"
	a = [symbol name];	 (required as A by "put symbol")
	[isfilename] = true;	 (wrapping this flag...)
	=> putsymbol;		 (...around the call to "put symbol"...)
	[isfilename] = false;	 (...to make it accept any names)
	a = [ps symbol record];  (setting pass number...)
	[a plus value] = [pass]; (...as the value of the library name-symbol)
	[noss] +;		 (update number of support symbols)
      "lp go reparse"
      (we're ready to parse this library: stack all the relevant data, and
       call the parser: it will now read from the name at: main + levl * 1024)
	[flns] -->; (current file's lines counter)
	[tpos] -->; (current position to read from once the cache is over)
	e      -->; (bytes to read before end of cache)
	=> parse;
      (parser failed with the library? ok, go fail THIS instance too)
      ? failed -> lp parse failed;
      (no parse errors with the library? ok, continue with this instance)
	<--	 e; (recover stacked data)
	<-- [tpos];
	<-- [flns];
      (but the cache contents would take too much stack to be saved, so you
       have to prepare to read from the file again, and not rely on cache...)
	[tpos] - e; (this sets "tpos" to point at next unread character)
	e = zero;   (now empty the cache, for "read char" to re-fill it up)
      (ah, and we don't care which period the parsed file left the parser to,
       when it ended: but of course it's unlikely that it was a library only
       to include other libraries, so we reset the period ID and parser to
       reflect the fact that we didn't yet exit from the "libraries" period
       of the former level...)
	[prid] = libs;
	[perp] = service libs parser;
      "lp already parsed"
      (finally return to previous nidification level)
	[levl] -;
      (zeroing reg B before returning to parser:
       it's not needed to save register B on entry to this period parser, for
       restoring it now, because on entry, here, register B is obviously not
       holding those flags for the parser signalling an open string, an open
       label, or the fact that a string has just been closed: there's no such
       entities in the middle of the "libraries" period)
	b = zero;
	-> parse reset;
      "lp parse failed"
      (note it doesn't jump - it returns: therefore closing this call;
       the fact that it fails will signal former calls to -also- fail,
       going straight to fail the main code's "parse" call, therefore
       you can imagine the following "fail" to proceed to quit the whole
       compiler's process; not even further passes will be performed; it
       can also nevermind decreasing [levl], it's no longer important)
	$ + 3; (discard stacked units, they're no longer needed)
	fail;

    (libraries parser error messages)
    "err too much nidification"
	[err string] = msg too much nidification;
	-> log parse error;
    "err cannot read from library"
	[levl] -; (just for proper error message visualization)
	[err string] = msg cannot read from library;
	-> log parse error;
    "err library not found"
	[levl] -; (just for proper error message visualization)
	[err string] = msg library not found;
	-> log parse error;

    ("stockfile" - specific period parser)
    "service stck parser"
      (pces's first part, of upto 2048 bytes, holds the string found in the
       "stockfile" period, which is supposed to be a compound's name, here:
       a first check, to see if the name begins with a forward slash: if it
       does, the RCFP, called TCFP for a Temporary path her, will be emptied,
       to mean absolute path, and the searched file will be based at pces[1]
       to skip that slash)
	a = pces;
      ? [a] != slash -> sp relative;
	a +;
	[tcfp] = null;
	-> sp absolute;
      "sp relative"
      (if the path is relative, with no forward slash prepended to it, then
       copy the actual level's rcfp onto this level's rcfp, because the
       path is in fact meant to be appended to the current path)
	[source string] = [levl];
	[source string] < 10;
	[source string] + rcfp;
	[target string] = tcfp;
	=> strcpy;
      "sp absolute"
      (at this point reg. A points to the path to the file to include, but
       it still has to be separated from the file's name, so scan the string
       pointed by A backwards, stopping as soon as you meet a forward slash
       or of course the beginning of the string, which would mean there's
       no path indication and the file is supposed to be found in the current
       directory; b will hold the pointer to the first character of the name
       and after the last slash of the path, but it needs to distinguish the
       case where the path is void because there'd be no such slashes to skip;
       in the end, the following piece also places a null unit at the end of
       the path part, if the path is not void, to later append the string to
       the temporary compound file path buffer, tcfp)
	[source string] = a;
	=> strlen;
	b = a;
	b + [string length];
      "sp scan for path"
      ? b = a -> sp voidpath;
	b -;
      ? [b] != slash -> sp scan for path;
      (terminate path pointed by A)
	[b] = null;
      (append path to current rcfp)
	[source string] = a;
	[target string] = tcfp;
	=> strcat;
      (skip slash to point B at the file name)
	b +;
      "sp voidpath"
      (find length of compound name, keep it in [string length] for later use)
	[source string] = b;
	=> strlen;
      (ok, ready to mount the absolute path+name of the .* file to look for:
       absolute here means in the point of view of the whole file system; as
       a first attempt, look for a file starting from the main source code's
       path, so...)
	[atbp] = no; (clear [atbp] flag, begin searching)
	[source string] = path; (the path to main source)
      "sp restart search" (reentry point, assumes [source string] loaded)
	[target string] = comp; (the future name of the compound file)
	=> strcpy; (copy the main source's path)
      ? [comp] = null -> sp null path;
	[source string] = path junction;
	=> strcat; (cat a junction, if path is not void)
      "sp null path"
	[source string] = tcfp;
	=> strcat; (cat the tcfp)
	[file command] = set dir;
	[file name] = comp;
	isocall; (set work dir to the resulting path)
      ? failed -> sp try base path; (no such folder, no such search)
      (search a file having the string pointed by reg B as the first part of
       its name, not considering the file's extension, if extension's present)
	[file command] = get first file;
	[file name] = tfsb; (temporary file search buffer)
	isocall;
      ? failed -> sp try base path; (no files in folder, end of search)
      "sp search"
	[target string] = tfsb; (convert file name from OS...)
	=> strlwr;		(...to compiler's all-lowercase convention)
	[source string] = tfsb; (file name from OS, possibly incl. extension)
	[target string] = b;	(file name to find, never incl. extension)
	=> strpcmp; (compare B string against part of "tfsb" upto strlen of B)
      ? failed -> sp search again; (no name correspondence, pass to next file)
	a = tfsb;	     (point reg A to...)
	a + [string length]; (...the character after the file name)
      ? [a] = null -> sp found; (end of name: match found)
      ? [a] = dot -> sp found;	(dot marking extension: match found)
      "sp search again"
	[file command] = get next file;
	[file name] = tfsb;
	isocall;
      ? ok -> sp search; (keep examining files of this folder)
      "sp try base path" (otherwise, end of search)
      ? [atbp] = yes -> err stockfile compound not found; (fatal)
	[atbp] = yes; (set this flag for you to fail, next time you get here)
	[source string] = baselib; (the path to the default libraries' folder)
	-> sp restart search; (reenter above, this time use <baselib> path)
      "sp found" (found a file matching search)
	[source string] = comp;
	[target string] = cpbk;
	=> strcpy; (backup actual path, "comp", to "cpbk": possible later use)
      ? [tcfp] = null -> sp null tcfp;
	[source string] = path junction;
	[target string] = comp;
	=> strcat; (cat a junction, if tcfp is not void)
      "sp null tcfp"
	[source string] = tfsb;
	[target string] = comp;
	=> strcat; (cat the file name, of course complete with extension here)
      (but wait! - IS THIS THE APPLICATION FILE?? - see the following case:
       -----------------------------------------------------------------------
       in my c:\lp\hsdmaker folder there's the following files:
	 hsdmaker.txt	  - the main source file
	 hsdmaker.tga	  - an image to use as the window's background
	 icon.bmp	  - program's icon that I'll save with IconEd later
       my main source file says:
	 "stockfile"
	   hsdmaker;
       to include the background image hsdmaker.tga within the stockfile, but
       what happens when the compiler creates "hsdmaker.exe" and then, in the
       <stck pass>, goes to seek "hsdmaker.tga" to merge it to the stockfile?
       -----------------------------------------------------------------------
       this is a very special case that leads the compiler to loop inifinitely
       concatenating itself to... itself: because extensions are ignored, it
       may happen that, when a stockfile compound name has null relative path
       and the same exact name of the application being compiled, the compiler
       may find ITSELF and try to link that to the stockfile, which ALSO means
       to itself; this loop goes on and on, until hundred megabytes are wasted
       concatenating infinite copies of the application file... LOL... oh cat,
       I really didn't think to this, and feel quite stupid at the moment...)
	[source string] = comp;
	[target string] = applic name;
	=> strcmp;
      ? failed -> sp not trying to link this same application file;
      (so if this IS the application file...)
	[source string] = cpbk;
	[target string] = comp;
	=> strcpy; (...restore "comp" from "cpbk"...)
	-> sp search again; (...and pass to next file, fixing infinite loops!)
      "sp not trying to link this same application file"
      (test if the file is really present and readable)
	[filecommand] = test;
	[filename] = comp;
	isocall;
      ? [filestatus] + error -> err cannot access compound; (fatal)
      ? [filestatus] - permit to read -> err cannot access compound; (fatal)
	[sfcs] = [file size];
      (returning to work path of the main source code to compile:
       this is also necessary before any operations that may log errors to
       the errors log, or notes to the symbols map, such as "put symbol",
       which may protest on invalid symbol names)
	[filecommand] = set dir;
	[filename] = path;
	isocall;
      ? ok -> sp on work path again;
      (unfortunately, if it isn't possible to return to the work path of the
       main source code, where the error log is supposed to stay, the compiler
       must fail "silently", because it can't access the error log from here:
       if it streamed a message to the error log now, a new error log would be
       created in the actual compound path, but that'd be of course wrong; the
       error might be a malfunction of the file system, rare if not pratically
       impossible, so I don't mind that much...)
	fail;
      "sp on work path again"
      ? [pass] > 1 -> sp link; (if not in pass 1, we're in stck pass)
      (see if this file was already linked: the check is made only on the
       file name, without path and without extension, because the compiler
       will have to define symbols basing on that name, so it isn't possible
       at all to include two files with the same name, no matter if they're
       in different paths or have different extensions: names must be unique)
	[symbol name] = b;
	=> get symbol;
      ? ok -> err cannot include two compounds having same name; (fatal)
      (making the compound file name constant, giving its position in stock)
	a = b; (a = symbol name, which is file name)
	=> put symbol;
	a = [ps symbol record];
	[a plus value] = [sfbp]; (symbol value = StockFile Byte Position)
	[a plus flags] = constant; (symbol type = a constant)
      (making the compound file size constant, giving its size in bytes)
	[source string] = pfx sizeof;
	[target string] = temp symbol;
	=> strcpy; (copying pfx sizeof to temp symbol)
	[source string] = b;
	=> strcat; (concatenating file name to make "sizeof filename")
	a = temp symbol;
	=> put symbol;
	a = [ps symbol record];
	[a plus value] = [sfcs]; (symbol value = tested [file size])
	[a plus flags] = constant; (symbol type = a constant, too, of course)
	-> sp return; (end of duties for pass 1)
      "sp link"
      (note this part is accessed only in stck pass:
       linking compound, which name's held in "comp" buffer, to the stockfile)
	[source file] = comp;		(cat file data from this file...)
	[target file] = applic name;	(...to this file)
	=> fcat;
      ? failed -> err failed to concatenate compound to stockfile;
      (logging compound's symbols into symbols map: the last pass logged all
       other symbols, so these will be logged at the bottom of the symbols map
       because the "stck pass" comes after the "last pass", reflecting its
       place in the mechanism that assembles the application file's pieces...)
      ? [sfbp] > zero -> sp log below; (no blank line if not first compound)
	[source string] = eol;
	[target string] = log output;
	=> strcpy;
	=> log report; (just add a blank line before stockfile constants)
      "sp log below"
	[source string] = lnk string;
	[target string] = log output;
	=> strcpy;
	[source string] = comp;
	=> strcat;
	[source string] = eol;
	=> strcat;
	=> log report; (report which exact file you have been linking)
	[sym string] = b;
	[cls string] = cls constant;
	[sym value] = [sfbp];
	=> log symbol; (log the constant with its position in the stockfile)
      (it's no repeated step: it needs to rebuild the "sizeof" string within
       "temp symbol" because when it was building it above, it was only for
       registering that symbol into the symbols map on pass 1, however the
       stockfile physically logs its symbols to the "smblsmap.txt" file only
       in the "stck" pass, which comes later...)
	[source string] = pfx sizeof;
	[target string] = temp symbol;
	=> strcpy; (copying pfx sizeof to temp symbol)
	[source string] = b;
	=> strcat; (concatenating file name to make "sizeof filename")
	[sym string] = temp symbol;
	[cls string] = cls constant;
	[sym value] = [sfcs];
	=> log symbol; (log the constant with the size of the compound file)
      "sp return"
      (updating stockfile byte position counter)
	[sfbp] + [sfcs];
      (zeroing reg B before returning to parser:
       it's not needed to save register B on entry to this period parser, for
       restoring it now, because on entry, here, register B is obviously not
       holding those flags for the parser signalling an open string, an open
       label, or the fact that a string has just been closed: there's no such
       entities in the middle of the "stockfile" period)
	b = zero;
	-> parse reset;

    (stockfile parser error messages)
    "err stockfile compound not found"
      (these errors must return to main source path before loggin a message)
	[filecommand] = set dir;
	[filename] = path;
	isocall;
      ? failed -> err j1;
	[err string] = msg stockfile compound not found;
	[cls string] = fser string;
	=> log error;
      "err j1"
	fail;
    "err cannot access compound"
      (these errors must return to main source path before loggin a message)
	[filecommand] = set dir;
	[filename] = path;
	isocall;
      ? failed -> err j2;
	[err string] = msg cannot access compound;
	[cls string] = fser string;
	=> log error;
      "err j2"
	fail;
    "err cannot include two compounds having same name"
      (no this doesn't need to return to main source path, it's already there)
	[err string] = msg cannot include two compounds having same name;
	-> log declaration error;
    "err failed to concatenate compound to stockfile"
      (no this doesn't need to return to main source path, it's already there)
	[err string] = msg failed to concatenate compound to stockfile;
	[cls string] = fser string;
	=> log error;
	fail;

    ("directors" - specific period parser)
    "service dirs parser"
      (the only valid syntax here is <director = something>...)
      ? [inst plus 0] != equal -> err wrong director statement;
      ? [inst plus 1] != null  -> err wrong director statement;
      ("symbolhash")
	[source string] = first operand relating pces;
	[target string] = dir symbolhash;
	=> strcmp;
      ? failed -> dp j1;
      ? [strd] != zero -> err wrong director statement;
	a = [shlo];
	a | [shhi];
      ? a != zero -> err there can be only one hash string;
 ---->; a = second operand relating pces;
	b = null; (null file SID hash, low  unit)
	e = null; (null file SID hash, high unit)
	c = minus 8; (shifter)
      "dp sid loop"
	d = [a];
	a +;
      ? d = null -> dp sid done;
	d * 123;
	c + 8;
	d & FFh;
	c & 3Fh;
	b - d;
	e + d;
      ? c >= 32 -> dp xor sid high;
	d < c;
	e +;
	b # d;
	-> dp sid loop;
      "dp xor sid high"
	d < c;
	b +;
	e # d;
	-> dp sid loop;
      "dp sid done"
	[sh lo] = b;
	[sh hi] = e;
 <----; a = [sh lo];
	a | [sh hi];
      ? a = null -> err invalid symbol hash;
	-> parse reset;
      "dp j1"
      (only "symbolhash" is parsed in all passes, the rest is parsed:
       - in last pass to resolve directors assigned to any kind of symbols;
       - in code pass to get [smap] flag, activating mapping for code labels.)
      ? [pass]	= last pass -> dp j2;
      ? [pass] != code pass -> parse reset;
      "dp j2"
      ("symbolsmap")
	[target string] = dir symbolsmap;
	=> strcmp;
      ? failed -> dp j3;
      ? [strd] != zero -> err wrong director statement;
	a = second operand relating pces;
	=> parse operand;
      ? [po error] = yes -> parse reset; (error was logged by parse operand)
      ? [po class] != immediate -> err director can only hold immediate value;
	[smap] | [po value]; (activate, but never disable while compiling)
	-> parse reset;
      "dp j3"
      (only "symbolsmap" is parsed in last pass AND in code pass - rest is
       parsed exclusively in last pass: from there onwards nothing changes.)
      ? [pass] != last pass -> parse reset;
      ("programname")
	[source string] = first operand relating pces;
	[target string] = dir programname;
	=> strcmp;
      ? failed -> dp j4;
      ? [strd] = zero -> err wrong director statement;
	b = regb cs programname; (tell "cat string" to fill "li app name")
	[pnbc] = zero; (must reset this counter - see "cat string" notes)
	=> cat string; (fill "li app name" upto 39 chars + a null byte)
	d = zero; (restore reg D, comment nid/level, modified by "cat string")
	-> parse reset;
      "dp j4"
      (all the rest except "programname")
      ? [strd] != zero -> err wrong director statement;
	a = second operand relating pces;
	=> parse operand;
      ? [po error] = yes -> parse reset; (error was logged by parse operand)
      ? [po class] != immediate -> err director can only hold immediate value;
      (preload, common to all following checks)
	[source string] = first operand relating pces;
      ("unit")
	[target string] = dir unit;
	=> strcmp;
      ? failed -> dp j5;
      ? [po value] != cpu unit -> err incompatible unit;
	[unit] = yes; ("unit=32" present and correct)
	-> parse reset;
      "dp j5"
      ("modularextensions")
	[target string] = dir modularextensions;
	=> strcmp;
      ? failed -> dp j6;
      ? [po value] '> 7 -> err unsupported modular extension;
	[rtmv] | [po value]; (set and accumulate flags, never "forget")
	-> parse reset;
      "dp j6"
      ("threadpriority")
	[target string] = dir threadpriority;
	=> strcmp;
      ? failed -> dp j7;
      ? [po value] '> 4 -> err invalid thread priority;
	[li app code pri] = [po value]; (hierarchic, main prog. rules)
	-> parse reset;
      "dp j7"
      ("displayxposition")
	[target string] = dir displayxposition;
	=> strcmp;
      ? failed -> dp j8;
      ? [po value] '> 1048576 -> err invalid display coordinate;
	[li lfb x at startup] = [po value]; (hierarchic, main prog. rules)
	-> parse reset;
      "dp j8"
      ("displayyposition")
	[target string] = dir displayyposition;
	=> strcmp;
      ? failed -> dp j9;
      ? [po value] '> 1048576 -> err invalid display coordinate;
	[li lfb y at startup] = [po value]; (hierarchic, main prog. rules)
	-> parse reset;
      "dp j9"
      ("displaywidth")
	[target string] = dir displaywidth;
	=> strcmp;
      ? failed -> dp j10;
      ? [po value] '> 1048576 -> err invalid display dimension;
	[li lfb w at startup] = [po value]; (hierarchic, main prog. rules)
	-> parse reset;
      "dp j10"
      ("displayheight")
	[target string] = dir displayheight;
	=> strcmp;
      ? failed -> dp j11;
      ? [po value] '> 1048576 -> err invalid display dimension;
	[li lfb h at startup] = [po value]; (hierarchic, main prog. rules)
	-> parse reset;
      "dp j11"
      ("displaymode")
	[target string] = dir displaymode;
	=> strcmp;
      ? failed -> dp j12;
      ? [po value] '> 1 -> err invalid display mode;
	[li display mode] = [po value]; (hierarchic, main prog. rules)
	-> parse reset;
      "dp j12"
      ("pointermode")
	[target string] = dir pointermode;
	=> strcmp;
      ? failed -> dp j13;
      ? [po value] '> 1 -> err invalid pointer mode;
	[li pointer mode] = [po value]; (hierarchic, main prog. rules)
	-> parse reset;
      "dp j13"
      ("testflags")
	[target string] = dir testflags;
	=> strcmp;
      ? failed -> err unknown director tag; (no more known tags)
      ? [po value] '> 15 -> err unsupported test flag;
	[li test flags] | [po value]; (set, and accumulate, these flags)
	-> parse reset;

    (directors parser error messages)
    "err wrong director statement"
	[err string] = msg wrong director statement;
	-> log syntax error;
    "err there can be only one hash string"
	[err string] = msg there can be only one hash string;
	-> log declaration error;
    "err invalid symbol hash"
	[err string] = msg invalid symbol hash;
	-> log declaration error;
    "err director can only hold immediate value"
	[err string] = msg director can only hold immediate value;
	-> log declaration error;
    "err incompatible unit"
	[err string] = msg incompatible unit;
	-> log declaration error;
    "err negative cpu delay"
	[err string] = msg negative cpu delay;
	-> log declaration error;
    "err unsupported modular extension"
	[err string] = msg unsupported modular extension;
	-> log declaration error;
    "err invalid thread priority"
	[err string] = msg invalid thread priority;
	-> log declaration error;
    "err invalid display coordinate"
	[err string] = msg invalid display coordinate;
	-> log declaration error;
    "err invalid display dimension"
	[err string] = msg invalid display dimension;
	-> log declaration error;
    "err invalid display mode"
	[err string] = msg invalid display mode;
	-> log declaration error;
    "err invalid pointer mode"
	[err string] = msg invalid pointer mode;
	-> log declaration error;
    "err unsupported test flag"
	[err string] = msg unsupported test flag;
	-> log declaration error;
    "err unknown director tag"
	[err string] = msg unknown director tag;
	-> log declaration error;

    ("constants" - specific period parser)
    "service cons parser"
      ? [inst plus 0] != equal -> err wrong declaration of constant;
      ? [inst plus 1] != null  -> err wrong declaration of constant;
	a = first operand relating pces;
	=> put symbol;
	a = second operand relating pces;
	=> parse operand;
      ? [po error] = no -> cp declare;
      (suspend this constant)
	[sssp] = true;
	a = [ps symbol record];
	[a plus value] = [po value];
	[a plus flags] | suspended plus constant;
	-> parse reset;
      "cp declare"
      (declare this constant)
      ? [po addrx] = yes -> err causal ring;
      ? [po class] != immediate -> err constant needs immediate value;
	a = [ps symbol record];
	[a plus value] = [po value];
	[a plus flags] & not suspended;
	[a plus flags] | constant;
      ? [po float] = no -> cp integer;
	[a plus flags] | fp;
      "cp integer"
      (in last pass, log constant to symbols map)
      ? [pass] != last pass -> parse reset;
	[sym string] = first operand relating pces;
	[cls string] = cls constant;
	[sym value] = [a plus value];
	=> log symbol;
	-> parse reset;

    (constants parser error messages)
    "err wrong declaration of constant"
	[err string] = msg wrong declaration of constant;
	-> log syntax error;
    "err constant needs immediate value"
	[err string] = msg constant needs immediate value;
	-> log declaration error;
    "err causal ring"
	[err string] = msg causal ring;
	-> log declaration error;

    ("variables" - specific period parser)
    "service vars parser"
      ? [inst plus 0] = equal -> vp assignment;
      ? [inst plus 0] = null -> vp implicitly unlabeled unit;
      ? [inst plus 0] = colon -> vp alignment;
      ? [inst plus 0] = asterisk -> vp implicitly unlabeled area;
      "vp assignment"
      ? [inst plus 1] = null -> vp unit;
      ? [inst plus 1] = asterisk -> vp area;
	-> err wrong declaration of variable;
      (react to syntax: <[no]label|vector/matrix/array... = value|{string};>)
      "vp unit"
	[ps symbol record] = null;
	[source string] = first operand relating pces;
	[target string] = pfx nolabel;
	=> strcmp;
      ? ok -> vpu unlabeled;
	a = first operand relating pces;
	=> put symbol; (register variable name)
	=> realign tow;
	[lkea] = [dpos]; (update Last Known Effective Address)
	[lkea] > 5;
      "vpu unlabeled"
      ? [strd] = no -> vpu no string;
	a = [ps symbol record];
      ? a = null -> vpu nolabel string;
	[a plus value] = [dpos];
	[a plus value] > 5;
	[a plus flags] & not suspended;
	[a plus flags] | static plus address;
      "vpu nolabel string"
	b = null;
	=> cat string;
	d = zero; (restore reg D, comment nid/level, modified by "cat string")
	-> vp log;
      "vpu no string"
	a = second operand relating pces;
	=> parse operand; (parse variable's initial value)
      ? [po error] = yes -> vp suspend;
      ? [po class] != immediate
	  -> err variable initialization needs immediate value;
	a = [ps symbol record];
      ? a = null -> vpu no address;
	[a plus value] = [dpos];
	[a plus value] > 5;
	[a plus flags] & not suspended;
	[a plus flags] | static;
	[source string] = first operand relating pces;
	[target string] = pfx shared;
	=> strpcmp;
      ? failed -> vpu examine secondary prefix;
	[source string] + 6;
      "vpu examine secondary prefix"
	[target string] = pfx vector;
	=> strpcmp;
      ? ok -> vpu address;
	[target string] = pfx matrix;
	=> strpcmp;
      ? ok -> vpu address;
	[target string] = pfx array;
	=> strpcmp;
      ? failed -> vpu no address;
      "vpu address"
	[a plus flags] | address;
      "vpu no address"
      (update top of workspace, account for 1 more unit)
	[dpos] + [make];
      (if in data pass, stream variable's initial value to application file)
      ? [pass] != data pass -> vp log;
	[dval] = [po value];
	[cd stack waste] = 0; (main flow, routed here via a "-> [perp];")
	=> cat unit;
	-> vp log;
      (react to syntax: <value;|{string}> - implicitly unlabeled)
      "vp implicitly unlabeled unit"
	[ps symbol record] = null;
      ? [strd] = no -> vpiuu no string;
	b = null;
	=> cat string;
	d = zero; (restore reg D, comment nid/level, modified by "cat string")
	-> parse reset;
      "vpiuu no string"
	a = first operand relating pces;
	=> parse operand; (parse unlabeled variable's initial value)
      ? [po error] = yes -> vp suspend;
      ? [po class] != immediate
	  -> err variable initialization needs immediate value;
      (update top of workspace, account for 1 more unit)
	[dpos] + [make];
      (if in data pass, stream variable's initial value to application file)
      ? [pass] != data pass -> parse reset;
	[dval] = [po value];
	[cd stack waste] = 0; (main flow, routed here via a "-> [perp];")
	=> cat unit;
	-> parse reset;
      (react to syntax: <[no]label = value *** duplications;>)
      "vp area"
      ? [inst plus 2] != asterisk -> err wrong declaration of variable;
      ? [inst plus 3] != asterisk -> err wrong declaration of variable;
      ? [inst plus 4] != null -> err wrong declaration of variable;
      ? [strd] != no -> err wrong declaration of variable; (string *** ?!)
	[ps symbol record] = null;
	[source string] = first operand relating pces;
	[target string] = pfx nolabel;
	=> strcmp;
      ? ok -> vpa unlabeled;
	a = first operand relating pces;
	=> put symbol; (register area name)
	=> realign tow;
	[lkea] = [dpos]; (update Last Known Effective Address)
	[lkea] > 5;
      "vpa unlabeled"
	a = second operand relating pces;
	=> parse operand; (parse value to fill area with)
      ? [po error] = yes -> vp suspend;
      ? [po class] != immediate
	  -> err variable initialization needs immediate value;
	[dval] = [po value]; (later use)
	a = third operand relating pces;
	=> parse operand; (parse duplications count)
      ? [po error] = yes -> vp suspend;
      ? [po class] != immediate
	  -> err duplications count needs immediate value;
      ? [po value] < zero -> err negative duplications count;
      (eventually log a warning into errors' log at last pass, in case a
       "no-label" area is also void, because an unlabeled area can be a
       filler, a labeled but void area can be useful too, as a marker, but
       a void unlabeled area is really an idiocy...)
      ? [ps symbol record] != null -> vpa stream;
      ? [po value] != zero -> vpa stream;
      ? [pass] != last pass -> parse reset;
	[err string] = msg useless declaration;
	=> log warning;
	-> parse reset;
      "vpa stream"
	a = [ps symbol record];
      ? a = null -> vpa nolabel;
	[a plus value] = [dpos];
	[a plus value] > 5;
	[a plus flags] & not suspended;
	[a plus flags] | static plus address;
      "vpa nolabel"
      (update top of workspace, account for <duplications' count> units)
	a = [po value];
	a * [make];
	[dpos] + a;
      (if in data pass, fill area within application file)
      ? [pass] != data pass -> vp log;
      ? [po value] = zero -> vp log; (never "cat data" with [dlen]=0)
	[dlen] = [po value];
	[cd stack waste] = 0; (main flow, routed here via a "-> [perp];")
	=> cat data;
	-> vp log;
      (react to syntax: <value *** duplications;> - implicitly unlabeled)
      "vp implicitly unlabeled area"
      ? [inst plus 1] != asterisk -> err wrong declaration of variable;
      ? [inst plus 2] != asterisk -> err wrong declaration of variable;
      ? [inst plus 3] != null -> err wrong declaration of variable;
      ? [strd] != no -> err wrong declaration of variable; (string *** ?!)
	[ps symbol record] = null;
	a = first operand relating pces;
	=> parse operand; (parse value to fill area with)
      ? [po error] = yes -> vp suspend;
      ? [po class] != immediate
	  -> err variable initialization needs immediate value;
	[dval] = [po value];
	a = second operand relating pces;
	=> parse operand; (parse duplications count)
      ? [po error] = yes -> vp suspend;
      ? [po class] != immediate
	  -> err duplications count needs immediate value;
      ? [po value] < zero -> err negative duplications count;
      (eventually log a warning into errors' log at last pass, in case
       the unlabeled area is also void, because an unlabeled area can be a
       filler, a labeled but void area can be useful too, as a marker, but
       a void unlabeled area is really an idiocy...)
      ? [po value] != zero -> vpiua stream;
      ? [pass] != last pass -> parse reset;
	[err string] = msg useless declaration;
	=> log warning;
	-> parse reset;
      "vpiua stream"
      (update top of workspace, account for <duplications' count> units)
	a = [po value];
	a * [make];
	[dpos] + a;
      (if in data pass, fill area within application file)
      ? [pass] != data pass -> parse reset;
	[dlen] = [po value];
	[cd stack waste] = 0; (main flow, routed here via a "-> [perp];")
	=> cat data;
	-> parse reset;
      (suspend variable)
      "vp suspend"
	[sssp] = true;
	a = [ps symbol record];
      ? a = null -> parse reset;
	[a plus value] = [po value];
	[a plus flags] | suspended plus static;
	-> parse reset;
      (in last pass, log variable's address to symbols map)
      "vp log"
      ? [pass] != last pass -> parse reset;
	a = [ps symbol record];
      ? a = null -> parse reset;
	[sym string] = first operand relating pces;
	[cls string] = cls variable;
	[sym value] = [a plus value];
	=> log symbol;
	-> parse reset;
      (parse alignment directive)
      "vp alignment"
	[source string] = first operand relating pces;
	[target string] = tag make;
	=> strcmp;
      ? ok -> vp make;
	[source string] = first operand relating pces;
	[target string] = tag extend upto;
	=> strcmp;
      ? ok -> vp extend upto;
	[source string] = first operand relating pces;
	[target string] = tag align at;
	=> strcmp;
      ? ok -> vp align at;
	-> err unknown alignment directive;
      "vp make"
	[source string] = second operand relating pces;
	[target string] = tag bits;
	=> strcmp;
      ? ok -> vp make bits;
	[target string] = tag nybbles;
	=> strcmp;
      ? ok -> vp make nybbles;
	[target string] = tag compact strings;
	=> strcmp;
      ? ok -> vp make compact strings;
	[target string] = tag bytes;
	=> strcmp;
      ? ok -> vp make bytes;
	[target string] = tag words;
	=> strcmp;
      ? ok -> vp make words;
	[target string] = tag doublewords;
	=> strcmp;
      ? ok -> vp make doublewords;
	[target string] = tag quadwords;
	=> strcmp;
      ? ok -> vp make quadwords;
	[target string] = tag units;
	=> strcmp;
      ? ok -> vp make units;
	=> atoui;
      ? failed -> err illegal value for make directive;
      ? [string binary] <= 0 -> err illegal value for make directive;
      ? [string binary] > 64 -> err illegal value for make directive;
	[make] = [string binary];
	[natu] = true;
	-> parse reset;
      "vp make bits"
	[make] = 1;
	[natu] = true;
	-> parse reset;
      "vp make nybbles"
	[make] = 4;
	[natu] = true;
	-> parse reset;
      "vp make compact strings"
	[make] = 7;
	[natu] = true;
	-> parse reset;
      "vp make bytes"
	[make] = 8;
	[natu] = true;
	-> parse reset;
      "vp make words"
	[make] = 16;
	[natu] = true;
	-> parse reset;
      "vp make doublewords"
	[make] = 32;
	[natu] = true;
	-> parse reset;
      "vp make quadwords"
	[make] = 64;
	[natu] = true;
	-> parse reset;
      "vp make units"
	=> realign tow;
	[make] = 32;
	[natu] = false;
	-> parse reset;
      "vp extend upto"
      ? [natu] = true -> err invalid alignment;
	[ps symbol record] = null;
	a = second operand relating pces;
	=> parse operand; (parse amount to extend area to)
      ? [po error] = yes -> vp suspend;
      ? [po class] != immediate
	  -> err alignment directive needs immediate value;
	[dlen] = [po value];
	[dlen] + [lkea];
	a = [dpos];
	a > 5;
	[dlen] - a;
      ? [dlen] = zero -> parse reset; (aligned already)
      ? [dlen] < zero -> err last labeled symbol is longer than that;
      "vp eu align at reentry"
      (update top of workspace, account for <alignment> units)
	a = [dlen];
	a < 5;
	[dpos] + a;
      (if in data pass, fill area within application file, with null units)
      ? [pass] != data pass -> parse reset;
	[dval] = null;
	[cd stack waste] = 0; (main flow, routed here via a "-> [perp];")
	=> cat data;
	-> parse reset;
      "vp align at"
      ? [natu] = true -> err invalid alignment;
	[ps symbol record] = null;
	a = second operand relating pces;
	=> parse operand; (parse amount to align area at)
      ? [po error] = yes -> vp suspend;
      ? [po class] != immediate
	  -> err alignment directive needs immediate value;
      ? [po value] <= zero -> err invalid alignment;
	a = [dpos];
	a > 5;
	a '% [po value];
      ? a = zero -> parse reset; (aligned already)
	[dlen] = [po value];
	[dlen] - a;
	-> vp eu align at reentry;

    (variables parser auxiliary routines)
    "realign tow"
      ? [dbss] < dcache size minus 32 -> rt cache is not full yet;
	=> flush data cache;
      ? failed -> cd error;
      "rt cache is not full yet"
	a = [dpos];
	a & 11111b;
      ? a = zero -> rt aligned already;
	[dpos] + 32;
	[dpos] - a;
      ? [pass] != data pass -> rt aligned already;
	[dbss] + 32;
	[dbss] - a;
      "rt aligned already"
	leave;
    "cat unit"
	[dlen] = 1;
    "cat data"
      ? [natu] = true -> cd make bitstream;
      "cd make units"
      ? [dbss] < dcache size -> cd mu cache is not full yet;
	=> flush data cache;
      ? failed -> cd error;
      "cd mu cache is not full yet"
	a = [duss];
	[a relating data] = [dval];
	[dbss] + 32;
	[duss] +;
	[dlen] ^ cd make units;
	leave;
      "cd make bitstream"
      ? [dbss] < dcache size minus 64 -> cd mb cache is not full yet;
	=> flush data cache;
      ? failed -> cd error;
      "cd mb cache is not full yet"
	a = [make];
	[starting bit number] = [dbss];
      ? a < 64 -> cd mb continue;
	a = 32;
      ? [bea] - bea dat -> cd mb continue;
	[starting bit number] + [make];
	[starting bit number] - 32;
      "cd mb continue"
	[bit stream pointer]  = data;
	[bit field size]      = a;
	[bit field content]   = [dval];
	---->;
	=> set bit field;
	<----;
	[dbss] + [make];
	[dlen] ^ cd make bitstream;
	a = [dbss];
	a > 5;
      ? [dbss] - 11111b -> cd mb no incomplete units;
	a +;
      "cd mb no incomplete units"
	[duss] = a;
	leave;
      "cd error"
	[err string] = msg could not stream static data to application file;
	[cls string] = fser string;
	=> log error;
	$ + [cd stack waste]; (discard call to "cat data")
	fail; (it's a fatal error, fail parser)
    "flush data cache"
      ? [dbss] = zero -> fdc nothing to flush;
	[file command] = test;
	[file name] = applic name;
	isocall;
      ? ok -> fdc go write;
	fail;
      "fdc go write"
      ? [bea] - bea dat -> fdc write as is;
	[area to swap] = data;
	[size of area to swap] = [dbss];
	[size of area to swap] > 5;
      ? [dbss] - 11111b -> fdc no incomplete units;
	[size of area to swap] +;
      "fdc no incomplete units"
	=> swap endian;
      "fdc write as is"
	[file command] = write;
	[file name] = applic name;
	[file position] = [file size];
	[block pointer] = data;
	[block size] = [dbss];
	[block size] > 3;
      ? [dbss] - 111b -> fdc no incomplete bytes;
	[block size] +;
      "fdc no incomplete bytes"
	isocall;
      ? ok -> fdc cleanup;
	fail;
      "fdc cleanup"
	a = dcache size div 32;
      "fdc cleanup loop"
	[a minus 1 relating data] = zero;
	a ^ fdc cleanup loop;
	[dbss] = zero;
	[duss] = zero;
      "fdc nothing to flush"
	end;

    (variables parser error messages)
    "err wrong declaration of variable"
	[err string] = msg wrong declaration of variable;
	-> log syntax error;
    "err variable initialization needs immediate value"
	[err string] = msg variable initialization needs immediate value;
	-> log declaration error;
    "err duplications count needs immediate value"
	[err string] = msg duplications count needs immediate value;
	-> log declaration error;
    "err negative duplications count"
	[err string] = msg negative duplications count;
	-> log declaration error;
    "err unknown alignment directive"
	[err string] = msg unknown alignment directive;
	-> log syntax error;
    "err alignment directive needs immediate value"
	[err string] = msg alignment directive needs immediate value;
	-> log declaration error;
    "err illegal value for make directive"
	[err string] = msg illegal value for make directive;
	-> log declaration error;
    "err last labeled symbol is longer than that"
	[err string] = msg last labeled symbol is longer than that;
	-> log declaration error;
    "err invalid alignment"
	[err string] = msg invalid alignment;
	-> log declaration error;

    ("workspace" - specific period parser)
    "service wksp parser"
      ? [inst plus 0] = equal -> wp area;
      ? [inst plus 0] = null -> wp implicitly unlabeled area;
	-> err wrong declaration of workspace area label;
      (react to syntax: <[no]label = units-count;>)
      "wp area"
	[ps symbol record] = null;
	[source string] = first operand relating pces;
	[target string] = pfx nolabel;
	=> strcmp;
      ? ok -> wpa unlabeled;
	a = first operand relating pces;
	=> put symbol; (register area name)
      "wpa unlabeled"
	a = second operand relating pces;
	=> parse operand; (parse area units count)
      ? [po error] = yes -> wp suspend;
      ? [po class] != immediate
	  -> err workspace area allocation needs immediate units count;
      ? [po value] < zero -> err negative duplications count;
      (eventually log a warning into errors' log at last pass, in case a
       "no-label" area is also void, because an unlabeled area can be a
       filler, a labeled but void area can be useful too, as a marker, but
       a void unlabeled area is really an idiocy...)
      ? [ps symbol record] != null -> wpa stream;
      ? [po value] != zero -> wpa stream;
      ? [pass] != last pass -> parse reset;
	[err string] = msg useless declaration;
	=> log warning;
	-> parse reset;
      "wpa stream"
	a = [ps symbol record];
      ? a = null -> wpa no label;
	[a plus value] = [wpos];
	[a plus value] + [prws];
	[a plus flags] & not suspended;
	[a plus flags] | static plus address;
      "wpa no label"
      (update top of workspace, account for <units count> more units)
	[wpos] + [po value];
      (in last pass, log labeled workspace area addresses to symbols map)
      ? [pass] != last pass -> parse reset;
	a = [ps symbol record];
      ? a = null -> parse reset;
	[sym string] = first operand relating pces;
	[cls string] = cls wrkspace;
	[sym value] = [a plus value];
	=> log symbol;
	-> parse reset;
      (react to syntax: <units-count;> - implicitly unlabeled)
      "wp implicitly unlabeled area"
	[ps symbol record] = null;
	a = first operand relating pces;
	=> parse operand; (parse area units count)
      ? [po error] = yes -> wp suspend;
      ? [po class] != immediate
	  -> err workspace area allocation needs immediate units count;
      ? [po value] < zero -> err negative duplications count;
      (eventually log a warning into errors' log at last pass, in case
       the unlabeled area is also void, because an unlabeled area can be a
       filler, a labeled but void area can be useful too, as a marker, but
       a void unlabeled area is really an idiocy...)
      ? [po value] != zero -> wpiua stream;
      ? [pass] != last pass -> parse reset;
	[err string] = msg useless declaration;
	=> log warning;
	-> parse reset;
      "wpiua stream"
      (update top of workspace, account for <units count> more units)
	[wpos] + [po value];
	-> parse reset;
      (suspend workspace area label)
      "wp suspend"
	[sssp] = true;
	a = [ps symbol record];
      ? a = null -> parse reset;
	[a plus value] = [po value];
	[a plus flags] | suspended plus static;
	-> parse reset;

    (workspace parser error messages)
    "err wrong declaration of workspace area label"
	[err string] = msg wrong declaration of workspace area label;
	-> log syntax error;
    "err workspace area allocation needs immediate units count"
	[err string] =
	  msg workspace area allocation needs immediate units count;
	-> log declaration error;

    ("programme" - specific period parser)
    "service prog parser"
      (increase instructions counter for current file)
	[fins] +;
      (clean up operand classes to mean that no operands were found so far)
	[op1 class] = null;
	[op2 class] = null;
	[op3 class] = null;
      (this flag will accumulate errors from "parse operand": if at least one
       operand caused one such error, the error will be reported by "parse
       operand" itself, but if this flag wasn't used, the instruction patterns
       search loop, looking on error for a possibly non-existing configuration
       of operand classes, may give a double error; it doesn't cause any real
       troubles, but it's silly to have two messages in the log because of the
       same, exact mistake; the problem would not happen for missing symbol
       names, which would be typical in pass 1, but it would for expressions'
       syntax errors where the whole operand class would not correspond to the
       intended class for the instruction, which is where search loops fail;
       notes of "parse operand" in effect state that the expression class is
       unpredictable on error, but in reality it applies to expression syntax
       errors, like missing a square bracket, writing a wrong combination of
       tags, writing a register not as the first element of the expression...
       because if the error is a "naming error", with references to symbols
       that were not declared, mistyped or simply - in pass 1 - not yet met by
       the parser, then the operand's class is correct anyway, and that's what
       counts for pattern selection here...)
	[opx error] = false;
      (ok, first thing: having no instruction signs here is nonsensical,
       unless the first operand is a tag like "isocall", "nop", etc...)
	a = [inst plus 0]; (preload)
	b = [inst plus 1]; (preload)
	c = [inst plus 2]; (preload)
	d = [inst plus 3]; (preload)
      ? a != null -> pp continue;
      (check tags for monolithic instructions)
	[source string] = first operand relating pces;
	[target string] = tag isocall;
	=> strcmp;
      ? ok -> pp isocall;
	[target string] = tag leave;
	=> strcmp;
      ? ok -> pp leave;
	[target string] = tag end;
	=> strcmp;
      ? ok -> pp end;
	[target string] = tag fail;
	=> strcmp;
      ? ok -> pp fail;
	[target string] = tag nop;
	=> strcmp;
      ? ok -> pp nop;
	[target string] = tag showregs;
	=> strcmp;
      ? ok -> pp fail;
      (no tag and no signs: nonsensical code warning)
	[err string] = msg nonsensical code;
	=> log warning;
	-> pp exit;
      (isocall is the only non-monolithic tag, at least internally)
      "pp isocall"
	[source string] = q02; (internal =>)
	[target string] = inst;
	=> strcpy;
	[source string] = op isokernel; ([isokernel])
	[target string] = first operand relating pces;
	=> strcpy;
	-> pp parse;
      (all the rest is monolithic)
      "pp leave"
	[source string] = q13; (internal ///)
	[target string] = inst;
	=> strcpy;
	-> pp closes program;
      "pp end"
	[source string] = q12; (internal /\/)
	[target string] = inst;
	=> strcpy;
	-> pp closes program;
      "pp fail"
	[source string] = q11; (internal \/\)
	[target string] = inst;
	=> strcpy;
       (-> pp closes program;)
      "pp closes program"
      ? [levl] > zero -> pp monolithic;
	[endt] = yes;
	-> pp monolithic;
      "pp nop"
	[source string] = q68; (internal /-/)
	[target string] = inst;
	=> strcpy;
	-> pp monolithic;
      "pp continue"
      (see if the first sign is a single quote, and followed by *, / or %,
       and no more signs: in these cases acknowledge those instructions as
       their official versions, which are *', /' and %', also care for the
       ultimately added synonym of /%', checking for a '/% alternative...)
      ? a != quote    -> pp j1;
      ? c != null     -> pp j2;
      ? b  = asterisk -> pp j3;
      ? b  = slash    -> pp j3;
      ? b  = percent  -> pp j3;
	-> pp j1;
      "pp j2"
      ? b != slash -> pp j1;
      ? c != percent -> pp j1;
      ? d != null -> pp j1;
	[inst plus 0] = b; (/)
	[inst plus 1] = c; (%)
	[inst plus 2] = a; (')
	-> pp j1;
      "pp j3"
	[inst plus 0] <> [inst plus 1];
	-> pp parse;
      "pp j1"
      (check for ?-> as an instruction string: if it's that, it might be a
       tagged conditional jump such as "? ok" or "? failed", whose real
       internal codes are untypeable because then contain parenthesis)
      ? a != question mark -> pp j4; (?)
      ? b  = quote	   -> pp j5; (?' is another case checked here)
      ? b != hyphen	   -> pp j4; (-)
      ? c != greater than  -> pp j4; (>)
      ? d != null -> pp j4;
	[source string] = first operand relating pces;
	[target string] = tag ok;
	=> strcmp;
      ? ok -> pp jsuccess;
	[target string] = tag failed;
	=> strcmp;
      ? failed -> pp j4;
	[source string] = q10; (? failed -> label;)
	[target string] = inst;
	=> strcpy; (copy instruction's internal code)
	[source string] = second operand relating pces;
	[target string] = first operand relating pces;
	=> strcpy; (copy second operand to first)
	[second operand relating pces] = null; (void second operand)
	-> pp parse;
      "pp jsuccess"
	[source string] = q09; (? ok -> label;)
	[target string] = inst;
	=> strcpy; (copy instruction's internal code)
	[source string] = second operand relating pces;
	[target string] = first operand relating pces;
	=> strcpy; (copy second operand to first)
	[second operand relating pces] = null; (void second operand)
	-> pp parse;
      "pp j5"
      (j5 checks for a fork of the condition where the first two signs of the
       instruction string are <question mark, single quote>, to translate the
       possible, but useless, "unsigned" jumps if equal/if not equal...)
      ? c != equal -> pp j6;			(?'=)
      ? d != hyphen -> pp j6;			(-)
      ? [inst plus 4] != greater than -> pp j6; (>)
      ? [inst plus 5] != null -> pp j6;
      (?'=-> becomes ?=->)
	[inst plus 1] = equal;
	[inst plus 2] = hyphen;
	[inst plus 3] = greater than;
	[inst plus 4] = null;
	-> pp parse;
      "pp j6"
      ? c != exclaim -> pp j4;			(?'!)
      ? d != equal -> pp j4;			(=)
      ? [inst plus 4] != hyphen -> pp j4;	(-)
      ? [inst plus 5] != greater than -> pp j4; (>)
      (?'!=-> becomes ?!=->)
	[inst plus 1] = exclaim;
	[inst plus 2] = equal;
	[inst plus 3] = hyphen;
	[inst plus 4] = greater than;
	[inst plus 5] = null;
	-> pp parse;
      "pp j4"
      (j4 finally translates signed shift left to unsigned shift left)
      ? a != less than -> pp parse; (>)
      ? b != less than -> pp parse; (>)
      ? c != null -> pp parse;
      (>> becomes >)
	[inst plus 1] = null;
      "pp parse"
      (parse all the possible operands, er... complessively upto three)
	a = first operand relating pces;
      ? [a] = null -> pp monolithic; (no operands)
	=> parse operand;
	[opx error] | [po error];
	[op1 class] = [po class];
	[op1 regid] = [po regid];
	[op1 value] = [po value];
      ? [po class] > immediate -> pp1 pragmize warning; (not immediate)
      ? [pass] = 1 -> pp1 pragmize warning; (can't tell now)
      ? b = greater than -> pp1 jump check; (it may be a jump or a call...)
      ? b = hyphen -> pp1 state check; (it may be a "?ok|failed->label;")
      "pp1 scalar check"
      ? [po flags] - static plus codelabel -> pp1 pragmize warning; (n/mind)
      ? [po flags] + address -> pp1 pragmize warning; (declared pointable)
      ? [po pragm] = yes -> pp1 pragmize warning; (pragma used)
	[err string] = msg this is the address of first operand;
	=> log warning;
	-> pp1 pragmize warning;
      "pp1 jump check"
      ? c != null -> pp1 scalar check; (...nah, it wasn't a jump or call)
      ? [po flags] + codelabel -> pp1 pragmize warning; (right, it's a label)
      ? [po pragm] = yes -> pp1 pragmize warning; (pragma used)
	[err string] = msg need code label as destination for jump or call;
	=> log warning;
	-> pp1 pragmize warning;
      "pp1 state check"
      ? c != greater than -> pp1 scalar check; (wasn't a "?ok|failed->label;")
      ? [po pragm] = yes -> pp1 pragmize warning; (pragma used)
      ? [po flags] + codelabel -> pp1 pragmize warning; (right, it's a label)
	[err string] = msg need label as destination of state check directive;
	=> log warning;
      "pp1 pragmize warning"
	a = second operand relating pces;
      ? [a] = null -> pp monolithic; (one operand)
	=> parse operand;
	[opx error] | [po error];
	[op2 class] = [po class];
	[op2 regid] = [po regid];
	[op2 value] = [po value];
      ? [po class] > immediate -> pp2 pragmize warning; (not immediate)
      ? [pass] = 1 -> pp2 pragmize warning; (can't tell now)
      ? b = null -> pp2 integer loop check; (it may be a "...^label;")
      "pp2 scalar check"
      ? [po flags] - static plus codelabel -> pp2 pragmize warning; (n/mind)
      ? [po flags] + address -> pp2 pragmize warning; (declared pointable)
      ? [po pragm] = yes -> pp2 pragmize warning; (pragma used)
	[err string] = msg this is the address of second operand;
	=> log warning;
	-> pp2 pragmize warning;
      "pp2 integer loop check"
      ? [inst plus 0] != caret -> pp2 scalar check; (it wasn't a "...^label;")
      ? [po pragm] = yes -> pp2 pragmize warning; (pragma used)
      ? [po flags] + codelabel -> pp2 pragmize warning; (right, it's a label)
	[err string] = msg need label as destination of integer loop;
	=> log warning;
      "pp2 pragmize warning"
	a = third operand relating pces;
      ? [a] = null -> pp bilateral; (two operands)
      (ah, and three operands are only for comparison directives, which all
       begin by a question mark, so if there's no question mark, protest...)
      ? [inst plus 0] != question mark -> err extra operands to instruction;
	=> parse operand;
      ? [po class] != immediate -> err wrong usage of comparison directive;
      ? [pass] = 1 -> pp pragmize missing codelabel warning; (can't tell now)
      ? [po flags] + codelabel -> pp pragmize missing codelabel warning;
      ? [po pragm] = yes -> pp pragmize missing codelabel warning;
	[err string] = msg need label as destination of comparison directive;
	=> log warning;
      "pp pragmize missing codelabel warning"
	[opx error] | [po error];
	[op3 class] = [po class];
	[op3 regid] = [po regid];
	[op3 value] = [po value];
	-> pp monolithic;
      "pp bilateral"
      (check probable nonsensical combinations of opcode and operands: it will
       react with a warning if the instruction is a floating-point bilateral
       operation using [REG] as the first operand, REG as the second operand,
       and where REG is the same register in both operands, meaning that the
       programmer wants to use the same register both as a pointer and as a
       floating-point value; of course, the register can't be both things at
       the same time and it's absurd to use floating-point values as pointers)
      ? [op1 regid] != [op2 regid] -> pp j14;
      ? [op1 class] != indirect -> pp j14;
      ? [op2 class] != register -> pp j14;
      (now, these possibly paradoxical instructions must be 2 signs long)
      ? c != null -> pp monolithic;
      (reload first sign in register A for quick checks)
	a = [inst plus 0];
      (FTI)
      ? a != equal -> pp j7;
      ? b != comma -> pp j7;
	-> pp first nonsensical condition;
      (ITF)
      "pp j7"
      ? a != comma -> pp j8;
      ? b != equal -> pp j8;
	-> pp first nonsensical condition;
      (ADD.f)
      "pp j8"
      ? a != cross -> pp j9;
      ? b != cross -> pp j9;
	-> pp first nonsensical condition;
      "pp j9"
      (SUB.f)
      ? a != hyphen -> pp j10;
      ? b != hyphen -> pp j10;
	-> pp first nonsensical condition;
      "pp j10"
      (MUL.f)
      ? a != asterisk -> pp j11;
      ? b != asterisk -> pp j11;
	-> pp first nonsensical condition;
      "pp j11"
      (DIV.f)
      ? a != slash -> pp j12;
      ? b != slash -> pp j12;
	-> pp first nonsensical condition;
      "pp j12"
      (REM.f)
      ? a != percent -> pp j13;
      ? b != percent -> pp j13;
	-> pp first nonsensical condition;
      "pp j13"
      (ATN.f)
      ? a != caret -> pp j14;
      ? b != slash -> pp j14;
      "pp first nonsensical condition"
      (I wonder if this worths the efforts with all those checks, but...)
	[err string] = msg nonsensical code;
	=> log warning;
	-> pp monolithic;
      "pp j14"
      (now it will react with a different warning message for splits using the
       exact same operand, where the result may be unpredictable, but zero or
       one depending on the relevant instruction pattern's implementation...)
      ? [op1 class] != [op2 class] -> pp monolithic;
      ? [op1 regid] != [op2 regid] -> pp monolithic;
      ? [op1 value] != [op2 value] -> pp monolithic;
      ? a = quote -> pp j15;
      ? a = slash -> pp j16;
	-> pp monolithic;
      (SPL.n <operand>, <same operand>)
      "pp j15"
      ? b != slash -> pp monolithic;
      ? c != percent -> pp monolithic;
      ? d != null -> pp monolithic;
	-> pp second nonsensical condition;
      (SPL.i <operand>, <same operand>)
      "pp j16"
      ? b != percent -> pp monolithic;
      ? c != null -> pp monolithic;
      "pp second nonsensical condition"
	[err string] = msg nonsensical split using same operand;
	=> log warning;
	-> pp monolithic;
      "pp monolithic"
      (more generally, when getting here it means there's no further operands
       to process, and so it can begin seatching for the appropriate pattern:
       as a first thing, check for possible unusual CPU behavior to reverse
       stack references... by inverting the relevant operand of the very few -
       complessively four - instructions directly accessing the stack pointer)
      ? [acc] - acc reverse stack -> pp common stack behavior;
      ? [inst plus 0] = dollar -> pp invert first operand;
      ? b = dollar -> pp common stack behavior;
	[op2 value] +-;
	-> pp common stack behavior;
      "pp invert first operand"
	[op1 value] +-;
	-> pp common stack behavior;
      "pp common stack behavior"
      (search ip index record that matches operand types)
	[source string] = inst; (preload for strcmp)
	a = ip quickreference; (start with ip quickreference table's address)
	c = zero; (zero index in ip records' table)
	d = zero; (zero progressive index in cpu pack stream)
      "pp search by instruction string"
	[target string] = a;
	=> strcmp;
      ? failed -> pp next instruction string;
	b = [a plus 8]; (set reg. B to be a counter of indexed configurations)
	b / 3;
      "pp search by operands configuration"
      ? [op1 class] != [c plus 0 relating ip records] -> pp next cfg;
      ? [op2 class] = [c plus 1 relating ip records] -> pp found;
      "pp next cfg"
	d + [c plus 2 relating ip records];
	c + 3;
	b ^ pp search by operands configuration;
      (register B got to zero, there's no more records within the index for
       this instruction, but it may not be an error yet, because there's
       currently TWO, and exactly two, instructions having the same symbolic
       code but different operands config.: integer increment/bilateral
       addition and integer decrement/bilateral subtraction)
      ? a = q06 -> pp resume search for the two special cases only;
      ? a = q07 -> pp resume search for the two special cases only;
      (may be an error? yeah but it may be an expression syntax error which
       would have been already signalled by "parse operand": if it was, the
       flag [opx error] remembers this and doesn't put another silly message
       in the errors' log, which would be given by the same cause, and I hate
       when compilers do that...)
      ? [opx error] != false -> pp exit;
      (index record matching symbolic code and operand classes not found)
	[err string] = msg unsupported instruction syntax;
	[cls string] = synt string;
	=> log error;
	-> pp exit;
      "pp next instruction string"
	d + [a plus 7];
	c + [a plus 8];
      "pp resume search for the two special cases only"
	a + 9;
      ? a < 74 mtp 9 relating ip quickreference
	  -> pp search by instruction string;
      (quick reference record matching symbolic code not found)
	[err string] = msg unrecognized instruction;
	[cls string] = synt string;
	=> log error;
	-> pp exit;
      "pp found"
      (found instr. pattern - move to variant depending on register operands)
	a = zero;		(zero variant selector)
      ? [op1 class] = register -> pp adjust for first register operand;
      ? [op1 class] != indirect -> pp no first register operand;
      "pp adjust for first register operand"
	a = [op1 regid];	(variant selector depends on op1 regid)
      "pp no first register operand"
      ? [op2 class] = register -> pp adjust for second register operand;
      ? [op2 class] != indirect -> pp no second register operand;
      "pp adjust for second register operand"
	a * 5;			(accumulate op1 regid, upto 25 combinations)
	a + [op2 regid];	(variant selector also depends on op2 regid)
      "pp no second register operand"
	d + a;			(select variant)
      (well, now register D holds the progressive index of the appropriate
       instruction's variant within the stream of patterns of the cpu pack,
       but to be used as a progressive byte index in the stream, it has to
       be multiplied by the IPs' alignment and added 8 bytes to skip those
       of the cpu pack's header)
	d * [cpp algn];
	d + 8;
      (you get here only in pass 1 and in code pass: in pass 1 you're not
       requested to effectively build any code, just to check for errors and
       to advance the instruction pointer [bpos] depending on the instruction
       pattern size, which can be found only effectively processing ISMOs,
       but however, you don't need to fill the ISMOs, so doing a different
       loop still saves some time...)
	[esav] = e;
	e = [cpp ter1];
	[pb stream] = cpu pack;
	[pb offset] = d;
      ? [pass] = code pass -> pp build code;
      "pp pass one reload"
	=> get progressive byte;
	a = [pb bvalue];	(preload)
	[pb offset] +;
	=> get progressive byte;
	b = [pb bvalue];	(preload)
	[pb offset] +;
	=> get progressive byte;
	c = [pb bvalue];	(preload)
      "pp pass one loop"
      (advance offset, read next pattern byte)
	[pb offset] +;
	=> get progressive byte;
	d = [pb bvalue];
      (check end of pattern, look for termination code)
      ? a != e -> pp pass one continue; 		(+)
      ? b  = [cpp ter2] -> pp loop stop;		(+)
      "pp pass one continue"
      (ismo identification checks)
      ? d  = 49 -> pp po ismo search conf size; 	(1)
      ? d != 52 -> pp po opcode byte;			(4)
      "pp po ismo search conf size"
      ? b <  49 -> pp po opcode byte;			(1)
      ? b >  51 -> pp po opcode byte;			(3)
      (operand id confirmed valid)
      ? a  = 73 -> pp po ismo search conf type; 	(I)
      ? a  = 68 -> pp po ismo search conf type; 	(D)
      ? a != 76 -> pp po opcode byte;			(L)
      (ismo type is L, relative Label jump address)
      ? c <  65 -> pp po opcode byte;			(A)
      ? c >  90 -> pp po opcode byte;			(Z)
      (relative jump ismo valid)
      ? d != 52 -> pp po opcode byte;			(rel/jmp only 4 bytes)
	-> pp po ismo;
      "pp po ismo search conf type"
      (ismo type is I, Immediate, or D, Displacement)
      ? c != 46 -> pp po opcode byte;			(.)
      (immediate/displacement ismo valid)
      "pp po ismo"
      (update ip considering true size of ismo operand)
	d - 48; (opex - '0', D gives operand byte-size) (0)
	[pb offset] +;
	[bpos] + d;
	-> pp pass one reload; (reload, past this ismo)
      "pp po opcode byte"
      (update ip considering 1 opcode byte just passed)
	[bpos] +;
      (roll back the read-ahead registers and continue)
	a = b;
	b = c;
	c = d;
	-> pp pass one loop;
      (end "pass one" quick ISMO parser - begin "code pass" ISMO filler)
      "pp build code"
	=> get progressive byte;
	a = [pb bvalue];	(preload)
	[pb offset] +;
	=> get progressive byte;
	b = [pb bvalue];	(preload)
	[pb offset] +;
	=> get progressive byte;
	c = [pb bvalue];	(preload)
      "pp code pass loop"
      (advance offset, read next pattern byte)
	[pb offset] +;
	=> get progressive byte;
	d = [pb bvalue];
      (check end of pattern, look for termination code)
      ? a != e -> pp code pass continue;		(+)
      ? b  = [cpp ter2] -> pp loop stop;		(+)
      "pp code pass continue"
      (ismo identification checks)
      ? d  = 49 -> pp cp ismo search conf size; 	(1)
      ? d != 52 -> pp cp opcode byte;			(4)
      "pp cp ismo search conf size"
      ? b <  49 -> pp cp opcode byte;			(1)
      ? b >  51 -> pp cp opcode byte;			(3)
      (operand id confirmed valid)
      ? a  = 73 -> pp cp ismo search conf immediate;	(I)
      ? a  = 68 -> pp cp ismo search conf displacement; (D)
      ? a != 76 -> pp cp opcode byte;			(L)
      (ismo type is L, relative Label jump address)
      ? c <  65 -> pp cp opcode byte;			(A)
      ? c >  90 -> pp cp opcode byte;			(Z)
      (relative jump ismo valid)
      ? d != 52 -> pp cp opcode byte;			(rel/jmp only 4 bytes)
	b - 49; (opid - '1', B gives offset->op1 value) (1)
	d - 48; (opex - '0', D gives operand byte-size) (0)
	a = [b plus op1 value]; (load dest label address)
	c - 65 plus 13; 	(calc. adjustment offset)
	a - [bpos];		(make rel. to current ip)
	a - c;			(apply adjustment offset)
      ? [acc] - acc reverse jumps -> pp cp rj forward;
	a +-;
      "pp cp rj forward"
      ? [bea] - bea rel -> pp cp use small endian;
      "pp cp use big endian"
      (stream 4-byte big-endian)
	b = [pb offset];			(framer - start)
	a <@ 8;
	[byte] = a; [byte] & FFh; => cat byte;
	a <@ 8;
	[byte] = a; [byte] & FFh; => cat byte;
	a <@ 8;
	[byte] = a; [byte] & FFh; => cat byte;
	a <@ 8;
	[byte] = a; [byte] & FFh; => cat byte;
	[pb offset] = b;			(framer - end)
	[pb stream] = cpu pack; 		(framer - end)
	-> pp cp ismo;
      "pp cp use small endian"
      (stream 4-byte small-endian)
	b = [pb offset];			(framer - start)
	[byte] = a; [byte] & FFh; => cat byte;
	a > 8;
	[byte] = a; [byte] & FFh; => cat byte;
	a > 8;
	[byte] = a; [byte] & FFh; => cat byte;
	a > 8;
	[byte] = a; [byte] & FFh; => cat byte;
	[pb offset] = b;			(framer - end)
	[pb stream] = cpu pack; 		(framer - end)
	-> pp cp ismo;
      "pp cp ismo search conf displacement"
      (ismo type is D, Displacement)
      ? c != 46 -> pp cp opcode byte;			(.)
	b - 49; (opid - '1', B gives offset->op1 value) (1)
	d - 48; (opex - '0', D gives operand byte-size) (0)
	a = [b plus op1 value]; (load displacement)
	b = [bea];		(load BEA)
	a < 2;			(multiply by unit)
	b & bea dis;		(insulate BEA displacement)
	-> pp cp ismo values fill;
      "pp cp ismo search conf immediate"
      (ismo type is I, Immediate)
      ? c != 46 -> pp cp opcode byte;			(.)
	b - 49; (opid - '1', B gives offset->op1 value) (1)
	d - 48; (opex - '0', D gives operand byte-size) (0)
	a = [b plus op1 value]; (load displacement)
	b = [bea];		(load BEA)
	b & bea imm;		(insulate BEA immediate)
      "pp cp ismo values fill"
      (common to both immediates and displacements)
      ? d = 1 -> pp cp onebyte;
      ? b = zero
	  -> pp cp use small endian;	(b = zero)
	  -> pp cp use big endian;	(else...)
      "pp cp onebyte"
      (stream 1-byte immediate value)
	[byte] = a;
	a = [pb offset];			(framer - start)
	=> cat byte;
	[pb offset] = a;			(framer - end)
	[pb stream] = cpu pack; 		(framer - end)
      "pp cp ismo"
      (update ip considering true size of ismo operand)
	[pb offset] +;
	[bpos] + d;
	-> pp build code; (reload, past this ismo)
      "pp cp opcode byte"
      (update ip considering 1 opcode byte just passed)
	[bpos] +;
      (stream opcode byte)
	[byte] = a;
	a = [pb offset];			(framer - start)
	=> cat byte;
	[pb offset] = a;			(framer - end)
	[pb stream] = cpu pack; 		(framer - end)
      (roll back the read-ahead registers and continue)
	a = b;
	b = c;
	c = d;
	-> pp code pass loop;
      "pp loop stop"
      (register E is only used within pattern scanning/building loops)
	e = [esav];
      (see if you might add a CPU delay between an instruction and the next)
      ? [cpud] = null -> pp exit;
      ? [dlyd] = yes -> pp strobe;
	[dlyd] = yes;
	[inst plus 0] = hyphen;
	[inst plus 1] = hyphen;
	[inst plus 2] = hyphen;
	[inst plus 3] = null;
	[op1 class] = immediate;
	[op1 value] = [cpud];
	[op2 class] = null;
	-> pp common stack behavior;
      "pp strobe"
	[dlyd] = no;
      "pp exit"
      (the following two registers where generally used here)
	b = zero; (clean up parser flags holder)
	d = zero; (clean up parser comments nidification level)
	-> [pp return point];

    (programme parser error messages)
    "err extra operands to instruction"
	[err string] = msg extra operands to instruction;
	-> log syntax error;
    "err wrong usage of comparison directive"
	[err string] = msg wrong usage of comparison directive;
	-> log syntax error;

    (programme parser auxiliary routines)
    "cat byte"
      ? [bbss] < bcache size -> cb cache is not full yet;
	=> flush code cache;
      ? failed -> cb error;
      "cb cache is not full yet"
	[pb stream] = bins;
	[pb offset] = [bbss];
	[pb bvalue] = [byte];
	[pb bvalue] & FFh;
	[bbss] +;
	-> set progressive byte; (jump, replaces <call+leave>)
      "cb error"
	[err string] = msg could not stream code to application file;
	[cls string] = fser string;
	=> log error;
	$ + 1; (discard call to "cat byte")
	fail;  (it's a fatal error, fail parser)
    "flush code cache"
      ? [bbss] = zero -> fcc nothing to flush;
	[file command] = test;
	[file name] = applic name;
	isocall;
      ? ok -> fcc go write;
	fail;
      "fcc go write"
	[file command] = write;
	[file name] = applic name;
	[file position] = [file size];
	[block pointer] = bins;
	[block size] = [bbss];
	isocall;
      ? ok -> fcc nothing to flush;
	fail;
      "fcc nothing to flush"
	[bbss] = zero;
	end;

    (compiler's global auxiliary routines)

    "copy option"
    (copies a command line option from [target string], to buffer pointed by
     register B, for upto a number of characters, not including the string's
     null terminator, given by register D; end of option may be:
     - the beginning of another option ie. two hyphens,
     - any character codes below the blank space, including final null.
     note: the last stopper means options CAN include spaces within them,
     and that those spaces will be considered part of the argument's value.)
	 a = [target string];
	 a + 6;
      "copy option loop"
	 c = [a];
	 a +;
      ?  c <  blank  -> finished copying option;
      ?  c != hyphen -> keep copying option;
      ? [a] = hyphen -> finished copying option;
      "keep copying option"
	[b] = c;
	 b +;
	 d ^ copy option loop;
      "finished copying option"
	[b] = null;
	leave;

    "unpack"
    (unpacks a packed bitstream, typically built in the "variables" period
     using "make" tags; the packed stream address is passed as [up source],
     the unpacked data destination buffer is passed as [up target], and the
     number of values to unpack as [up length]; finally, [up bitspervalue]
     must be loaded with the number of bits forming a single value, as used
     in the stream's corresponding "make:..." tags, but please note that:
     - does not preserve any registers,
     - does not preserve [up length], it returns with [up length] zeroed,
     - does not preserve [up target], it increases it by [up length] units,
     - needs the "bits" library to work, and alters its input parameters)
	[bit stream pointer] = [up source];
	[starting bit number] = zero;
	[bit field size] = [up bitspervalue];
      "up unpack loop"
	=> get bit field;
	a = [up target];
	[starting bit number] + [up bitspervalue];
	[a] = [bit field content]; a +;
	[up target] = a;
	[up length] ^ up unpack loop;
	leave;

    "cat string"
    (concatenates [stst] string to actual initialized workspace, and updates
     [dpos] as the top of workspace; it does only this last thing if pass is
     not the data pass: this routine is typically called by variables parser
     in reply to a text string declaration, either labeled or not, within
     the variables period; [stst] is a character pointer within the actual
     source code file, measured from the beginning of the source code file.
     Ok, this routine isn't easy to understand, it manages its flow in such
     an unusual way, for optimization... as if it wasn't enough to parse the
     five \cr, \cs, \lf, \ta, \us tags, the routine can also, entered with a
     flag set in register B, <regb cs programname>, fill the <app name> area
     of the RTM initialization paragraph, which is what happens when the tag
     programname = { something } is found in the "directors" period; when it
     does so, remember to reset [pnbc] to zero before entering "cat string".)
	[tpos] -->;
	e      -->;
	c = [tpos];
	c - [sccs]; (c = current cache block's beginning in source file)
      ? [stst] >= c -> cs rewind;
      (string is outside current cache block)
	b | regb cs recache;
	e = 0; (empty cache, letting "read char" refill it)
	[tpos] = [stst]; (reposition cache block to read)
	-> cs loop;
      "cs rewind"
      (string is within currently loaded cache block: rewind current cache)
	b & FFFFFFFFh minus regb cs recache;
	d = [stst];
	d - c; (d = char position of string within actual cached block)
	e = [sccs];
	e - d; (e = cached bytes remaining = cache size - string position)
      "cs loop"
	=> read char;
      ? ok -> cs examine;
      "cs read error"
	$ + 3; (discard the call to "cat string" and 2 stacked units)
	-> err read error; (parser fatal error)
      "cs examine"
      ? c  < 033 -> cs loop; (disregard any text-formating codes below 33)
      ? c  > 126 -> cs loop; (disregard non-standard codes above ASCII 126)
      ? c  = 125 -> cs stop; (stop when you find a closing brace)
      ? c  = 095 -> cs space;	  (translate underscores to spaces)
      ? c != 092 -> cs character; (no backslash -> go stream normal character)
      (otherwise read the character that follows the backslash)
	=> read char;
      ? failed -> cs read error;
      (character following backslash is checked for tags control)
      ? c = 092 -> cs double backslash; (another backslash: stream only one)
      ? c = 099 -> cs lowercasec;	(lowercase "c" may be "\cr" or "\cs")
      ? c = 108 -> cs lowercasel;	(lowercase "l" may be "\lf")
      ? c = 116 -> cs lowercaset;	(lowercase "t" may be "\ta")
      ? c = 117 -> cs lowercaseu;	(lowercase "u" may be "\us")
      (what follows backslash is none of the above: save what it is in reg. D)
	d = c;
      (stream the backslash because it's not part of a tag)
	c = backslash;
	=> cs tag character;
      (and go back to examine the character which was following the backslash)
	c = d;
	-> cs examine;
      (case of "\c..." --- look for tags "\cr", "\cs")
      "cs lowercasec"
	=> read char;
      ? failed -> cs read error;
      (examine the character that's following "\c")
      ? c = 114 -> cs cr; (lowercase "r" marks "\cr")
      ? c = 115 -> cs cs; (lowercase "s" marks "\cs")
      (no "\cr" and no "\cs": preserve character following "\c" in register D)
	d = c;
      (stream the initial backslash)
	c = backslash;
	=> cs tag character;
      (stream the lowercase "c")
	c = 99;
	=> cs tag character;
      (go back to examine the character which was following "\c")
	c = d;
	-> cs examine;
      (case of "\cr": translate to ASCII code 13 - Carriage Return)
      "cs cr"
	c = 13;
	-> cs character;
      (case of "\cs": translate to ASCII code 125 - Closed String)
      "cs cs"
	c = 125;
	-> cs character;
      (case of "\l..." --- look for tag "\lf")
      "cs lowercasel"
	=> read char;
      ? failed -> cs read error;
      (examine the character that's following "\l")
      ? c = 102 -> cs lf; (lowercase "f" marks "\lf")
      (it's no "\lf": preserve character following "\l" in register D)
	d = c;
      (stream the initial backslash)
	c = backslash;
	=> cs tag character;
      (stream the lowercase "l")
	c = 108;
	=> cs tag character;
      (go back to examine the character which was following "\l")
	c = d;
	-> cs examine;
      (case of "\lf": translate to ASCII code 10 - Line Feed)
      "cs lf"
	c = 10;
	-> cs character;
      (case of "\t..." --- look for tag "\ta")
      "cs lowercaset"
	=> read char;
      ? failed -> cs read error;
      (examine the character that's following "\t")
      ? c = 97 -> cs ta; (lowercase "a" marks "\ta")
      (it's no "\ta": preserve character following "\t" in register D)
	d = c;
      (stream the initial backslash)
	c = backslash;
	=> cs tag character;
      (stream the lowercase "t")
	c = 116;
	=> cs tag character;
      (go back to examine the character which was following "\t")
	c = d;
	-> cs examine;
      (case of "\ta": translate to ASCII code 9 - TAbulation)
      "cs ta"
	c = tabulation;
	-> cs character;
      (case of "\u..." --- look for tag "\us")
      "cs lowercaseu"
	=> read char;
      ? failed -> cs read error;
      (examine the character that's following "\u")
      ? c = 115 -> cs us; (lowercase "s" marks "\us")
      (it's no "\us": preserve character following "\u" in register D)
	d = c;
      (stream the initial backslash)
	c = backslash;
	=> cs tag character;
      (stream the lowercase "u")
	c = 117;
	=> cs tag character;
      (go back to examine the character which was following "\u")
	c = d;
	-> cs examine;
      (case of "\us": translate to ASCII code 95 - UnderScore)
      "cs us"
	c = underscore;
	-> cs character;
      (was: case of "\\", which becomes a single backslash)
      "cs double backslash"
	c = backslash;
	-> cs character;
      (was: case of "_", which becomes an effective blank space)
      "cs space"
	c = 32;
       (-> cs character;) (of course no jump needed at this point)
      "cs character"
      ? b - regb cs programname -> cs stream character;
      (we're parsing the programname director tag: go fill "li app name")
	=> cs programname character;
	-> cs loop;
      (else we're parsing a normal text string in the "variables" period)
      "cs stream character"
	[dpos] + [make]; (account 1 unit for this character...)
      (...and in data pass, stream this character to the application's file)
      ? [pass] != data pass -> cs loop;
	[dval] = c;
	[cd stack waste] = 3; (2 stacked units, plus the call to "cat string")
	=> cat unit;
	-> cs loop;
      (here follows the label used when a "}" is found, marking end of string)
      "cs stop"
      ? b + regb cs programname -> cs stop ascii string;
      (stopping a 4b data string, cat a null unit as a terminator)
	[dpos] + [make];
      (...and in data pass, stream the null to the application's file)
      ? [pass] != data pass -> cs terminated;
	[dval] = null;
	[cd stack waste] = 3; (2 stacked units, plus the call to "cat string")
	=> cat unit;
	-> cs terminated;
      "cs stop ascii string"
      (while when stopping the ASCII string from programname, cat a null byte)
	[pb stream] = li app name;
	[pb offset] = [pnbc];
	[pb bvalue] = null;
	=> set progressive byte;
      "cs terminated"
      ? b - regb cs recache -> cs return;
      (need to recache - may happen for very long strings, otherwise rarely)
	<--	 e;
	<-- [tpos];
	[tpos] - e; (this sets "tpos" to point at next unread character)
	e = zero;   (now empty the cache, for "read char" to re-fill it up)
	leave;
      "cs return"
      (no need to recache, but still needs to reposition)
	<-- e;
	$ + 1;
	leave;

    (auxiliary subroutines for "cat string")
    "cs tag character"
      ? b + regb cs programname -> cs programname character;
	[dpos] + [make]; (account for new character...)
      (...but as always, stream it only in data pass...)
      ? [pass] != data pass -> cs tc done; (look a bit below: it'll return)
	[dval] = c;
	[cd stack waste] = 4; (=> cat string, 2 stacked units, => cs tag char)
	-> cat unit;
    "cs programname character"
      ? [pnbc] < 39 -> cs pc continue;
	[err string] = msg program name is longer than 39 characters;
	=> log warning;
	$ + 1; (discard the call to "cs programname character")
	-> cs stop; (stop parsing the string, no more room)
      "cs pc continue"
	[pb stream] = li app name;
	[pb offset] = [pnbc];
	[pb bvalue] = c;
	=> set progressive byte;
	[pnbc] +;
      "cs tc done"
	leave;

    "get symbol"
    (searchs 4b string [symbol name] within symbols' map: if found, returns
     corresponding [gs symbol record], as the pointer within "stab" array,
     and returns successfully, fails otherwise)
 ---->; b = 555555h; (base SID hash, low  unit)
	e = AAAAAAh; (base SID hash, high unit)
	b # [sh lo]; (local hashing, low  unit)
	e # [sh hi]; (local hashing, high unit)
	[gsgs] = no; (not globally searched yet)
      "gs global search"
	a = [symbol name];
	c = minus 8; (shifter)
      "gs sid loop"
	d = [a];
	a +;
      ? d = null -> gs sid done;
	d * 123;
	c + 8;
	d & FFh;
	c & 3Fh;
	b - d;
	e + d;
      ? c >= 32 -> gs xor sid high;
	d < c;
	e +;
	b # d;
	-> gs sid loop;
      "gs xor sid high"
	d < c;
	b +;
	e # d;
	-> gs sid loop;
      "gs sid done"
      (search SID into symbols table)
	a = stab;
	d = [nods];
      ? d = zero -> gs no actual symbols;
      "gs sid check"
      ? [a plus sidlo] != b -> gs sid passed;
      ? [a plus sidhi] = e -> gs sid found;
      "gs sid passed"
	a + symbol size;
	d ^ gs sid check;
      ? [gsgs] = yes -> gs no actual symbols;
	[gsgs] = yes;
	a = [sh lo];
	b = 555555h; (global SID hash, low  unit)
	a | [sh hi];
	e = AAAAAAh; (global SID hash, high unit)
      ? a != null -> gs global search;
      "gs no actual symbols"
 <----; fail;
      "gs sid found"
	[gs symbol record] = a;
 <----; end;

    "put symbol"
    (logs symbol, which name's null-terminated 4b string is pointed by reg A,
     into symbols map; fails - with a fatal error breaking the parser - if:
     - there's no more free symbol records, ie. if [nods] = max symbols;
     - there's already a symbol with that name and the parser is in pass 1;
     - name's invalid: is a register, contains tags, begins with digits 0-9.
     on success:
     - returns [ps symbol record] as a pointer to a new record within "stab";
     - fills the record's "sidlo" and "sidhi" fields with the Symbol ID hash.
     does not really report success and failure states, it quits with "leave",
     but it's only supposed to be called by a specific period parser, so it
     knows how to break the parser from here, and it does; in short, if it
     doesn't return, it failed - if it returns, it's alright.)
 ---->; [pshlo] = null;
	[pshhi] = null;
      ? [prid] <= stck -> ps SID hash selected;
	[source string] = a;
	[target string] = pfx shared;
	=> strpcmp;
      ? ok -> ps public;
	[pshlo] = [shlo];
	[pshhi] = [shhi];
	-> ps SID hash selected;
      "ps public"
	a + 6;
      "ps SID hash selected"
      (in pass 2 and laters, we know the symbols were all valid: this check,
       coupled with the same kind of check in "err symbol already declared",
       causes "put symbol" to return the existing symbol record in passes
       after pass 1, allowing period parsers to update suspended symbol data
       for all symbols that were depending on other symbols; of course the
       validity of a symbol's name is only checked in pass 1, when the symbol
       is supposed to be effectively added to the symbols map)
      ? [pass] > 1 -> ps valid;
      (preload first character of symbol name for a series of quick checks)
	b = [a];
      (see if it's void)
      ? b = null -> err void symbol name;
      (registering libraries' support symbols, skip all the rest of checks)
      ? [isfilename] = true -> ps valid;
      (see if it's a register's name)
      ? b > 101 -> ps no register name;
      ? b < 097 -> ps no register name;
      ? [a plus 1] = null -> err illegal symbol name;
      "ps no register name"
      (begins by a decimal digit?)
      ? b > 57 -> ps no initial digit;
      ? b > 47 -> err illegal symbol name;
      "ps no initial digit"
      (see if it contains any tags)
	[source string] = a;
	[target string] = ftpragm;
	=> strstr;
      ? ok -> err illegal symbol name;
	[target string] = ftxultiplied;
	=> strstr;
      ? ok -> err illegal symbol name;
	[target string] = ftxinus;
	=> strstr;
      ? ok -> err illegal symbol name;
	[target string] = ftxtp;
	=> strstr;
      ? ok -> err illegal symbol name;
	[target string] = ftxelating;
	=> strstr;
      ? ok -> err illegal symbol name;
	[target string] = ftxivided;
	=> strstr;
      ? ok -> err illegal symbol name;
	[target string] = ftxiv;
	=> strstr;
      ? ok -> err illegal symbol name;
	[target string] = ftxlus;
	=> strstr;
      ? ok -> err illegal symbol name;
	[target string] = ftxsbytesize;
	=> strstr;
      ? ok -> err illegal symbol name;
      (scan for any Non-Alphanumeric characters)
	b = a;
      "ps check NA chars"
	c = [b];
	b +;
      ? c = null -> ps valid;
      ? c < 048 -> err illegal symbol name;
      ? c > 122 -> err illegal symbol name;
      ? c > 096 -> ps check NA chars;
      ? c < 058 -> ps check NA chars;
	-> err illegal symbol name;
      "ps valid"
      (calculate SID hash)
	b = 555555h; (base SID hash, low  unit)
	e = AAAAAAh; (base SID hash, high unit)
	b # [pshlo]; (local hashing, low  unit)
	e # [pshhi]; (local hashing, high unit)
	c = minus 8; (shifter)
      "ps sid loop"
	d = [a];
	a +;
      ? d = null -> ps sid done;
	d * 123;
	c + 8;
	d & FFh;
	c & 3Fh;
	b - d;
	e + d;
      ? c >= 32 -> ps xor sid high;
	d < c;
	e +;
	b # d;
	-> ps sid loop;
      "ps xor sid high"
	d < c;
	b +;
	e # d;
	-> ps sid loop;
      "ps sid done"
      (got the SID - check if it's already registered:
       - it must *not* be already registered in pass 1;
       - it *must* be already registered in later passes.)
	a = stab;
	d = [nods];
      ? d = zero -> ps no actual symbols;
      ? d = max symbols -> err too many symbols;
      "ps sid check"
      ? [a plus sidlo] != b -> ps sid passed;
      ? [a plus sidhi] = e -> err symbol already declared;
      "ps sid passed"
	a + symbol size;
	d ^ ps sid check;
      "ps no actual symbols"
      (add symbol record, fill SID fields, return)
	[nods] +;
	[a plus sidlo] = b;
	[a plus sidhi] = e;
      "ps post pass one reentry"
      (reentry here after pass 1, from "err symbol already declared")
	[ps symbol record] = a;
 <----; leave;

    ("put symbol" error messages)
    "err void symbol name"
	[err string] = msg void symbol name;
	[cls string] = decl string;
	=> log error;
	<----; (restore registers saved by "put symbol")
	$ + 1; (discard call by parser to "put symbol")
	fail;  (fail parser)
    "err illegal symbol name"
	[err string] = msg illegal symbol name;
	[cls string] = decl string;
	=> log error;
	<----; (restore registers saved by "put symbol")
	$ + 1; (discard call by parser to "put symbol")
	fail;  (fail parser)
    "err too many symbols"
	[err string] = msg too many symbols;
	[cls string] = intr string;
	=> log error;
	<----; (restore registers saved by "put symbol")
	$ + 1; (discard call by parser to "put symbol")
	fail;  (fail parser)
    "err symbol already declared"
      ? [pass] > 1 -> ps post pass one reentry;
	[err string] = msg symbol already declared;
	[cls string] = decl string;
	=> log error;
	<----; (restore registers saved by "put symbol")
	$ + 1; (discard call by parser to "put symbol")
	fail;  (fail parser)

    "parse operand"
     (considers the linear expression pointed by register A on entry, and
      calculates the value of that operand basing on tags' interpretation,
      and/or classifies the expression as:
      - immediate value ....... [po class] = immediate;
      - direct address ........ [po class] = direct;
      - register .............. [po class] = register;
      - indirect address ...... [po class] = indirect.
      returns <[po error]=no> when expression is valid, <[po error]=yes> if:
      - the expression contains one or more illegal values;
      - the expression refers to one or more suspended symbols.
      returns the operand's type as [po class] - unpredictable on error,
      returns the operand's flags as [po flags] - unpredictable on error,
      returns the operand's value as [po value] - unpredictable on error,
      returns the operand's register as [po regid] - unchanged on error.
      [po float] signals presence of at least 1 f-p expression component,
      therefore if [po float] is returned as "yes", the expression's value
      held by [po value] must be considered and handled as a f-p number:
      [po float] may be asserted either if a floating-point value has been
      parsed by subroutine "po parse value", or if the value of a constant
      of f-p type has been found; finally, [po addrx] is returned if one of
      the symbols forming the expression is an address to an entity of the
      static data, ie. a variable's name or a workspace area label, and it
      will be checked upon registering constants for detecting the quite
      subtle, but unavoidable, "causal ring" error condition; for warnings
      check, [po flags] is the composite of all flags having been found in
      the symbols' flags of all the symbols appearing in the expression.)
 ---->; b = zero;	   (assume no values or modifiers found so far)
	d = null;	   (last tag found)
	e = zero;	   (characters parsed so far)
	[po class] = immediate; (assume this class until proven differently)
	[po flags] = null; (assume no flags, no registered symbols parsed yet)
	[po error] = no;   (assume there were no errors in values so far)
	[po value] = zero; (expression value so far)
	[po float] = no;   (assume it's no floating-point result, so far)
	[po addrx] = no;   (assume it's not formed by static data addresses)
	[po inman] = no;   (assume it has not been processing mantissa part)
	[po inexp] = no;   (assume it's not actually processing exponent part)
	[po brkts] = zero; (will have to be zero: brackets' accumulator)
	[po pragm] = no;   (pragma flag: now no, but it'll check immediately)
      (check for "pragma" prefix)
	[source string] = a;
	[target string] = tgpragm;
	=> strpcmp;
      ? failed -> po again;
	[po pragm] = yes;
	a + 6;
      "po again"
      (preload next character for quick checks, advance pointer)
	c = [a];
	a +;
      (quit if at end of expression string)
      ? c = null -> po done;
      (opening bracket?)
      ? c != open bracket -> po no open bracket;
      (if yes, only at the beginning of the string: also don't count the
       opening bracket as part of the expression string's parsed chars,
       that is, skip incrementing register E. the fact that the bracket
       has been found will be marked by [po brkts] anyway, and E serves
       in later checks to see how many effective chars have passed)
      ? e != zero -> err expression syntax error;
      ? [po brkts] != zero -> err expression syntax error; (1 bracket pls)
	[po class] = direct;
	[po brkts] +;
	-> po again;
      "po no open bracket"
      (closing bracket?)
      ? c != close bracket -> po no close bracket;
      (if yes, only at the end of the string: next char must be null)
      ? [a] != null -> err expression syntax error;
      ? [po brkts] = zero -> err expression syntax error; (not opened)
	-> po done;
      "po no close bracket"
      (check a... tags)
      ? c != 97 -> po no lowercase a;
	[source string] = a;
	[target string] = tgxsbytesize;
	=> strpcmp;
      ? ok -> po ptgxsbytesize;
      "po no lowercase a"
      (check m... tags)
      ? c != 109 -> po no lowercase m;
	[source string] = a;
	[target string] = tgxultiplied;
	=> strpcmp;
      ? ok -> po ptgxultiplied;
	[target string] = tgxinus;
	=> strpcmp;
      ? ok -> po ptgxinus;
	[target string] = tgxtp;
	=> strpcmp;
      ? ok -> po ptgxtp;
      "po no lowercase m"
      (check r... tags)
      ? c != 114 -> po no lowercase r;
	[source string] = a;
	[target string] = tgxelating;
	=> strpcmp;
      ? ok -> po ptgxelating;
      "po no lowercase r"
      (check d... tags)
      ? c != 100 -> po no lowercase d;
	[source string] = a;
	[target string] = tgxivided;
	=> strpcmp;
      ? ok -> po ptgxivided;
	[target string] = tgxiv;
	=> strpcmp;
      ? ok -> po ptgxiv;
      "po no lowercase d"
      (check p... tags)
      ? c != 112 -> po break tag match;
	[source string] = a;
	[target string] = tgxlus;
	=> strpcmp;
      ? ok -> po ptgxlus;
      "po break tag match"
      (no tags here, it's just a character, supposedly part of a value)
      ? b + regb mod val -> po no value start marker;
	b | regb mod val;
	[po start] = a;
	[po start] -;
      "po no value start marker"
	e +;
	-> po again;
      "po done"
      (end of expression: a value must NOT be there if the "as byte size"
       modifier was used, which is often supposed to be the last tag)
      ? b - regb mod abs -> po check eos;
      ? b + regb mod val -> err expression syntax error;
	-> po break;
      "po check eos"
      (end of expression: a value MUST be there as the very last part of
       the expression string, otherwise it's of course a syntax error)
      ? b - regb mod val -> err expression syntax error;
	=> po parse value;
      "po break"
 <----; leave;

     "po ptgxsbytesize"
      ? b - regb mod val -> po ptg j1;
	=> po parse value;
      (all tags except plus and minus are invalid after e-terminated mantissa,
       because the eventual "plus" or "minus" following such f-p values would
       be supposed to be the sign of the exponent: *BUT* this check could be
       safely done only after the first pass, when the compiler already knows
       for sure all declared symbols' names, else it may believe an unknown
       symbol whose name ends with an "e", to be an e-terminated mantissa of a
       floating-point value, which would at this precise point stop compiling
       on pass 1, without giving the compiler a chance to meet that future
       symbol ending by an "e"; this bug was found by Peterpaul using 2 files:

	in the first file:

	"constants"
	  UNITSINLINE = CHRSINLINE div BYTESPERUNIT;

	in the second file, including the first as a library, the CHRSINLINE
	was defined - ergo the first file was an "integration library", so:

	"constants"
	  CHRSINLINE = 256;

	the L.in.oleum compiler is officially supposed to resolve any kinds
	of forward references like that [with the exception of causal rings],
	but here [and in similar tags which wouldn't be allowed to be placed
	after an e-terminated floating point value], due to the lack of the
	comparison directive "? [pass] = 1 -> po ptg j1;", when the compiler
	met "CHRSINLINE div BYTESPERUNIT" on pass 1, it wasn't knowing [yet]
	that a symbol called CHRSINLINE would have been declared in that 2nd
	file which would have been parsed later... SO, in the end the "parse
	value" routine was not finding any symbols called CHRSINLINE, but it
	was noticing the value ended by "E" [uppercase, or lowercase, is the
	same, you know], and supposing it might have been some floating-point
	number given in the <mantissa+e+exponent> scientific format: at that
	point, this routine here was EXPECTING the exponent to follow, and of
	course it was complaining because it believed the tag "div" to have
	been used after an e-terminated floating-point value, it was like if
	the compiler saw the expression as:

	  UNITSINLINE = 1.2345e div BYTESPERUNIT;

	while, if the value would have to be a legal floating-point number,
	it should have been:

	  UNITSINLINE = 1.2345e [plus|minus] BYTESPERUNIT;

	...that is, it was expecting a plus or minus to follow as the sign of
	what it believed to be the exponent... phew, hope it explained that.)
      ? [pass] = 1 -> po ptg j1;
      ? [po inman] = yes -> err expression syntax error;
      "po ptg j1"
      ("as byte size" is strictly for integers)
      ? [po float] = yes -> err value is not integer;
      (update the actual operand value to round its bytes-to-units conversion)
	c = [po value];
	[po value] >> 2;
      ? c - 3 -> po dont bytesize;
	[po value] +;
      "po dont bytesize"
      (can't stay at the beginning of an expression)
      ? e = zero -> err expression syntax error;
      (can't be directly preceeded by another tag)
      ? d != null -> err expression syntax error;
      (can't be preceeded by a register's name)
      ? e != 1 -> po ptgxsbytesize accept;
      ? [a minus 2] < 97 -> po ptgxsbytesize accept;
      ? [a minus 2] > 101 -> po ptgxsbytesize accept;
	-> err expression syntax error;
      "po ptgxsbytesize accept"
	a + 9;
	d = tgxsbytesize;
	e + 10;
	b | regb mod abs;
	-> po again;

    "po ptgxultiplied"
      (resolve <-multiplie div[ided]> = <multiplied iv[ided]> conflicts)
	[source string] + 9; (point to character after >d in multiplie>d)
	[target string] = tgxiv; (compare with -iv)
	=> strpcmp;
      ? ok -> po break tag match;
      (parse an eventual value found before this tag)
      ? b - regb mod val -> po ptg j2;
	=> po parse value;
      (all tags except plus and minus are invalid after e-terminated mantissa)
      ? [pass] = 1 -> po ptg j2;
      ? [po inman] = yes -> err expression syntax error;
      "po ptg j2"
      (can't stay at the beginning of an expression)
      ? e = zero -> err expression syntax error;
      (can't be directly preceeded by another tag)
      ? d != null -> err expression syntax error;
      (can't be preceeded by a register's name)
      ? e != 1 -> po ptgxultiplied accept;
      ? [a minus 2] < 97 -> po ptgxultiplied accept;
      ? [a minus 2] > 101 -> po ptgxultiplied accept;
	-> err expression syntax error;
      "po ptgxultiplied accept"
	a + 9;
	d = tgxultiplied;
	e + 10;
	b | regb mod xtp;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;

    "po ptgxinus"
      (parse an eventual value found before this tag)
      ? b - regb mod val -> po ptg j3;
	=> po parse value;
      "po ptg j3"
      (no tags can follow "relating", ie "relating minus" is an error)
      ? d = tgxelating -> err expression syntax error;
      ("minus minus" is accepted: will become "plus")
      ? d = tgxinus -> po ptgxinusxinus;
      (accept and register as "minus" the rest of combinations:
       - multiplied minus
       - mtp minus
       - divided minus
       - div minus
       - plus minus)
	a + 4;
	d = tgxinus;
	e + 5;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;
      "po ptgxinusxinus"
	a + 4;
	d = tgxlus;
	e + 5;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;

    "po ptgxtp"
      (resolve <-mt plus> = <mtp lus> conflicts)
	[source string] + 2; (point to character after >p in multiplie>p)
	[target string] = tgxlus; (compare with -lus)
	=> strpcmp;
      ? ok -> po break tag match;
      (parse an eventual value found before this tag)
      ? b - regb mod val -> po ptg j4;
	=> po parse value;
      (all tags except plus and minus are invalid after e-terminated mantissa)
      ? [pass] = 1 -> po ptg j4;
      ? [po inman] = yes -> err expression syntax error;
      "po ptg j4"
      (can't stay at the beginning of an expression)
      ? e = zero -> err expression syntax error;
      (can't be directly preceeded by another tag)
      ? d != null -> err expression syntax error;
      (can't be preceeded by a register's name)
      ? e != 1 -> po ptgxtp accept;
      ? [a minus 2] < 97 -> po ptgxtp accept;
      ? [a minus 2] > 101 -> po ptgxtp accept;
	-> err expression syntax error;
      "po ptgxtp accept"
	a + 2;
	d = tgxtp;
	e + 3;
	b | regb mod xtp;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;

    "po ptgxelating"
      (parse an eventual value found before this tag)
      ? b - regb mod val -> po ptg j5;
	=> po parse value;
      (all tags except plus and minus are invalid after e-terminated mantissa)
      ? [pass] = 1 -> po ptg j5;
      ? [po inman] = yes -> err expression syntax error;
      "po ptg j5"
      ("relating" is a synonym of "plus" but with tighter syntax constrictions
       so that it can't be placed at the beginning of an expression)
      ? e = zero -> err expression syntax error;
      (and can't be directly preceeded by another tag: furthermore it can't be
      followed by other tags, but that's checked in other tag's interpreters)
      ? d != null -> err expression syntax error;
      (because "relating" ideally expresses the relationship between the index
       and/or register that preceeds this tag, and the vector that follows it:
       oh, and it can't be used in periods other than "programme", where such
       indirect addressings can effectively take place)
	a + 7;
	d = tgxelating;
	e + 8;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;

    "po ptgxivided"
      (parse an eventual value found before this tag)
      ? b - regb mod val -> po ptg j6;
	=> po parse value;
      (all tags except plus and minus are invalid after e-terminated mantissa)
      ? [pass] = 1 -> po ptg j6;
      ? [po inman] = yes -> err expression syntax error;
      "po ptg j6"
      (can't stay at the beginning of an expression)
      ? e = zero -> err expression syntax error;
      (can't be directly preceeded by another tag)
      ? d != null -> err expression syntax error;
      (can't be preceeded by a register's name)
      ? e != 1 -> po ptgxivided accept;
      ? [a minus 2] < 97 -> po ptgxivided accept;
      ? [a minus 2] > 101 -> po ptgxivided accept;
	-> err expression syntax error;
      "po ptgxivided accept"
	a + 6;
	d = tgxivided;
	e + 7;
	b | regb mod xiv;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;

    "po ptgxiv"
      (parse an eventual value found before this tag)
      ? b - regb mod val -> po ptg j7;
	=> po parse value;
      (all tags except plus and minus are invalid after e-terminated mantissa)
      ? [pass] = 1 -> po ptg j7;
      ? [po inman] = yes -> err expression syntax error;
      "po ptg j7"
      (can't stay at the beginning of an expression)
      ? e = zero -> err expression syntax error;
      (can't be directly preceeded by another tag)
      ? d != null -> err expression syntax error;
      (can't be preceeded by a register's name)
      ? e != 1 -> po ptgxiv accept;
      ? [a minus 2] < 97 -> po ptgxiv accept;
      ? [a minus 2] > 101 -> po ptgxiv accept;
	-> err expression syntax error;
      "po ptgxiv accept"
	a + 2;
	d = tgxiv;
	e + 3;
	b | regb mod xiv;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;

    "po ptgxlus"
      (parse an eventual value found before this tag)
      ? b - regb mod val -> po ptg j8;
	=> po parse value;
      "po ptg j8"
      (no tags can follow "relating", ie "relating plus" is an error)
      ? d = tgxelating -> err expression syntax error;
      ("minus plus" is accepted, but becomes a simple "minus")
      ? d = tgxinus -> po ptgxinusxlus;
      (accept and register as "plus" the rest of combinations:
       - multiplied plus
       - mtp plus
       - divided plus
       - div plus
       - plus plus)
	a + 3;
	d = tgxlus;
	e + 4;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;
      "po ptgxinusxlus"
	a + 3;
	d = tgxinus;
	e + 4;
	b & FFFFFFFFh minus regb mod abs;
	-> po again;

    (error messages concerning "parse operand":
     never fatal, but they invalidate the operand's expression)
    "err expression syntax error"
	[err string] = msg expression syntax error;
	[cls string] = synt string;
	=> log error;
	[po error] = yes; (nullify this expression)
	-> po break;
    "err value is not integer"
	[err string] = msg value is not integer;
	[cls string] = synt string;
	=> log error;
	[po error] = yes; (nullify this expression)
	-> po break;

    "po parse value"
    (parses a single value found in the expression being parsed by the above
     "parse operand" routine: such a value is anything that stays between two
     tags, or between the beginning and the end of the whole expression, or
     between the last found tag and the end of the expression: this subroutine
     is called either when a tag is found, or at the end of the expression,
     and it's entered with register A pointing to the character after the one
     that terminated the value; [po start] instead gives the pointer to the
     very first character of the value. on output:
     - [po value] gives the value of the string from [po start] to A-2;
     - [po error] is asserted if value is illegal or suspended;
     - [po regid] is updated if value is a register but only if reg=1st value;
     - [po class] is updated if value is a register and expression bracketed;
     - [po flags] is updated by an OR with symbol flags if value is a symbol;
     - [po addrx] is asserted if value is the pointer to a static data symbol;
     - [po float] is updated and asserted if value is f-p const. or immediate;
     - [po inman] is asserted after parsing mantissa of an f-p man+exp value;
     - [po inexp] in handled exclusively internally but must be zero on entry;
     - syntax errors in values are streamed to errors log when necessary;
     - registers B and D from "parse operand" are reset to null;
     - [pv value] gives the value of the string from [po start] to A-2, but in
       case of suspended symbols or of syntax errors in the said string, it is
       conventionally assigned to either integer 1 or to 1.0f, depending on
       the state of the [po float] flag, to avoid fake division by zero errs.
     note: syntax errors for undeclared symbols are only outputted in passes
     after the first pass; the first pass in supposed to at least take note of
     all the declared symbols' names, so such errors become true only later.)
 ---->; c = [po start]; (point C to the first character of the value)
	a - 2; (for later checks, point A to the last character of the value)
	c = [c]; (load up first character for the following check)
      (be quick: anything beginning by a decimal digit OR by a dot must be an
       immediate value - dot is of course used in f-p values like ".25f"...)
      ? c > 57 -> po pv may not be immediate; (above "9")
      ? c = 46 -> po pv surely immediate;     (equal ".")
      ? c > 47 -> po pv surely immediate;     (above "/", that is "0" or more)
      "po pv may not be immediate"
      (another quick check that must be done now to acknowledge registers)
      ? a > [po start] -> po pv no register; (value has more than 1 character)
      ? [a] > 101 -> po pv no register; (the only char is above lowercase "e")
      ? [a] < 097 -> po pv no register; (the only char is below lowercase "a")
      (registers may appear in expressions, but only as the first value of the
       expression: complain if it's not so, knowing that register E still has
       the number of characters parsed so far in the whole expression)
      ? e > 1 -> err misplaced register in indirection;
	[po class] = register;
	[po regid] = [a];
	[po regid] - 97;
      ? [po brkts] = zero -> po pv return;
	[po class] = indirect;
	-> po pv return;
      "po pv no register"
      (ok, so it's no register: check if the programmer wrote something after
       a register which is not used in indirections; registers alone mean the
       register's value, and cannot be coupled to anything else, unless there
       were brackets around, in which case it's an indirection)
      ? [po class] = register -> err extra input after standalone register;
      (after that check, see if the whole value is the name of a known symbol:
       to do so it needs temporarly transforming the expression's part that
       contains this value, in a null-terminated string, then feed the string
       to the "get symbol" routine; if "get symbol" returns successfully, of
       course it means the value is a known symbol, and the symbol's actual
       value will be returned by this subroutine...)
	c = [a plus 1]; (save)
	[a plus 1] = null; (terminate value string)
	[symbol name] = [po start];
	=> get symbol;
      ? failed -> po pv immediate;
	[a plus 1] = c; (restore on "get symbol" success)
      (it's a known symbol: return its value)
	a = [gs symbol record];
	[po flags] | [a plus flags]; (update overall expression flags)
	[pv modif] = b; (preserve modifiers and flags from "parse operand")
	b = [a plus value];
      ? [a plus flags] - static -> po pv not an address;
	[po addrx] = yes;
      "po pv not an address"
      ? [a plus flags] - suspended -> po pv not suspended;
	[po error] = yes;
	[pv value] = 1d; (dummy value: not zero to avoid divisions by zero)
      ? [po float] = no -> po pv done;
	[pv value] = IEEE1; (dummy value: not zero to avoid divisions by zero)
	-> po pv done;
      "po pv not suspended"
      ? [a plus flags] - fp -> po pv int success; (no fp flag: integer)
	-> po pv fp success; (else: floating-point)
      "po pv immediate"
	[a plus 1] = c; (restore on "get symbol" failure)
      "po pv surely immediate"
      (it's either an unknown symbol, or an immediate value ie a pure number:
       pure numbers may be marked by a final classification letter, as in the
       following checks...)
	[pv modif] = b; (preserve modifiers and flags from "parse operand")
	b = [a];
      ? b = 098 -> po pv binary;      (lowercase b at end of value)
      ? b = 104 -> po pv hexadecimal; (lowercase h at end of value)
      ? b = 102 -> po pv float;       (lowercase f at end of value)
      ? b = 101 -> po pv mantissa;    (mantissa, e at end of value)
      ? b = 100 -> po pv decimal;     (lowercase d at end of value)
      (no classification letter: well, assume decimal, don't mind calling the
       existing "atoui" like in the "d" case, this is one of the most frequent
       cases of immediate value, so you might parse it quick... even because
       this loop will have to realize, as soon as possible, if the string may
       be a decimal number or it's just a symbol that in pass 1 we don't know)
	c = a; (mark last string character's pointer)
	a = [po start]; (rewind to beginning of value's string)
	b = zero; (zero integer value accumulator)
      "po pv noclass decimal again"
	e = [a];
      ? e > 57 -> po pv error; (above "9")
      ? e < 48 -> po pv error; (below "0")
	e - 48; (convert "0" -> 0 .. "9" -> 9)
	b '* 10; (multiply accumulator to shift it 1 dec. digit left)
	a +; (increase pointer - do it here for possible pairability)
	b + e; (add digit to accumulator)
      ? a <= c -> po pv noclass decimal again; (loop for whole string)
      "po pv int success"
      (when getting here, conversion subroutine succeeded and the value is of
       integer type: b-binaries, d-decimals and h-hexadecimals will come here)
	[pv value] = b; (assume it's an integer operand: most frequent case)
      ? [po float] = no -> po pv done;
	[pv value] ,= b; (think back only if it's part of a f-p operand)
	-> po pv done;
      "po pv fp success"
      (here, conversion subroutine succeeded and the value is floating-point
       type - this actually happens with f-floats, or if the symbol that was
       found by "get symbol" was already registered as floating-point type)
	[pv value] = b;
      "po pv fp success after exponent"
      ? [po float] = yes -> po pv done;
	[po value] ,= [po value];
	[po float] = yes;
	-> po pv done;
      "po pv error"
      (this is the above subroutines' rendezvous point in case of error: but,
       at this point, the fact that it's a true error depends on the actual
       pass number, because in pass 1 there's supposed to be symbols that the
       parser didn't meet yet; so if it's pass 1, disregard the error)
	[po error] = yes;
	[pv value] = 1d; (dummy value: not zero to avoid divisions by zero)
      ? [po float] = no -> po pv error integer;
	[po float] = no; (floating-point illegals may be symbols ending by
			  an "e" or an "f" letter: to avoid non-existing
			  errors involving such problems that would be
			  acknowledged as floating-point, as for the error
			  message "value is not integer", simply assume the
			  value is integer on error)
      "po pv error integer"
      ? [pass] > 1 -> err undeclared symbol or illegal immediate value;
      (in any cases, successful or failed, a single error such as an illegal
       value or an undeclared symbol, doesn't break compilation: [po error]
       reports that an error has happened but for the rest, "parse operand"
       and "parse value" have to go on to signal other such possible errors
       in later points of the expression or of the source code)
      "po pv done"
      ? [po float] = no -> po pv update integer;
      (if it's been processing the mantissa part of a floating-point value
       which is divided in mantissa and exponent, the actual [pv value] is
       incomplete, and it's not to be used for updating [po value]: in this
       case [po value] will get updated when also the exponent part has been
       parsed and [pv value] updated by its exponent)
      ? [po inman] = yes -> po pv return;
      (if it's been, instead, processing the exponent part of such a value,
       remember that the effective tag and modifier placed in front of the
       value has gone, possibly overwritten by the sign of the exponent)
      ? [po inexp] = no -> po pv update;
	[po inexp] = no; (clear this, for later values of same expression)
	[pv modif] = [pv prmod];
	d = [pv prtag];
      "po pv update"
      (update [po value] by [pv value], as floating point)
      ? d != tgxinus -> po pv positive;
	[pv value] ++--;
      "po pv positive"
      ? [pv modif] - regb mod xtp -> po pv dont multiply;
	[po value] ** [pv value];
	-> po pv return;
      "po pv dont multiply"
      ? [pv modif] - regb mod xiv -> po pv dont xivide;
     ?? [pv value] = IEEE0 -> err xivision by zero in linear expression;
	[po value] // [pv value];
	-> po pv return;
      "po pv dont xivide"
	[po value] ++ [pv value];
	-> po pv return;
      "po pv update integer"
      (update [po value] by [pv value], as integer)
      ? d != tgxinus -> po pv positive integer;
	[pv value] +-;
      "po pv positive integer"
      ? [pv modif] - regb mod xtp -> po pv dont multiply integer;
	[po value] * [pv value];
	-> po pv return;
      "po pv dont multiply integer"
      ? [pv modif] - regb mod xiv -> po pv dont xivide integer;
      ? [pv value] = zero -> err xivision by zero in linear expression;
	[po value] / [pv value];
	-> po pv return;
      "po pv dont xivide integer"
	[po value] + [pv value];
      "po pv return"
      (finished processing value)
 <----; b = zero; (reset: no more values or modifiers found so far)
	d = null; (reset: no previous tags)
	leave;

    "po pv binary"
	? a = [po start] -> po pv error; (classification letter without value)
	b = zero; (integer value accumulator)
	c = 1; (bit to add)
      "po pv binary again"
	a -; (start from the letter before the "b")
      ? a < [po start] -> po pv int success; (end)
      ? [a]  = 48 -> po pv binary zero; (it's a "0")
      ? [a] != 49 -> po pv error; (not "0" and not "1")
	b + c; (add bit to accumulator)
      "po pv binary zero"
	c < 1; (raise bit's significance)
	-> po pv binary again;

    "po pv hexadecimal"
	? a = [po start] -> po pv error; (classification letter without value)
	b = zero; (integer value accumulator)
	c = zero; (nybble-shifter)
      "po pv hexadecimal again"
	a -; (start from the letter before the "h")
      ? a < [po start] -> po pv int success; (end)
	e = [a]; (preload)
      ? e > 102 -> po pv error; (above "f")
      ? e < 048 -> po pv error; (below "0")
      ? e < 058 -> po pv hexadecimal digit;
      ? e < 097 -> po pv error; (below "a")
	e - 87; ("a" -> 10)
	-> po pv hexadecimal add;
      "po pv hexadecimal digit"
	e - 48; ("0" -> 0)
      "po pv hexadecimal add"
	e < c; (position determines weight: 4 bits at a time)
	c + 4; (raise significance by 4 bits, for next digit)
	b + e; (add hex digit to accumulator)
	-> po pv hexadecimal again;

    "po pv mantissa"
	? a = [po start] -> po pv error; (classification letter without value)
    (value was terminated by "e", for exponent, take note of this fact, and
     begin processing this e-terminated value which should be the mantissa)
	[pv prtag] = d;
	[pv prmod] = [pv modif];
	[po inman] = yes;
	-> po pv float start;
    "po pv float"
	? a = [po start] -> po pv error; (classification letter without value)
    (value was terminated by "f", ending the whole floating-point value, and
     so see if an e-terminated value was found before: if it was, reset the
     flag [po inman] which was claiming that this routine was to convert the
     mantissa, and turn on the [po inexp] flag, which claims it's now called
     to process the exponent part)
      ? [po inman] = no -> po pv float start;
	[po inman] = no;
	[po inexp] = yes;
    "po pv float start"
	[pv point] = no; (flag: no point found so far)
	b = IEEE0; (f-p value accumulator)
	c = IEEE1; (f-p value factor)
      "po pv float again"
	a -; (start from the letter before the "e" or "f" letter)
      ? a < [po start] -> po pv float return; (end)
	e = [a]; (preload)
      ? e = 101 -> po pv emexp; (equal "e")
      ? e > 057 -> po pv error; (above "9")
      ? e = 046 -> po pv point; (equal ".")
      ? e < 048 -> po pv error; (below "0")
	e - 48; ("0" -> 0)
	e ,= e; (convert)
	e ** c; (position determines factor)
	c ** IEEE10; (raise significance by a factor of 10, for next digit)
	b ++ e; (add f-p digit to accumulator)
	-> po pv float again;
      "po pv point"
      (found the decimal point)
      ? [po inexp] = yes -> po pv error; (no, no decimal points in exponents)
      ? [pv point] = yes -> po pv error; (uhm, I need only one point, thanks)
	[pv point] = yes; (remember that you've found a point)
	b // c; (convert the actual accumulator to represent the decimal part)
	c = IEEE1; (reset factor, restart counting in integer units)
	-> po pv float again;
      "po pv emexp"
      (found an EMbedded EXPonent: a lowercase "e" in an f-terminated value)
      ? [pv point] = yes -> po pv error; (no, no decimal points in exponents)
      ? c = IEEE1 -> po pv error; (well, something might be there after the "e")
      ? a = [po start] -> po pv error; (and to be picky, also before the "e")
      (well, so in practice, in the case of an embedded exponent, what you've
       parsed so far WAS the exponent, and now you have to still parse the
       mantissa: it's better and faster to have another parse loop behaving
       slightly differently, than messing up the flow of the above loop; oh,
       and an "embedded exponent", if the above comment didn't explain it
       clearly, is what you have in e.g. "1e9f", which means 1000000000, and
       where there's no tags, like plus and minus, separating the exponent,
       which is 9, from the mantissa, which is 1)
	[pv value] = b; (store, for later use: it's the exponent)
	b = IEEE0; (reset: f-p value accumulator)
	c = IEEE1; (reset: f-p value factor)
      "po pv man again"
	a -; (start from the letter before the embedded "e" letter)
      ? a < [po start] -> po pv man return; (end)
	e = [a]; (preload)
      ? e = 101 -> po pv error; (another "e"? what for?)
      ? e > 057 -> po pv error; (above "9")
      ? e = 046 -> po pv man point; (equal ".")
      ? e < 048 -> po pv error; (below "0")
	e - 48; ("0" -> 0)
	e ,= e; (convert)
	e ** c; (position determines factor)
	c ** IEEE10; (raise significance by a factor of 10, for next digit)
	b ++ e; (add f-p digit to accumulator)
	-> po pv man again;
      "po pv man point"
      (found the decimal point in the mantissa loop)
      ? [pv point] = yes -> po pv error; (uhm, I need only one point, thanks)
	[pv point] = yes; (remember that you've found a point)
	b // c; (convert the actual accumulator to represent the decimal part)
	c = IEEE1; (reset factor, restart counting in integer units)
	-> po pv man again;
      "po pv man return"
      (end of mantissa loop for embedded exponents:
	reg. B holds the mantissa;
	[pv value] holds the exponent.
       but for the rest of the subroutine below, it must be exactly the
       contrary, so exchange them and go calculate [pv value] *= 10^b...)
	b <> [pv value];
      (must repeat some of the following steps now: embedded exponents are
       implicitly positive 'cos the fact that they were "embedded" precisely
       means that the expression's parser, "parse operand", didn't find tags
       between the "f" terminating the floating-point value and the "e" that
       marks the beginning of the embedded exponent; so, since "minus" for a
       negative exponent *would* be a tag, the exponent is assumed positive;
       however the code below "po pv float return", apart from checking for
       zero exponents, also checks register D indicating the last found tag,
       expecting it to be the sign of the exponent, but that's incorrect for
       embedded exponents [D is in fact the sign of the whole value], so the
       repeated steps concern all the checks made by "po pv float return",
       except that check on register D...)
	c =, b; (convert reg. B holding exponent, to integer, give to reg. C)
      ? c = zero -> po pv fp success after exponent; (exponent zero -> as is)
	-> po pv fr positive exponent; (assume positive, jump to common code)
      "po pv float return"
      (end of loop after either parsing a stand-alone exponent, such as in
       value "1 E minus 2f", which by the way is meaning the same as 0.01f,
       or parsing a simple mantissa without exponent, as in "1.25f", or even
       parsing the mantissa part when the exponent is not embedded)
      ? [po inexp] = no -> po pv fp success; (not been parsing an exponent)
	c =, b; (convert reg. B holding exponent, to integer, give to reg. C)
      ? c = zero -> po pv fp success after exponent; (exponent zero -> as is)
      ? d != tgxinus -> po pv fr positive exponent; (latest tag = exp.'s sign)
      (exponent is negative, will repeately multiply <value> by 0.1)
      "po pv fr negative exponent"
	[pv value] ** IEEE01;
	c ^ po pv fr negative exponent;
	-> po pv fp success after exponent;
      "po pv fr positive exponent"
      (exponent is positive, will repeately multiply <value> by 10)
	[pv value] ** IEEE10;
	c ^ po pv fr positive exponent;
	-> po pv fp success after exponent;

    "po pv decimal"
	? a = [po start] -> po pv error; (classification letter without value)
	[a] = null; (remove final "d")
	[source string] = [po start];
	=> atoui;
      ? failed -> po pv atoui error;
	[a] = 100; (restore final "d" on success)
	b = [string binary]; (return the value)
	-> po pv int success;
      "po pv atoui error"
	[a] = 100; (restore final "d" on failure)
	-> po pv error;

    (error messages concerning "po parse value")
    "err misplaced register in indirection"
	[err string] = msg misplaced register in indirection;
	[cls string] = synt string;
	=> log error;
	-> po pv error;
    "err extra input after standalone register"
	[err string] = msg extra input after standalone register;
	[cls string] = synt string;
	=> log error;
	-> po pv error;
    "err undeclared symbol or illegal immediate value"
	[err string] = msg undeclared symbol or illegal immediate value;
	[cls string] = synt string;
	=> log error;
	[po error] = yes;
	-> po pv done;
    "err xivision by zero in linear expression"
	[err string] = msg xivision by zero in linear expression;
	[cls string] = decl string;
	=> log error;
	[po error] = yes;
	-> po pv return;

    "log error"
    (logs ASCII error message specified by [err string], of type [cls string],
     appending the message to the "errorlog.txt" file in ASCII format)
	[source string] = [err string];
	[target string] = log revert;
	=> atofb;
	[target string] = line number;
	[string binary] = [flns];
	[string binary] +;
	=> uitoa;
	[source string] = file string;
	[target string] = log output;
	=> strcpy;
	[source string] = [levl];
	[source string] < 10;
	[source string] + main;
	=> strcat;
	[source string] = junc string;
	=> strcat;
	[source string] = line string;
	=> strcat;
	[source string] = line number;
	=> strcat;
	[source string] = [cls string];
	=> strcat;
	[source string] = log revert;
	=> strcat;
	[source string] = log output;
	=> strlen;
	[target string] = log output;
	=> fbtoa;
	[filecommand]  = write;
	[filename]     = errlog name;
	[fileposition] = [errlog fpos];
	[blockpointer] = [target string];
	[blocksize]    = [string length];
	isocall;
	[errlog fpos]  + [blocksize];
      ? [cls string] = warn string -> it was some kind of warning;
	[errs] +;
      "it was some kind of warning"
	leave;

    "log symbol"
    (logs a 4b string specified by [sym string], of type [cls string],
     echoing the value that's associated to the symbol as [sym value],
     appending the message to the "smblsmap.txt" file in ASCII format)
      ? [smap] = off -> ls off; (providing symbols map is required)
	[target string] = line number;
	[string binary] = [flns];
	[string binary] +;
	=> uitoa;
	[target string] = symbol value;
	[string binary] = [sym value];
	=> uitoa;
	[source string] = file string;
	[target string] = log output;
	=> strcpy;
	[source string] = [levl];
	[source string] < 10;
	[source string] + main;
	=> strcat;
	[source string] = junc string;
	=> strcat;
	[source string] = line string;
	=> strcat;
	[source string] = line number;
	=> strcat;
	[source string] = [cls string];
	=> strcat;
	[source string] = [sym string];
	=> strcat;
	[source string] = vjun string;
	=> strcat;
	[source string] = symbol value;
	=> strcat;
	[source string] = eol;
	=> strcat;
	-> log report;
      "log compiler report"
      (it's a reentry point, used after compiling and linking, for statistics)
	[source string] = log output;
	[target string] = compiler report;
	=> strcat;
      "log report"
      (it's a reentry point, used for reports that don't follow common scheme)
      ? [smap] = off -> ls off; (providing symbols map is required)
	[source string] = log output;
	=> strlen;
	[target string] = log output;
	=> fbtoa;
	[filecommand]  = write;
	[filename]     = symaps name;
	[fileposition] = [symaps fpos];
	[blockpointer] = [target string];
	[blocksize]    = [string length];
	isocall;
	[symaps fpos]  + [blocksize];
      "ls off"
	leave;

    "strlen"
    (finds out the length of 4b string pointed by [source string],
     giving result to variable [string length],
     not including the null terminator)
 ---->; a = [source string];
	b = zero;
      "strlen again"
      ? [a] = null -> strlen done;
	a +;
	b +;
	-> strlen again;
      "strlen done"
	[string length] = b;
 <----; leave;

    "atofb"
      (converts string pointed by [source string], given in ASCII format,
       to fourbyte format, and uses [target string] as a pointer to where
       resulting string is to be stored: halts when the first null byte
       is found in [source string])
 ---->; a = [source string];
	b = [target string];
	c = zero;
      "ca2fb loop"
	e = [a];
	b +;
	e > c;
	c + 8;
	e & ffh;
       [b minus 1] = e;
      ? e = null -> ca2fb done;
      ? c < 32 -> ca2fb loop;
	c = 0;
	a +;
	-> ca2fb loop;
      "ca2fb done"
 <----; leave;

    "fbtoa"
    (converts string pointed by [source string], given in fourbyte format,
     to ASCII format, and uses [target string] as a pointer to where resulting
     string is to be stored: halts when the first null unit is found in the
     string to convert - the source and target buffers must be both aligned to
     a unit's boundary, but they may be, without fear, even -the same- buffer)
 ---->; a = [source string];
	b = [target string];
	c = zero;
	d = FFFFFF00h;
      "cfb2a loop"
	e = [a];
	a +;
       [b] & d;
	e < c;
	c + 8;
       [b] | e;
      ? e = null -> cfb2a done;
      ? c < 32 -> cfb2a continue;
	b +;
	c = 0;
	d = FFFFFF00h;
	-> cfb2a loop;
      "cfb2a continue"
	d <@ 8;
	-> cfb2a loop;
      "cfb2a done"
 <----; leave;

   "atoui"
    (converts the contents of 4b string pointed by [source string], which is
     supposed to be numerical, decimal and without sign [positive or null],
     to binary, and stores the resulting value within [string binary]: if some
     of the string's units are outside the range of digits 0-9, returns zero
     and fails the call)
 ---->; a = [source string];
	b = zero;
      "atoui again"
	c = [a];
	c - 48;
      ? c = minus 48 -> atoui done;
      ? c < zero -> atoui zero;
      ? c > 9 -> atoui zero;
	b '* 10;
	a +;
	b + c;
	-> atoui again;
      "atoui zero"
	[string binary] = zero;
 <----; fail;
      "atoui done"
	[string binary] = b;
 <----; end;

    "uitoa"
    (converts value held by [string binary], which is supposed to be an
     unsigned integer value, to decimal, and stores the resulting text
     within 4b [target string])
 ---->; a = zero;
	b = [string binary];
      "uitoa forward"
	c = b;
	c '% 10;
	c + 48;
	[a relating uitoa helping] = c;
	a +;
	b '/ 10;
      ? b > zero -> uitoa forward;
	b = [target string];
      "uitoa reverse"
	[b] = [a minus 1 relating uitoa helping];
	b +;
	a ^ uitoa reverse;
	[b] = null;
 <----; leave;

    "strcmp"
    (compares two 4b strings pointed by [source string] and [target string],
     succeeds if the strings are equal,
     fails it they're different)
 ---->; a = [source string];
	b = [target string];
      "strcmp again"
      ? [a] != [b] -> strcmp diffr;
      ? [a] = null -> strcmp equal;
	a +;
	b +;
	-> strcmp again;
      "strcmp equal"
 <----; end;
      "strcmp diffr"
 <----; fail;

    "strpcmp"
    (partial comparison of 4b [source string] against 4b [target string], by
     comparing until the end of [target string]; if all units matched until
     that point, the strings are considered to be equal and the rest of the
     [source string] is ignored: returns always successful - always equal -
     if the [target string] points to a void string)
 ---->; a = [source string];
	b = [target string];
      "strpcmp again"
      ? [b] = null -> strpcmp equal;
      ? [a] != [b] -> strpcmp diffr;
	a +;
	b +;
	-> strpcmp again;
      "strpcmp equal"
 <----; end;
      "strpcmp diffr"
 <----; fail;

    "strcpy"
    (copies 4b [source string] to 4b [target string])
 ---->; a = [target string];
    "strcpy strcat reentry"
	b = [source string];
      "strcpy again"
	[a] = [b];
	a +;
	b +;
      ? [b minus 1] != null -> strcpy again;
 <----; leave;

    "strcat"
    (concatenates 4b [source string] to 4b [target string])
 ---->; a = [target string];
      "strcat again"
      ? [a] = null -> strcpy strcat reentry;
	a +;
	-> strcat again;

    "strstr"
    (searchs 4b [target string] within 4b [source string],
     succeeds if match found, and returns match ptr. as [target string],
     fails otherwise, leaving [target string] unchanged,
     also fails unconditionally if one of the strings is void)
 ---->; a = [source string];
	b = [target string];
      ? [a] = null -> strstr match not found;
      ? [b] = null -> strstr match not found;
	c = [b];
	d = [a];
      "strstr again"
      ? d = null -> strstr match not found;
      ? c != d -> strstr fast skip;
	d = a;
	e = b;
      "strstr compare"
      ? [e plus 1] = null -> strstr match found;
      ? [d plus 1] = null -> strstr match not found;
      ? [d plus 1] != [e plus 1] -> strstr fast skip;
	d +;
	e +;
	-> strstr compare;
      "strstr fast skip"
	d = [a plus 1];
	a +;
	-> strstr again;
      "strstr match found"
	[target string] = a;
 <----; end;
      "strstr match not found"
 <----; fail;

     "strlwr"
     (converts 4b [target string] to lowercase)
	a -->;
	b -->;
	a = [target string];
      "strlwr again"
	b = [a]; (load)
	a +; (advance ptr)
      ? b > 90 -> strlwr skip; (above "Z")
      ? b < 65 -> strlwr skip; (below "A")
	b + 32; ("A" -> "a")
	[a minus 1] = b; (store)
      "strlwr skip"
      ? b != null -> strlwr again;
	<-- b;
	<-- a;
	leave;

    (
    --------------------------------------------------------
    note: not needed for this program, here for completeness
    --------------------------------------------------------
    "strupr"
    (converts 4b [target string] to uppercase)
	a -->;
	b -->;
	a = [target string];
      "strupr again"
	b = [a]; (load)
	a +; (advance ptr)
      ? b < 097 -> strupr skip; (below "a")
      ? b > 122 -> strupr skip; (above "z")
	b - 32; ("a" -> "A")
	[a minus 1] = b; (store)
      "strupr skip"
      ? b != null -> strupr again;
	<-- b;
	<-- a;
	leave;
    )

    "fcpy"
    (copies binary [source file], starting reading from [source fpos],
     to [target file], starting writing [target file] at [target fpos],
     reading and writing for upto [transf size] byts:
     both files must be shorter than 2^31 bytes - that is 2 Gb - in size,
     both <fpos> parameters are expressed in bytes and must be positive,
     if [transf size] is negative, e.g. minus 1, copies whole [source file],
     if [target file] doesn't exist, the routine creates it,
     if [target file] exists, and:
     - [target fpos] after end of [target file], extends [target file],
     - [target fpos] before end of [target file], overwrites the intersection,
     fails if it can't read from [source file] or write to [target file],
     succeeds, but does not touch [target file], if [source file] is void,
     or if [source file] is shorter than [source fpos].
     * preserves and returns all parameters and registers unchanged.)
	[source fpos] -->;
	[target fpos] -->;
	[transf size] -->;
      "fcpy fcat reentry"
      ? [source fpos] < zero -> fcpy error;
      ? [target fpos] < zero -> fcpy error;
      "fcpy loop"
      ? [transf size] = zero -> fcpy done;
	[file command] = read;
	[file name] = [source file];
	[file position] = [source fpos];
	[block pointer] = ffun cache;
	[block size] = sizeof ffun cache mtp bytes per unit;
	isocall;
      ? failed -> fcpy error;
      ? [block size] = zero -> fcpy done;
      ? [transf size] < zero -> fcpy no limit;
	[transf size] - [block size];
      ? [transf size] >= zero -> fcpy no limit;
	[block size] + [transf size];
	[transf size] = zero;
      "fcpy no limit"
      ? [fcpy callback] = null -> fcpy no callback;
	=> [fcpy callback];
      "fcpy no callback"
	[file command] = write;
	[file name] = [target file];
	[file position] = [target fpos];
	[block pointer] = ffun cache;
	[fcpy verify] = [block size];
	isocall;
      ? failed -> fcpy error;
      ? [fcpy verify] != [block size] -> fcpy error;
	[source fpos] + [block size];
	[target fpos] + [block size];
	-> fcpy loop;
      "fcpy done"
	<-- [transf size];
	<-- [target fpos];
	<-- [source fpos];
	end;
      "fcpy error"
	<-- [transf size];
	<-- [target fpos];
	<-- [source fpos];
	fail;

    "fcat"
    (concatenates [source file] to [target file], using "fcpy" entered with:
     - [source fpos] = zero;
     - [target fpos] = file size of [target file];
     - [transf size] = minus 1.
     * preserves and returns all parameters and registers unchanged.)
	[source fpos] -->;
	[target fpos] -->;
	[transf size] -->;
	[file command] = test;
	[file name] = [target file];
	isocall;
	[source fpos] = zero;
	[target fpos] = [file size];
	[transf size] = minus 1;
	-> fcpy fcat reentry;

    "swap endian"
    (converts an area of memory from small-endian to big-endian, and
     vice-versa, depending on what's the compiler been compiled with...
     the fact that there's two standards is a terrible nightmare, yes,
     and I wonder if big-endian processors will ever get to convert to
     small-endian or disappear, or small-endian processors convert to
     big-endian or disappear, anyway CHOOSE ONE, PLEASE... no I'm not
     sure I've considered every possibility before a real event of
     swapping to big-endian, I've tried to, but it really is difficult
     to tell, we're speaking of PURE NUMBERS, not some mad device out
     of any standards, and the world is just so crazy to use two ways
     to save values into some binary programmable machine memory...
     oh, well, it's already something that they did agree on using 8
     bits per byte and say the byte is really a standard... I just hope
     that with time, those who decided what they decided decades ago
     about big and small endian, did at least begin to understand what
     they just did... and I keep wondering why they did...
	*lights up a cigarette*
     ...okay this is the equivalent of a BSWAP on all the doublewords
     forming the [area to swap], ie for [size of area to swap] dwords,
     and one of those times you get to think that CISC is so nice...)
 ---->; a = [area to swap];
	a + [size of area to swap];
      "swap endian loop"
	b = [a minus 1];
	c = b;
	d = b;
	e = b;
	b & 000000FFh;
	c & 0000FF00h;
	d & 00FF0000h;
	e & FF000000h;
	b < 24;
	a -;
	c < 8;
	d > 8;
	e > 24;
	b | c;
	b | d;
	b | e;
	nop;
       [a] = b;
      ? a >= [area to swap] -> swap endian loop;
 <----; leave;
