(

    integration Graphical User Interface
    version packaged with Linoleum 1.13.12b, last changed 02/16/2004
    --------------------------------------------------------------------------
    | Weighs:	      46826 bytes *  [BUT PLEASE SEE NOTE AFTER THE LGPL]
    | Allocates:      21036 bytes ** [BUT PLEASE SEE NOTE AFTER THE LGPL]
    --------------------------------------------------------------------------
    | *  code size + initialized data size + stockfile parts size
    | ** uninitialized data size [RAM needed, symbols in workspace period]
    --------------------------------------------------------------------------
      This library is free software;  you can redistribute it and/or modify it
    under the terms of the  GNU Lesser General Public License  as published by
    the  Free Software Foundation;  either version 2.1	of the License, or, at
    your option, any later version.
      This  library  is  distributed  in the hope  that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.
      See the GNU Lesser General Public License for more details.
      You should have received a copy of the GNU Lesser General Public License
    along with this library;  if not,  write to the  Free Software Foundation,
    Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
    --------------------------------------------------------------------------
      Given this package's libraries conventions, functions are not assumed to
    care for preserving registers' contents, but they might preserve any entry
    parameters passed throught related variables.  This library is provided as
    part of the L.in.oleum compiler package's default libraries.

    Note on this library's "weight" calculation:
    --------------------------------------------------------------------------
    Code + static data size computation was made using minimal but unrealistic
    setup constants, in a test application which included only "defstyle.txt",
    and for which the constants layout was as follows:

	INITIAL WIDTH			= 0;
	INITIAL HEIGHT			= 0;
	MINIMUM WIDTH			= 0;
	MINIMUM HEIGHT			= 0;
	MAXIMUM WIDTH			= 0;
	MAXIMUM HEIGHT			= 0;
	MAX MENU OPTIONS		= 0;
	MAX ONSCREEN OPTIONS		= 0;
	MAX LEVELS IN SHOW		= 0;
	MAX FILES IN SELECTOR		= 0;
	MAX FILES IN SHOW		= 0;
	MAX OPTIONS IN QUESTION 	= 0;
	MAX FIELDS IN QUESTION		= 0;

    So please be aware that such an application would compile successfully,
    but if you set all those constants as above you're providing no memory for
    storage of important iGUI data, and used in a serious application, such a
    configuration for the setup constants would result in a 100% sure crash.
    The all-zeroed configuration was used only for calculating how many bytes
    the library's bare code and constant-sized static data will be taking into
    the final executable file, for informative purposes only.
    Also note that the "weight" includes the 10,866 bytes taken by the default
    skin graphics parts. The default skin for this version is "Toffee", and is
    configured by main/lib/igui/defstyle.txt.

	Actual features:			     Remarks:
	------------------------------------------------------------------
      - standard iGUI window control buttons	     [all iGUI's versions]
      - pull-down menus and simple file selectors    [all iGUI's versions]
      - question boxes and text fields in questions  [buggy until 1.13.3b]
      - tools bar at the bottom of the display	     [buggy until 1.13.4b]
      - scrollers, a.k.a scroll bars		     [buggy until 1.13.5b]
      - directories exploration in file selectors    [implemented 1.13.6b]
      - skin exchange "on the fly"		     [implemented 1.13.7b]
      - keyboard-driven menu & dialogs controls      [implemented 1.13.9b]
      - cut, copy and paste in text fields	     [implemented 1.13.9b]
      - scrollers react to mouse wheel movements     [implemented 1.13.10]
	------------------------------------------------------------------

	Changelog:
	------------------------------------------------------------------
      - [1.13.6b] Improved precision in scrollers' readout management.
		  Specially since the iGUI now uses ITS OWN scrollers to
		  explore contents of a file selector.
      - [1.13.6b] Removed "dump button" formerly printing current display.
		  Deemed pratically useless, and since the introduction of
		  modular extensions, would have meant sensible growth in
		  the iGUI executables' size, considering the 1.5 Kb more
		  for the printer extension, and about 1.3 Kb for both the
		  additional button's code and the button's image itself.
      - [1.13.7b] several changes to DefStyle and generally to external
		  symbols declarations, accomodating the possibilty to
		  import/export skins "on the fly", but unfortunately also
		  compelling existing software to "retouch" their styles
		  in the case they didn't use "DefStyle". Now, support for
		  skins' import/export is built into an optional library,
		  "IGS.txt", which may or may not be included by the main
		  program, at the author's choice. For informations about
		  how to use IGS, see that library itself.
      - [1.13.7b] implemented possibility to witheld the menu caption text
		  on a per-skin basis, ideally for when it's disturbing a
		  graphical menu button which isn't intended to hold some
		  text over its surface. See skin block of "DefStyle.txt",
		  it's that flag called "Write Caption Over Menu Button".
      - [1.13.7b] fixed bug where buffer for sleepy windows position was
		  a bit too small, and overwritten pointer-related units.
      - [1.13.7b] fixed bug in file selectors' FILENAMEBOX, not appending
		  file name after path when the user typed some text in
		  the text field and the clicked that same text filed [it
		  worked, instead, when pressing ENTER].
      - [1.13.7b] made file selectors automatically append file extension
		  [or a generic "filter"] to typed file names, evidently
		  expectable by many users.
      - [1.13.8b] corrected file selectors' behaviour not listing folders
		  alphabetically [they were only sorting files, but they
		  were supposed to also sort directories].
      - [1.13.9b] codesize optimization - the following couple lines:
		    => subroutine;
		    end;
		  wherever found, has became:
		    -> subroutine;
		  which results in the same behaviour, apart from one less
		  unit saved to the stack, but it's faster and especially,
		  takes 6 bytes less; there were many occurrences of this:
		  quick and simple, in the end it saved about 500 bytes!
		  other than that, "end" became "leave", when applicable.
      - [1.13.10] scrollers focusing: focused scroller reacts to movements
		  of the mouse wheel; to read the mouse wheel on Windows,
		  however, the RTM 1.13.10b requires -at least- Windows98.
      - [1.13.11] changed "FoldUnfold Rendezvous" point to proceed with
		  "Refresh Display" instead of just "Update Layers", 'cos
		  the simple update wasn't retracing the backdrop layer if
		  the "Now Fold" subroutine was called from a menu option,
		  as the Icon Editor does. Closing the menu after such an
		  option was selected, caused a refresh to happen but the
		  [display height] was then 25 pixels, causing "normalize
		  region" to believe that, and limit all regions to that.
      - [1.13.12] er... fixed glitch in fold/unfold introduced above: the
		  retrace-after-fold was causing a few regions which were
		  often involved in W.A.Ms to be void, but not supposed by
		  the client to need a normalize, well.. in the end it was
		  overwriting memory around. I've not let it refresh when
		  unfolding, but not with folding, and removed the common
		  rendezvous point. It *might* always work now. I have not
		  been updating anything else because I've been quite busy
		  writing the L.in.oleum compiler version 1.14.
	------------------------------------------------------------------

	------------------------------------------------------------------
	PLEASE SEE FOLLOWING EXAMPLES,	READ THEIR COMMENTS, TO UNDERSTAND
	HOW THE iGUI IS  SETUP AND USED  BY APPLICATIONS; THE iGUI IS ONLY
	A FACILITY TO BUILD  USER-FRIENDLY  LINOLEUM APPLICATIONS, BUT YOU
	ARE *NOT* COMPELLED TO USE THIS GUI AS THE ONLY POSSIBLE GRAPHICAL
	INTERFACE,  THERE IS ABSOLUTELY  NO FORCED INTEGRATION BETWEEN THE
	LINOLEUM RUNTIME ENVIRONMENT AND THIS LIBRARY.	THE INTEGRATION IS
	ONLY EFFECTIVE ON A PER-APPLICATION BASIS!  THE iGUI HAS *NOTHING*
	TO DO WITH THE BASIC PRINCIPLES OF THE LINOLEUM ENVIRONMENT, WHICH
	IS DESIGNED TO BE ABSOLUTELY CROSS-PLATFORM. iGUI IS A LIBRARY, IT
	IS NOT PART OF THE HOST OPERATING SYSTEM OR OF THE RUNTIME MODULE,
	IT DOES NOT RELY ON SPECIFIC FEATURES OF THOSE TWO ENTITIES. IT IS
	FUNDAMENTALLY A TEXT FILE,  THIS TEXT FILE,  LIKE MANY OTHERS THAT
	YOU MAY WRITE ON YOUR OWN TO REPLACE THIS FILE'S FUNCTIONALITIES.
	------------------------------------------------------------------

	examples\iGUIcli.txt
	   minimum iGUI client, a skeleton application

	examples\DIRit.txt
	   using a virtual console for program's output

	examples\icon_editor\iconed.txt
	   using a toolbar
	   switching resolutions for fullscreen display

	examples\linoinstaller\linoinstaller.txt
	   package's front-end
	   using a background image

	examples\network_node\node.txt
	   virtual console for networking purposes:
	   when used as a client, it's similar to a telnet client,
	   but it can also play the part of a "dumb" server

	documentation about basic iGUI's facilities usage is found in the
	Icon Editor source code; default library "VCons.txt" documents the
	workings of iGUI's scrollbars management facilities, by operating
	a vertical scroller

	other programs using the iGUI found on anywherebb.com:

      | ArtSCII, http://anywherebb.com/software.html
      |    uses both an horizontal and a vertical scroller
      | The Narrator, http://anywherebb.com/software.html
      |    changes mouse pointer's shape and shadow, among other things

	known alternative skins for the iGUI at this very moment:

      | Peterpaul Klein Haneveld's aqua clone at:
      | http://www.kleinhaneveld.tk

	for further skins check out the forums at http://anywhere.i.am,
	there's at least a few members there occasionally popping one out...

)

"libraries"

	/gen/ekey;    (enhanced keystrokes server)
	/gen/allowdd; (allows display dragging via handle to be defined by callers)
	/gen/stdfont; (standard ASCII font support, including default font shape)
	/gen/hotspot; (hot spots manager: they're areas sensible to mouse actions)
	/gen/region;  (what I call regions are rectangular areas of the display)
	/gen/layers;  (layers are alternative DRAM frame buffers, see library)
	/gen/rect;    (draws gradiented rectangles with specified effects)
	/gen/tga;     (loads TGA pictures)
	/gen/tgatile; (used to fill regions by repeating a "tile" in TGA format)

"stockfile"

	btnclose; btnsleep; btnflunf; btnfulls; btnmaxim; btnresiz;
	menulogo; mpointer; mpshadow; wcaption; pmfiller; tcshadow;
	lcshadow; brshadow; phshadow; pvshadow; dbfiller; toolsbar;
	tbbutton; scrollth; scrollph; scrolltv; scrollpv;

"constants"

    (public)
	OPTION TYPE NORMAL		= 00000000h;
	OPTION TYPE SUBMENU		= 00000001h;
	OPTION TYPE FILE SELECTOR	= 00000002h;
	OPTION TYPE DISABLED		= 00000004h;
	OPTION TYPE FILENAME		= 80000000h;
	OPTION TYPE FILENAMEBOX 	= 40000000h;
	IS FIRST OPTION IN LEVEL	= 80000000h;
	IS LAST OPTION IN LEVEL 	= 40000000h;
	ENDOFMENU			= NULL;

	TOOLS BAR SEPARATOR		= 1;
	ENDOFTOOLS			= NULL;

    (scroller datascripts' fields and offsets)
	SCROLLER IDENTITY		= 0; (24 bits, bits #24-31 reserved!)
	SCROLLER BOUNDS 		= 1;
	SCROLLER PAD POSITION		= 5;
	SCROLLER SCOPE			= 6;
	SCROLLER WINDOW 		= 7;
	SCROLLER READOUT		= 8;
	SCROLLER TRACK LENGTH MEMORY	= 9;
	SCROLLER SCOPE MEMORY		= 10;

    (scroller datascripts' behavior flags, marked in SCROLLER IDENTITY field)
    (that's what the identity field's 8 top-most bits are reserved to...)

	SB NOREDRAW ON CHANGE		= 80000000h;
       (avoids redrawing the scrollbar and refreshing the part of the display
	that's covered by the scrollbar: this is a little speed-up and avoids
	some flickering in the cases where changing the position of the pad
	will also, directly or indirectly, cause the scrollbar to be also
	retraced, that is, when the scrollbar is PART of the scrolled entity:
	for example, vcons' scrollbar uses this flag, as well as iGUI file
	selectors)

	SB WHEEL MULTIPLY		= 40000000h;
       (applies a given multiplication factor to the units scrolled when the
	scrollpad is moved throught the mouse wheel: the factor used is in
	variable [Wheel Multiplication Factor])

    (text fields' behavior flags)
	TXF NOREDRAW			= 1; (field text must not be written)
	TXF NOUPDATE			= 2; (field area may not be retraced)

    (internal)
	RGFX PARTS COUNT		= 23;
	HORIZONTAL			= 1;
	VERTICAL			= 2;

"variables"

    (public)

    (a string and a string pointer: the menu caption is what's written on the
     pull-down menu button: if you change the menu caption at any time, do a
     "=> Update Menu Button Appearence;" to show changes)
	Default Menu Caption = { MENU };
	Menu Caption = Default Menu Caption;

    (integer values: if displacements are both zero, the text is perfectly
     centered within the area of the menu button, otherwise the displacements
     are algebrically added to the center's coordinates)
	Menu Caption X Displacement = 1;
	Menu Caption Y Displacement = 1;

    (a string and a string pointer: small caption, written while the app is
     "iconified": displacements given for menu caption also affect this)
	Default Small Caption = { NO_NAME };
	Small Caption = Default Small Caption;

    (milliseconds between each iteration: the value below may be zeroed to
     disable delays between each control loop - this increases performance
     significantly, but consumes 100% of the CPU time left by any other
     applications having smaller priority levels; ideally, this variable
     might be zeroed only while doing time-critical processing)
	Control Loop Idle Slice = 10;

    (flag: specifies if iGUI is supposed to clear the display with black;
     it is normally done to clear the remnants of previous frames, specially
     while resizing the display, but it may be turned off if your application
     knows that its on-screen elements will cover the whole display, and it
     doesn't need the iGUI to waste time by pre-claring it - in the end, it's
     useful to set this to NO for graphics-intensive applications in need of
     best performance from the "Refresh Display" function)
	Always Clear Work Area = YES;

    (flags: in control loops, their actual YES/NO state indicates that the
     application - a.k.a. the "client" - may check and use the mouse pointer
     or the console input functions; if an application, in its control loops,
     finds out these flags are set to NO, it might not use the corresponding
     resource to avoid INTERFERING with the iGUI, because when these flags
     are set to NO, the mouse pointer or the intended focus for keyboard's
     input are actually placed over controls that belong to the iGUI itself)
	Client Owns Mouse Pointer = YES;
	Client Owns Text Cursor = YES;

    (vector: the "work area" is what others may call the "client area" of
     the window, the rectangular area of the window which is available to
     the application for showing its visual user interface, or the output;
     ideally, no drawing operations may be performed outside this area;
     beware that the work area's limits may change according to the size
     of the window - to reflect such changes, the following vector is
     automatically kept up-to-date by the iGUI itself, typically in reply
     to the user dragging around the window's "adjust size" button)
 vector Work Area = 1; 25; INITIAL WIDTH minus 2; INITIAL HEIGHT minus 2;

    (string pointer: by default it points to "Application Description"
     among the resident strings declared by the client application, and
     that string, if using DefStyle.txt, reads "NO NAME", but it may be
     pointed to another string during the run-time; after changing this
     pointer, refresh the title bar with a "=> Update Title Bar;")
	Window Title = Application Description;

    (positive integer values: they may be changed to resize the window,
     but as soon as possible, after resizing it, you'll have to make a
     call to "=> Resize Display", to make changes effective; beware that
     resizing below 248 pixels in width is not allowed, and if done, it
     will crash the iGUI; also beware that forcely resizing the display
     in this way, if the application is running in full-screen mode,
     will cause the display to return to windowed mode)
	New Display Width = INITIAL WIDTH;
	New Display Height = INITIAL HEIGHT;

    (pointer's presence counter: specifies when the mouse pointer is NOT to
     be showen; on entry it's set to minus 1, where any negative values will
     cause the arrow not to be traced, however the arrow reveals right after
     entering the iGUI's main hook "Enter Integrated GUI", otherwise it would
     lay somewhere on the display, but it would not move until that hook is
     entered, and give the impression, to the user, that the arrow is enabled
     and SHOULD move; this way it only appears when the application completed
     its initialization section [the section to be placed between a call to
     "Initialize Integrated GUI" and a call to "Enter Integrated GUI"]: this
     is a counter, because nidified control loops, that is multiple loops one
     inside another, could alternately request the mouse pointer to be hidden
     or showen; this way, by decreasing this counter to hide the pointer, and
     and vice-versa increasing the counter to show the pointer, this counter
     might keep track of the final result of those requests and that's why if
     the counter holds a POSITIVE or NULL value, the arrow gets showen, while
     if it holds a NEGATIVE value, the arrow gets hidden; now, if you're more
     familiar with Win32's GUI, this mechanism is very similar to the way its
     GUI manages calls to the "ShowCursor" function)
	Arrow Presence = minus 1;

    (the following may be changed to customize scrollers' global behavior:
     "Scroller Adv Ticks Delay" is the amount of millisecond the iGUI waits
     before changing the readout by 1 unit while the user is holding mouse's
     left button pressed down on the scroller's track, outside the pad: iGUI
     scrollers don't use arrows at each end because they allow to scroll at
     the maximum precision of 1 unit per click by simply clicking the track
     instead of the pad, in the direction the user wants to scroll to.
     "Wheel Doublings Per Knot" is an exponent of 2 to be used for enhancing
     the movement when a scroller is changed using the mouse wheel: if it's
     set to zero, the wheel will scroll by 1 * 2^0 readout units, that is,
     by 1 readout unit per "knot" of the wheel; the default is 2, which will
     cause the wheel to scroll by 1 * 2^2, which is 1 * 4, units per knot:
     this is why the wheel scrolls iGUI file selectors by 4 files at a time.
     "Wheel Multiplication Factor" is ALSO an exponent of 2 to be used for
     further multiplying the units scrolled per wheel's knot: only, this one
     is applied if the scroller's identity has the "SB WHEEL MULTIPLY" flag
     set; this is done by VCons, for example, because VCons scrolls the text
     1 pixel at a time, not 1 character at a time, so scrolling without the
     multiplier would normally be too slow for that particular case; now, by
     considering the defaults given above, the resulting advance per knot of
     a scroller using SB WHEEL MULTIPLY is given by 1 * 2^2 * 2^4, which is
     1 * 4 * 16, and in the end 1 * 64, so VCons' scroller by default will
     scroll the console text at 64 pixels per wheel knot: considering default
     font's body of 16 pixels per line, this ALSO means 4 lines per knot.
     A warning: [Wheel Multiplication Factor] might not be kept at zero when
     scrollers are using it, because given the quick and short bitwise shifts
     used for calculating the amount to be added to the readout, exponent 0
     there would be considered like exponent 31; as to why this happens, it's
     a matter of ANDing the scroller's identity field for insulating the SB
     WHEEL MULTIPLY flag, and subsequently wishing to shift it right by 32
     minus zero bits, that is, by 32 bits, but a 32-bit shift is normalized
     by 32-bit CPUs to a shift of zero bits, because only the leftmost 5 bits
     of the shift counter are taken in consideration by the CPU... oh, well,
     nevermind, just don't set [Wheel Multiplication Factor] to zero :P)
	Scroller Adv Ticks Delay = 250;
	Wheel Doublings Per Knot = 2;
	Wheel Multiplication Factor = 4;

    (internal)

    (resident graphics)
 vector RGFX Positions =
		btnclose; btnsleep; btnflunf; btnmaxim; btnfulls; btnresiz;
		menulogo; mpointer; mpshadow; wcaption; pmfiller; tcshadow;
		lcshadow; brshadow; phshadow; pvshadow; dbfiller; toolsbar;
		tbbutton; scrollth; scrollph; scrolltv; scrollpv;

 vector RGFX Buffers =
		Exit Button Shape; Slep Button Shape; Fold Button Shape;
		Maxi Button Shape; Full Button Shape; Size Button Shape;
		Logo Shape; Crosshair Shape; Crosshair Shadow;
		Window Caption; Menu Filler; Menu Shadow Top Corner;
		Menu Shadow Left Corner; Menu Shadow Bottom Right Corner;
		Menu Shadow Horizontal;  Menu Shadow Vertical;
		Dialog Filler; Tools Bar Filler; Tools Bar Button;
		H Scroller Track; H Scroller Pad;
		V Scroller Track; V Scroller Pad;

 vector RGFX Sizes =
		Size of btnclose; Size of btnsleep; Size of btnflunf;
		Size of btnmaxim; Size of btnfulls; Size of btnresiz;
		Size of menulogo; Size of mpointer; Size of mpshadow;
		Size of wcaption; Size of pmfiller; Size of tcshadow;
		Size of lcshadow; Size of brshadow; Size of phshadow;
		Size of pvshadow; Size of dbfiller; Size of toolsbar;
		Size of tbbutton; Size of scrollth; Size of scrollph;
		Size of scrolltv; Size of scrollpv;
		53444E45h; ( 'ENDS' signature for .IGS skin packets )

    (generic)
	Exit Shown As Active		= YES;
	Menu Shown As Active		= YES;
	Size Shown As Active		= YES;
	Title Shown As Active		= YES;
	Previous display width		= INITIAL WIDTH;
	Previous display height 	= INITIAL HEIGHT;
	Previous display X position	= MIDDLE;
	Previous display Y position	= MIDDLE;
	Previous thread priority	= NORMAL PRIORITY;
 vector Standard Black Gradients	= 0.0f *** 9;
 vector All Controls Off		= .15f; .15f; .15f; 0.1f; 0.1f; 0.1f; .05f; .05f; .05f;
 vector iGUI Caption Bar		=   1; 0; INITIAL WIDTH minus 2; 24;
 vector iGUI Window Left Edge		=   0; 0; 0; INITIAL HEIGHT minus 2;
 vector iGUI Window Right Edge		= INITIAL WIDTH minus 1; 0; INITIAL WIDTH minus 1; INITIAL HEIGHT minus 2;
 vector iGUI Window Bottom Edge 	=   0; INITIAL HEIGHT minus 1; INITIAL WIDTH minus 1; INITIAL HEIGHT minus 1;
 vector Title Bar Bounds		= 121; 1; INITIAL WIDTH minus 127; 23; 0;
 vector Sleeping Title Bar Bounds	=  25; 1; 124; 23;
 vector Sleeping Title Bar Shadow	=  25; 1;  34; 23;
 vector Exit Button			=   1; 1;  23; 23;
 vector Exit Button Hotspot		=   0; 0;  23; 23; 0;
 vector Slep Button			=  25; 1;  47; 23;
 vector Slep Button Hotspot		=  24; 0;  47; 23; 0;
 vector Fold Button			=  49; 1;  71; 23;
 vector Fold Button Hotspot		=  48; 0;  71; 23; 0;
 vector Fold Button Inside		=  49; 1;  71; 23;
 vector Maxi Button			=  73; 1;  95; 23;
 vector Maxi Button Hotspot		=  72; 0;  95; 23; 0;
 vector Full Button			=  97; 1; 119; 23;
 vector Full Button Hotspot		=  96; 0; 119; 23; 0;
 vector Full Button Inside		=  97; 1; 119; 23;
 vector Size Button			= INITIAL WIDTH minus 24; 1; INITIAL WIDTH minus 2; 23;
 vector Size Button Hotspot		= INITIAL WIDTH minus 25; 0; INITIAL WIDTH minus 1; 23; 0;
 vector Menu Button			= INITIAL WIDTH minus 125; 1; INITIAL WIDTH minus 26; 23;
 vector Menu Button Hotspot		= INITIAL WIDTH minus 126; 0; INITIAL WIDTH minus 26; 23; 0;
 vector Tools Bar Bounds		= 1; INITIAL HEIGHT minus 24; INITIAL WIDTH minus 2; INITIAL HEIGHT minus 2;
 vector App Menu Description		= { Main Menu }; extend upto: 64;
 vector Tool Tip			= { Placeholder }; extend upto: 64;
 vector Tool Hovering Gradients 	= 1.0f; 0.0f; 0.0f; 1.0f; 0.0f; 0.0f; 1.0f; 0.0f; 0.0f;
 vector Tool Pushing Gradients		= .33f; .33f; .33f; .33f; .33f; .33f; 0.0f; 0.0f; 0.0f;

    (display window)
	Sleepy Display X Position	= UNDEFINED;
	Sleepy Display Y Position	= UNDEFINED;
	Sleepy Windows Key		= { iGUI_sleepy_windows_pos };

    (file selectors)
 vector FS scroller =
	9999999 plus SB NOREDRAW ON CHANGE;
			 (above: control identity: any value but "undefined")
	0; 0; 0; 0;	 (bounds: filled depending on menu area bounds)
	zero;		 (initial position of pad, in pixels, usually zero)
	undefined;	 (scope: size of entity to be scrolled)
	undefined;	 (window: size of visible part of the list)
	zero;		 (initial readout: pad's position in "scope units")
	undefined;	 (memorizes last known scroller track's length)
	undefined;	 (memorizes last known scroller scope)

    (questions)
	Q Datascript Before Overscan	= On Question Overscan;

    (tools bar)
	Tool Tip Identity		= UNDEFINED;

    (scrollers)
	Lock On Scroller		= UNDEFINED;
	Last Locked Scroller		= UNDEFINED;

"workspace"

    (public)

    (service subroutine pointer: the "Work Area Manager" is the subroutine,
     declared as a service inside the client application, that's supposed to
     retrace application-related contents on the display, whenever a display
     refresh is required, either because the "=> Refresh Display;" function
     has been esplicitly called, or because an iGUI control needs that;
     applications might expect calls to this service to occur at any time;
     if the pointer is zeroed, then no such service is provided/necessary)
	Work Area Manager = 1;

    (service subroutine pointer: the "Control Loop" is where a GUI-driven
     application spends most of its time waiting for user input; alhtough
     the iGUI has its own internal control loop, at every single frame it
     will call the application's specific control loop to provide a hook
     for the application to interact with the user, e.g. "did the user
     click on a certain point?", "did the user press this key?", etc...
     things that are checked in the control loop, are checked continuously,
     once per frame; if the pointer is zeroed, then no such service is
     provided/necessary)
	Control Loop = 1;

    (service subroutine pointer: this is like "Control Loop", but it might
     point to a special version of the above control loop, where the loop
     does never request for display refreshes, or alters the display in any
     other ways; this version of the control loop, in facts, takes control
     whenever the application is iconized; if the pointer is zeroed, then
     no such service is provided/necessary)
	Sleepy Control Loop = 1;

    (flag: client applications may set "Quit Now" to YES at any time - doing
     this will cause the iGUI to return control to the main program, right
     after the latest call to "=> Enter Integrated GUI;" - ideally, this is
     set to yes in reply to an user action that might quit the whole program,
     and the iGUI assumes this automatically when:
     - the red exit button is pressed with the mouse pointer
     - ALT+F4 key combination is detected by ekey session 19010003)
	Quit Now = 1;

    (flag: can be checked in control loops and work area managers - if YES,
     then the display is in fold state, that is, the window is now only 25
     pixels tall, and most of the iGUI's controls are temporarily disabled;
     normally, and unless the application uses the window's height for some
     particular reason, this might not influence the program's behaviour,
     and the only thing an application might *NOT* do while it's fold, is
     forcely resizing the display, either by calling "=> Resize Display" or
     by simply altering the [Display Width] and [Display Height] variables)
	Fold Is Active = 1;

    (flag: can be checked in control loops - if YES, then the application is
     in "dormant" state, where its priority has been set to the minimum and
     the display is "iconized", usually in the screen's lower right corner:
     when an application is sleeping, it may use a special control loop that
     could perform internal processes and checks, called the "Sleepy Control
     Loop" - while in this loop, applications might never alter the display
     in any way, including drawing upon it or refreshing it, no matter if
     those operations are properly done inside the work area; while iconized,
     the display might not be altered at all)
	Slep Is Active = 1;

    (string pointer: whenever this pointer is not assigned to zero, and
     unless the application is in fold or dormant state, a tooltip will be
     tailed to the mouse pointer's arrow, ideally to describe the pointed
     control: the tooltip will simply hold what the pointed string says;
     hovering iGUI controls causes this pointer to change)
	Balloon Text String = 1;

    ("Menu On" is a flag that informs about when the menu is being shown,
     "Last Lit Option" is the option code of the latest option the mouse
     pointer hovered; in conjunction, these two values may be used, for
     instance, to aim a textual description of the menu option's action;
     "Last Lit Option" is initially set to "UNDEFINED", and may be later
     set to that value again, to mean no options were recently hovered)
	Menu On = 1;
	Last Lit Option = 1;

    (service subroutine pointer: "On File Select" is called whenever the
     user presses the enter key in the file name text field of a menu
     option associated with a file selector, or clicks a file's name:
     the resulting file name is copied in "vector Selected File Name", a
     vector of 511 units holding upto 510 characters and a null terminator,
     and reflecting a 255-character path name followed by a 255-characters
     file name, and then one remaining unit for the null terminator)
	On File Select = 1;

    (string pointer: the "File Selector Filter" is a string formed by the
     very last characters of a file name that matches all files listed in
     a selector; ideally, those characters represent the conventional file's
     extension, preceeded by a dot, and the match isn't case-sensitive;
     if "File Selector Filter" is set to NULL, the list will be unfiltered;
     typically, both "On File Select" and "File Selector Filter" are loaded
     by an option manager that is associated with a menu option of type file
     selector, and this way, they determine the behaviour of the selector's
     list that is opened immediately after executing that manager subroutine)
	File Selector Filter = 1;

    (the following variables may be used to control text fields: such fields
     are used by the iGUI to control question boxes' text fields, and the
     file name field of a file selector; they may, however, be used directly
     by the application: those fields are event-driven and to setup
     interaction with such a field, all the following variables must be
     loaded in a control loop; right after loading them, a call to "=> Check
     Text Field" must be made: only one text field might have "input focus",
     that is, might read from the keyboard's buffer, at a time, so you might
     check if the client owns the text cursor before making any calls to the
     "Check Text Field" function, and avoid checking TWO of your own fields
     at the same time in a single frame: the said function, Check Text Field,
     will try and get any pending keystrokes and animate the field, allowing
     the user to scroll around the text even if the bounds of the field are
     smaller than the string itself; the Text Field Data parameter is a
     pointer to a vector of at least 7 units, where the first 4 units hold
     the pixel coordinates - left, top, right, bottom - of the text field's
     bounding box, and the remaining 3 units might be zeroed on entry, since
     they are used to hold data processed by "Check Text Field"; the buffer
     size must include the null terminator; the flag "Is active Text Field"
     means that the "Check Text Field" function will retrace the cursor in
     the field, to indicate the user that THAT field has the focus, but
     beware that in case the field hadn't the focus, the subroutine to call
     in place of "Check Text Field" is "CTF Refresh", which does not check
     and react to keyboard input, but just retraces the field, typically in
     a work area manager, and not in a control loop: in a control loop, you
     would only call "Check Text Field" for the field that has the focus;
     the parameters to "CTF Refresh" are the same as "Check Text Field")
	Text Field Data = 1; (ptr. to a vector of 7 units, see above)
	Text Field Size = 1; (size in units of the associated buffer)
	Text Field Buffer = 1; (ptr. to the associated text buffer)
	On Change = 1; (ptr. to service subroutine reacting to text changes)
	On Return = 1; (ptr. to service subroutine reacting to "enter" key)
	On Escape = 1; (ptr. to service subroutine reacting to "escape" key)
	On Tabstp = 1; (ptr. to service subroutine reacting to "tab" key)
	Is Active Text Field = 1; (flag: show the text cursor in this field)
	Text Field Behavior = 1; (retrace behavior flags: use TXF constants)

    (this must be loaded with a pointer to a question's datascript as
     described in example applications, such as "iconed.txt" and "node.txt",
     prior to calling the "=> Question" function, which will then parse the
     datascript, show the resulting question box, and call the routines in
     charge of servicing all the question's options; the option that just
     closes the question box is normally associated to a null pointer for
     its service subroutine: when such an option is clicked, the "Question"
     function just returns to the caller. "Q Default Option" is initialized
     at zero, to mean the very first option: the default option is coloured
     differently from the other options, and may be set to a value other
     than zero, in which case it might be re-initialized to the approperiate
     value on a per-question basis, that is, you re-load "Q Default Option"
     along with "Question Datascript", or you may choose to always present
     the first option as the default option, by always leaving that to zero)
	Question Datascript = 1;
	Q Default Option = 1;

    (pointer to menu datascript: to be loaded prior to calling function
     "Install Menu", will parse the datascript and store the menu layout
     in iGUI's work variables; for details see examples)
	Menu To Install = 1;

    (integer value giving, usually in hexadecimal, the option code as it
     appears in a menu datascript; the "Option Code" is loaded before
     calling any of the "Enable Option", "Disable Option", "Mark Option"
     and "UnMark Option" functions, to manipulate the menu in real time:
     it indicates which option is affected by the change; marking and un-
     marking pratically means setting the first character of the menu
     option's on-screen name to a blank space [demarker] or an asterisk
     [marker], typically for indicating which is the active option in a
     set of mutually exclusive options)
	Option Code = 1;

    (pointer to a tools bar datascript: for details see "Icon Editor";
     this value must be loaded prior to calling "Install Tools Bar", in
     order to parse the datascript and load its relevant data into iGUI's
     work variables; tools bar buttons' properties may be altered in real
     time while the tools bar is installed, such as for enabling and
     disabling them by setting they associated service subroutine pointers
     to non-zero or zero values, to change the color of their icons, etc;
     a good example, in this sense, is given in ArtSCII 1.2 source code)
	Tools Bar To Install = 1;

    (pointer to a scroller datascript: for details see "Network Node";
     this value must be loaded prior to calling "Check Scroller" or
     "Draw Scroller"; the source code of "VCons.txt" explains the
     mechanics of these scrollers in detail)
	Scroller Datascript = 1;

    (internal)

    (generic)
	Init OK 			= 1;
	Is Menu Balloon 		= 1;
	RD Disable			= 1;
	UL Disable			= 1;
	UA Disable			= 1;

    (pointing device cursor)
	Do Not Retrace Arrow Region	= 1;
	FMM X				= 1;
	FMM Y				= 1;
	FMM P				= 1;

    (pull-down menus)
	RMC String			= 1;
	RMC Region			= 1;
	Installed Menu Options		= 1;
	OnScreen Menu Options		= 1;
	OnScreen Menu Levels		= 1;
	Last Level First Option Index	= 1;

    (resident graphics)
	Exit Button Shape		= Size of btnclose div BYTES PER UNIT plus 1;
	Slep Button Shape		= Size of btnsleep div BYTES PER UNIT plus 1;
	Fold Button Shape		= Size of btnflunf div BYTES PER UNIT plus 1;
	Maxi Button Shape		= Size of btnmaxim div BYTES PER UNIT plus 1;
	Full Button Shape		= Size of btnfulls div BYTES PER UNIT plus 1;
	Size Button Shape		= Size of btnresiz div BYTES PER UNIT plus 1;
	Logo Shape			= Size of menulogo div BYTES PER UNIT plus 1;
	Crosshair Shape 		= Size of mpointer div BYTES PER UNIT plus 1;
	Crosshair Shadow		= Size of mpshadow div BYTES PER UNIT plus 1;
	Window Caption			= Size of wcaption div BYTES PER UNIT plus 1;
	Menu Filler			= Size of pmfiller div BYTES PER UNIT plus 1;
	Menu Shadow Top Corner		= Size of tcshadow div BYTES PER UNIT plus 1;
	Menu Shadow Left Corner 	= Size of lcshadow div BYTES PER UNIT plus 1;
	Menu Shadow Bottom Right Corner = Size of brshadow div BYTES PER UNIT plus 1;
	Menu Shadow Horizontal		= Size of phshadow div BYTES PER UNIT plus 1;
	Menu Shadow Vertical		= Size of pvshadow div BYTES PER UNIT plus 1;
	Dialog Filler			= Size of dbfiller div BYTES PER UNIT plus 1;
	Tools Bar Filler		= Size of toolsbar div BYTES PER UNIT plus 1;
	Tools Bar Button		= Size of tbbutton div BYTES PER UNIT plus 1;
	H Scroller Track		= Size of scrollth div BYTES PER UNIT plus 1;
	H Scroller Pad			= Size of scrollph div BYTES PER UNIT plus 1;
	V Scroller Track		= Size of scrolltv div BYTES PER UNIT plus 1;
	V Scroller Pad			= Size of scrollpv div BYTES PER UNIT plus 1;

    (display window)
	no label			= MAXIMUM WIDTH mtp 2 plus 1; (for spreading fxs)
	Primary Display 		= MAXIMUM WIDTH mtp MAXIMUM HEIGHT;
	no label			= MAXIMUM WIDTH mtp 2 plus 1; (for spreading fxs)

	no label			= MAXIMUM WIDTH mtp 2 plus 1; (for spreading fxs)
	Backdrop Layer			= MAXIMUM WIDTH mtp MAXIMUM HEIGHT;
	no label			= MAXIMUM WIDTH mtp 2 plus 1; (for spreading fxs)

	Sleepy Windows Data		= 255; (S.W.D. - a Global K)
	no label			= 1; (padder of S.W.D. for "copyback" loop)

    (pointing device cursor)
	Arrow X In This Frame		= 1;
	Arrow Y In This Frame		= 1;
	Arrow Shadow X In This Frame	= 1;
	Arrow Shadow Y In This Frame	= 1;
	Arrow X In Previous Frame	= 1;
	Arrow Y In Previous Frame	= 1;
	Arrow Shadow X In Previous Frame= 1;
	Arrow Shadow Y In Previous Frame= 1;
	Arrow Region Left Now		= 1;
	Arrow Region Top Now		= 1;
	Arrow Region Right Now		= 1;
	Arrow Region Bottom Now 	= 1;
	Arrow Region Left Before	= 1;
	Arrow Region Top Before 	= 1;
	Arrow Region Right Before	= 1;
	Arrow Region Bottom Before	= 1;
	Arrow Coverage Left		= 1;
	Arrow Coverage Top		= 1;
	Arrow Coverage Right		= 1;
	Arrow Coverage Bottom		= 1;
	iGUIcc Wheel Knot Actual	= 1;
	iGUIcc Wheel Knot Before	= 1;

    (balloon help)
	Balloon Width			= 1;
	Balloon Height			= 1;
	Balloon Left			= 1;
	Balloon Top			= 1;
	Balloon Right			= 1;
	Balloon Bottom			= 1;
	Balloon Window Left		= 1;
	Balloon Window Top		= 1;
	Balloon Window Right		= 1;
	Balloon Window Bottom		= 1;

    (pull-down menus)
	Examined Option 		= 1;
	Current Level In Show		= 1;
	First Option In Level		= 1;
	SML Attr			= 1;
	SML Left			= 1;
	SML Top 			= 1;
	SML Width			= 1;
	SML Height			= 1;
	SML Code Mask			= 1;
	SML Code Low			= 1;
	SML Code High			= 1;
	SML Option Top			= 1;
 vector SML String buffer		= 256;
 vector Menu Option Code		= MAX MENU OPTIONS;
 vector Menu Option String		= MAX MENU OPTIONS;
 vector Menu Option Attributes		= MAX MENU OPTIONS;
 vector Menu Option Manager		= MAX MENU OPTIONS;
 vector Menu Option OS Code		= MAX ONSCREEN OPTIONS;
 vector Menu Option OS Attr		= MAX ONSCREEN OPTIONS;
 vector Menu Option OS Man		= MAX ONSCREEN OPTIONS;
 vector Menu Option OS X		= MAX ONSCREEN OPTIONS;
 vector Menu Option OS Y		= MAX ONSCREEN OPTIONS;
 vector Menu Option OS W		= MAX ONSCREEN OPTIONS;
 vector Menu Option OS H		= MAX ONSCREEN OPTIONS;
 vector Menu Option OS Flags		= MAX ONSCREEN OPTIONS;
 vector Menu Level OS Attr		= MAX LEVELS IN SHOW;
 vector Menu Level OS Mask		= MAX LEVELS IN SHOW;
 vector Menu Level OS Low		= MAX LEVELS IN SHOW;
 vector Menu Level OS High		= MAX LEVELS IN SHOW;
 vector Menu Level OS X 		= MAX LEVELS IN SHOW;
 vector Menu Level OS Y 		= MAX LEVELS IN SHOW;
 vector Menu Level Bounds		= 4;
 vector Menu Option Bounds		= 4;
 vector Menu Option Hotspot		= 5;

    (file selectors)
	FS On				= 1;
	FS Get First			= 1;
	FS Get Next			= 1;
	Number of dirs in table 	= 1;
	Number of files in table	= 1;
	Number of FS objects in show	= 1;
	FT Char1			= 1;
	FT Char2			= 1;
	FT Bubble Flag			= 1;
	FNB Option ID			= 1;
 vector FS Body Bounds			= 4;
 vector FS Text Region			= 4;
 vector FSTF				= 7;
 vector Selected File Name		= 511;
 vector File name box buffer		= 256;
	Best FSIS match index		= 1;
	Best FSIS match size		= 1;
 vector File indexs table		= MAX FILES IN SELECTOR;
 vector File names table		= 256 multiplied MAX FILES IN SELECTOR;
	Startup Directory		= 256;
	Prefileselect Directory 	= 256;

    (text fields)
	CTF Fake Retrace		= 1;
 vector CTF Cursor			= 4;

    (text fields' selections)
	CTF Selection Buffer		= 1;
	CTF Selection Buffer Size	= 1;
	CTF Start Selecting At		= 1;
	CTF Stop Selecting At		= 1;
	CTF Selection Start		= 1;
	CTF Selection Stop		= 1;

    (questions)
	Width Of Question Form		= 1;
	Height Of Question Form 	= 1;
	Height Of Question Body 	= 1;
	Q Datascript ptr		= 1;
	Q String ptr			= 1;
	Q Options Count 		= 1;
	Q Current option to check for	= 1;
	Q Remaining options to check for= 1;
	Q Fields Count			= 1;
	Q Selected Field		= 1;
	Q Examined Field		= 1;
	Q Field To Retrace		= 1;
	Q Quit				= 1;
 vector Question Form Bounds		= 4;
 vector Q Whole Display Bounds		= 4;
 vector Q Test Text Box 		= 4;
 vector Q Field Title			= MAX FIELDS IN QUESTION;
 vector Q Field Classification		= MAX FIELDS IN QUESTION;
 vector Q Field Buffer			= MAX FIELDS IN QUESTION;
 vector Q Field Buffer Size		= MAX FIELDS IN QUESTION;
 vector Q Field Content Width		= MAX FIELDS IN QUESTION;
 vector Q Field Title Width		= MAX FIELDS IN QUESTION;
 vector Q Field Displacement		= MAX FIELDS IN QUESTION;
 vector Q Fields Data			= 7 mtp MAX FIELDS IN QUESTION;
 vector Q Fields Hotspot		= 5 mtp MAX FIELDS IN QUESTION;
 vector Q Options Data			= 7 mtp MAX OPTIONS IN QUESTION plus 1;

    (related to tracing shadows behind menus and dialogs)
	Shadow Layer Mask		= 1;
	SL X Start			= 1;
	SL Y Start			= 1;
	SL X End			= 1;
	SL Y End			= 1;
	SL X Delta			= 1;
	SL Y Delta			= 1;

    (tools bar)
	Tools Bar Active		= 1;
	Installed Tools Bar Options	= 1;
	Installed Tools Pointers	= 256;
	Installed Tools Hotspot Flags	= 256;
	UT Bounds			= 5;
	UT Shadow Bounds		= 4;
	UT Datascript Pointer		= 1;
	UT Copy tip			= 1;
	UT Color			= 1;
	UT Effect			= 1;
	UT Pixel Pointer		= 1;
	UT Scanlines			= 1;
	Currently examined tool 	= 1;

    (scrollers)
	Scroller Direction		= 1;
	Scroller Variation Flag 	= 1;
	Scrollpad Bounds		= 4;
	DS Shadow Bounds		= 4;
	DS Refresh			= 1;
	DS Pad Hole			= 1;
	DS Pad Hole Shadow		= 1;
	CS Range			= 1;
	CS Gap				= 1;
	CSD Pad Update Flag		= 1;
	Scroller adv ticks elapse	= 1;
	Scroller adv ticks former	= 1;

    (skin exchanger)
	SX Pointers			= 0;
	p Exit Button Shape		= 1;
	p Slep Button Shape		= 1;
	p Fold Button Shape		= 1;
	p Maxi Button Shape		= 1;
	p Full Button Shape		= 1;
	p Size Button Shape		= 1;
	p Logo Shape			= 1;
	Pointer To Arrow Shape		= 1;
	Pointer To Arrow Shadow 	= 1;
	p Window Caption		= 1;
	p Menu Filler			= 1;
	p Menu Shadow Top Corner	= 1;
	p Menu Shadow Left Corner	= 1;
	p Menu Shadow BottomRightCorner = 1;
	p Menu Shadow Horizontal	= 1;
	p Menu Shadow Vertical		= 1;
	p Dialog Filler 		= 1;
	p Tools Bar Filler		= 1;
	p Tools Bar Button		= 1;
	p H Scroller Track		= 1;
	p H Scroller Pad		= 1;
	p V Scroller Track		= 1;
	p V Scroller Pad		= 1;

"programme"

    (public)

    (initializes the integrated GUI: as a safe way to use the iGUI, this
     might be the very first thing an iGUI client does, that is, calling
     this function, which has no parameters)

"Initialize Integrated GUI"
      ? [Init OK] = YES -> IIG Already;
	[Display Origin] = Primary Display;
	[DraggingPad] = vector Title Bar Bounds;
	=> Load Resident Graphics;
	[File Command] = GET DIR;
	[File Name] = Startup Directory;
	isocall;
	[Init OK] = YES;
      "IIG Already"
	=> Refresh Display;
	leave;

    (between a call to "Initialize Integrated GUI" and "Enter Integrated
     GUI", there may be some application-specific initialization code;
     when the application finished initializing, it should enter this loop
     and, when the loop returns, the application simply terminates: this is
     pratically the iGUI's internal control loop, which also periodically
     calls the application control loop)

"Enter Integrated GUI"
	=> Initialize Integrated GUI;
	[Arrow Presence]+;
	[Quit Now] = NO;

    "Wait User Input"
	=> Begin Control Loop;

		[Client Owns Mouse Pointer] = YES;
	      ? [Pointer Status] + PD IN SIGHT -> Pointing Device cursor is hovering this programs window;
		[Client Owns Mouse Pointer] = NO;
		[Balloon Text String] = NULL;
	      "Pointing Device cursor is hovering this programs window"

		[Client Owns Text Cursor] = YES;
	      ? [Display Status] + ACTIVE -> Input focus is set to this programs window;
		[Client Owns Text Cursor] = NO;
	      "Input focus is set to this programs window"

	      ? [Pointer X Coordinate] < [vector Work Area plus 0] -> Pointer is out of work area so client doesnt own it;
	      ? [Pointer Y Coordinate] < [vector Work Area plus 1] -> Pointer is out of work area so client doesnt own it;
	      ? [Pointer X Coordinate] > [vector Work Area plus 2] -> Pointer is out of work area so client doesnt own it;
	      ? [Pointer Y Coordinate] > [vector Work Area plus 3] -> Pointer is out of work area so client doesnt own it;
		-> Pointer is inside work area so client still owns it;
	      "Pointer is out of work area so client doesnt own it"
		[Client Owns Mouse Pointer] = NO;
	      "Pointer is inside work area so client still owns it"

		[Hot Spot Data] = vector Title Bar Bounds;
		[While Hovering] = NULL;
		[When Hovering] = service When Hovering Title Bar;
		[When No Longer Hovering] = service When No Longer Hovering Title Bar;
		[When Pushing] = NULL;
		[When No Longer Pushing] = NULL;
		=> Check Hot Spot;

	      ? [Fold Is Active] = YES -> Cant use pulldown menus; (...when the display has been fold)
	      ? [Lock On Scroller] = [vector FS Scroller] -> Cant use pulldown menus; (...while scrolling a file selector)
		[ekey session id] = 19010002;
		=> negotiate ekey session;
	      ? failed -> skip session 19010002;
		[key f10    server] = service F10 Menu Activation;
		[key down   server] = service KDriven Menu Next;
		[key up     server] = service KDriven Menu Prev;
		[key return server] = service KDriven Menu Action;
		=> serve enhanced keystrokes;
		=> quit ekey session;
	      "skip session 19010002"
		[Hot Spot Data] = vector Menu Button Hotspot;
		[While Hovering] = NULL;
		[When Hovering] = service When Hovering Menu Button;
		[When No Longer Hovering] = service When No Longer Hovering Menu Button;
		[When Pushing] = service When Pushing Menu Button;
		[When No Longer Pushing] = service Menu Button Action;
		=> Check Hot Spot;
		A = [OnScreen Menu Options];
	    "Checking OnScreen Menu Options"
		A -;
	      ? A < ZERO -> No more options;
		[Examined Option] = A;
		B = vector Menu Option Hotspot;
		[B plus 0] = [A plus vector Menu Option OS X];
		[B plus 1] = [A plus vector Menu Option OS Y];
		[B plus 2] = [A plus vector Menu Option OS X];
		[B plus 3] = [A plus vector Menu Option OS Y];
		[B plus 2] + [A plus vector Menu Option OS W];
		[B plus 2] -;
		[B plus 3] + [A plus vector Menu Option OS H];
		[B plus 3] -;
		[B plus 4] = [A plus vector Menu Option OS Flags];
	      ? [A plus vector Menu Option OS Flags] - IS FIRST OPTION IN LEVEL -> COSMO Not 1st;
		[B plus 1] - [Menu Borders];
	      "COSMO Not 1st"
	      ? [A plus vector Menu Option OS Flags] - IS LAST OPTION IN LEVEL -> COSMO Not last;
		[B plus 3] + [Menu Spacing];
		[B plus 3] + [Menu Borders];
		[B plus 3] +;
	      "COSMO Not last"
		[Hot Spot Data] = vector Menu Option Hotspot;
		[While Hovering] = service While Hovering Menu Option;
		[When Hovering] = service When Hovering Menu Option;
		[When No Longer Hovering] = service When No Longer Hovering Menu Option;
		[When Pushing] = service When Pushing Menu Option;
		[When No Longer Pushing] = service Menu Option Action;
	      ? [A plus vector Menu Option OS Attr] - OPTION TYPE DISABLED -> COSMO Enabled option;
		[When Hovering] = NULL;
		[When No Longer Hovering] = NULL;
		[When Pushing] = NULL;
		[When No Longer Pushing] = NULL;
	      "COSMO Enabled option"
		=> Check Hot Spot;
		A = [Examined Option];
		B = vector Menu Option Hotspot;
		[A plus vector Menu Option OS Flags] = [B plus 4];
	      ? [Menu On] = NO -> No more options;
		-> Checking OnScreen Menu Options;
	      "No more options" (or) "Cant use pulldown menus"

	      ? [FS On] = NO -> File selector inactive; (because no file selector in show)
	      ? [Fold Is Active] = YES -> File selector inactive; (because the window is fold)
	      ? [Lock On Scroller] = [vector FS Scroller] -> Pointer locked to FS scroller;
		A = vector FS Scroller;
	      ? [Pointer X Coordinate] < [A plus 1] -> Pointing out of FS scroller;
	      ? [Pointer X Coordinate] > [A plus 3] -> Pointing out of FS scroller;
	      ? [Pointer Y Coordinate] < [A plus 2] -> Pointing out of FS scroller;
	      ? [Pointer Y Coordinate] > [A plus 4] -> Pointing out of FS scroller;
	      "Pointer locked to FS scroller"
		[Client Owns Mouse Pointer] = NO;
		[Balloon Text String] = NULL;
	      "Pointing out of FS scroller"
		[Scroller Datascript] = vector FS Scroller;
		=> Check Scroller;
	      ? [Scroller Variation Flag] = NO -> FS Scroller is in same position;
		=> PBL Redraw menu;
		[L2L Region] = vector FS Body Bounds;
		=> Update Area;
	      "FS Scroller is in same position"
		[Client Owns Text Cursor] = NO;
		[Text Field Data] = vector FSTF;
		[Text Field Size] = 256;
		[Text Field Buffer] = vector File name box buffer;
		[On Change] = service On Change of file name box;
		[On Return] = NULL;
		[On Escape] = NULL;
		[On Tabstp] = NULL;
		[Is Active Text Field] = YES;
		[Text Field Behavior] = TXF NOREDRAW plus TXF NOUPDATE;
		=> Check Text Field;
	      "File selector inactive"

	      ? [Menu On] = YES -> No further tools;
	      ? [Fold Is Active] = YES -> No further tools;
	      ? [Tools Bar Active] = NO -> No further tools;
		[UT Bounds plus 0] = [vector Tools Bar Bounds plus 0];
		[UT Bounds plus 1] = [vector Tools Bar Bounds plus 1];
		[UT Bounds plus 2] = [UT Bounds plus 0]; [UT Bounds plus 2] + 23;
		[UT Bounds plus 3] = [UT Bounds plus 1]; [UT Bounds plus 3] + 23;
		A = ZERO;
	      "Check tools"
	      ? A >= [Installed Tools Bar Options] -> No further tools;
	      ? [UT Bounds plus 2] >= [Display Width] -> No further tools;
	      ? [A plus Installed Tools Pointers] = TOOLS BAR SEPARATOR -> Manage separator;
		[Hot Spot Data] = UT Bounds;
		[When Hovering] = service When Hovering Tool;
		[While Hovering] = NULL;
		[When No Longer Hovering] = service When No Longer Hovering Tool;
		[When Pushing] = service When Pushing Tool;
		[When No Longer Pushing] = service Tool Action;
		[UT Bounds plus 4] = [A plus Installed Tools Hotspot Flags];
		[Currently examined tool] = A; A -->; => Check Hot Spot; <-- A;
		[A plus Installed Tools Hotspot Flags] = [UT Bounds plus 4];
		[UT Bounds plus 0] + 24;
		[UT Bounds plus 2] + 24;
		A+; -> Check tools;
	      "Manage separator"
		[UT Bounds plus 0] + 4;
		[UT Bounds plus 2] + 4;
		A+; -> Check tools;
	      "service When Hovering Tool"
		A = [Currently examined tool];
		[UT Datascript pointer] = [A plus Installed Tools Pointers];
		[Rectangle Gradients] = vector Tool Hovering Gradients;
		[Rectangle Effect] = service FX Alpha Light;
		[UT Copy tip] = YES;
		=> Update Tool;
		[Balloon Text String] = vector Tool Tip;
		[Tool Tip Identity] = [Currently examined tool];
		leave;
	      "service When No Longer Hovering Tool"
		A = [Currently examined tool];
		[UT Datascript pointer] = [A plus Installed Tools Pointers];
		[Rectangle Gradients] = NULL;
		[UT Copy tip] = NO;
		=> Update Tool;
	      ? [Tool Tip Identity] != [Currently examined tool] -> WNLHT Do not remove tooltip;
		[Balloon Text String] = NULL;
		[Tool Tip Identity] = UNDEFINED;
	      "WNLHT Do not remove tooltip"
		leave;
	      "service When Pushing Tool"
		A = [Currently examined tool];
		[UT Datascript pointer] = [A plus Installed Tools Pointers];
		[Rectangle Gradients] = vector Tool Pushing Gradients;
		[Rectangle Effect] = service FX Alpha Dim;
		[UT Copy tip] = NO;
		-> Update Tool;
	      "service Tool Action"
		=> service When Hovering Tool;
		[Balloon Text String] = NULL;
		[Tool Tip Identity] = UNDEFINED;
		A = [Currently examined tool];
		A = [A plus Installed Tools Pointers];
	      ? A = NULL -> TA Greyed;
		=> [A];
	      "TA Greyed"
		leave;
	      "No further tools"

	      ? [Fold Is Active] = YES -> It is not recommended to activate exit button when fold;
	      (exit button control)
		[Hot Spot Data] = vector Exit Button Hotspot;
		[While Hovering] = NULL;
		[When Hovering] = service When Hovering Exit Button;
		[When No Longer Hovering] = service When No Longer Hovering Exit Button;
		[When Pushing] = service When Pushing Exit Button;
		[When No Longer Pushing] = service Exit Button Action;
		=> Check Hot Spot;
	      (keyboard-driven quit hook, using... oh, well, ALT+F4, why not?)
		[ekey session id] = 19010003;
		=> negotiate ekey session;
	      ? failed -> skip session 19010003;
		[key f4 server] = service KD Quit hook;
		=> serve enhanced keystrokes;
		=> quit ekey session;
		-> skip session 19010003;
	      "service KD Quit hook"
	      ? [KEY ALTERNATE] = OFF -> KDQH F4 alone means nothing to me;
		[Quit Now] = YES;
	      "KDQH F4 alone means nothing to me"
		leave;
	      "skip session 19010003"
	      "It is not recommended to activate exit button when fold"

		[Hot Spot Data] = vector Fold Button Hotspot;
		[While Hovering] = NULL;
		[When Hovering] = service When Hovering Fold Button;
		[When No Longer Hovering] = service When No Longer Hovering Fold Button;
		[When Pushing] = service When Pushing Fold Button;
		[When No Longer Pushing] = service Fold Button Action;
		=> Check Hot Spot;

		[Hot Spot Data] = vector Slep Button Hotspot;
		[While Hovering] = NULL;
		[When Hovering] = service When Hovering Slep Button;
		[When No Longer Hovering] = service When No Longer Hovering Slep Button;
		[When Pushing] = service When Pushing Slep Button;
		[When No Longer Pushing] = service Slep Button Action;
		=> Check Hot Spot;

		[Hot Spot Data] = vector Maxi Button Hotspot;
		[While Hovering] = NULL;
		[When Hovering] = service When Hovering Maxi Button;
		[When No Longer Hovering] = service When No Longer Hovering Maxi Button;
		[When Pushing] = service When Pushing Maxi Button;
		[When No Longer Pushing] = service Maxi Button Action;
		=> Check Hot Spot;

		[Hot Spot Data] = vector Full Button Hotspot;
		[While Hovering] = NULL;
		[When Hovering] = service When Hovering Full Button;
		[When No Longer Hovering] = service When No Longer Hovering Full Button;
		[When Pushing] = service When Pushing Full Button;
		[When No Longer Pushing] = service Full Button Action;
		=> Check Hot Spot;

		A = MINIMUM WIDTH;
		B = MINIMUM HEIGHT;
		? A != MAXIMUM WIDTH  -> Size Button May Be Used;
		? B != MAXIMUM HEIGHT -> Size Button May Be Used;
		-> Cant Use Size Button If Display Isnt Intended To Be Resized;
		"Size Button May Be Used"
		? [Fold Is Active] = YES -> Cant Use Size Button When Fold;
		? [Display Status] + EXCLUSIVE -> Cant Use Size Button When In Exclusive Mode;
			[Hot Spot Data] = vector Size Button Hotspot;
			[While Hovering] = NULL;
			[When Hovering] = service When Hovering Size Button;
			[When No Longer Hovering] = service When No Longer Hovering Size Button;
			[When Pushing] = service When Pushing Size Button;
			[When No Longer Pushing] = NULL;
			=> Check Hot Spot;
		"Cant Use Size Button When Fold"
		"Cant Use Size Button When In Exclusive Mode"
		"Cant Use Size Button If Display Isnt Intended To Be Resized"

		? [Fold Is Active] = NO -> Show active exit button;
		? [Fold Is Active] = YES -> Show inactive exit button;
		"Get back to main loop L0"

		? [Display Status] + ACTIVE -> Show active title bar;
		? [Display Status] - ACTIVE -> Show inactive title bar;
		"Get back to main loop L1"

		? [Fold Is Active] = NO -> Show active menu button;
		? [Fold Is Active] = YES -> Show inactive menu button;
		"Get back to main loop L2"

		? [Fold Is Active] = YES -> Show inactive size button;
		? [Display Status] + EXCLUSIVE -> Show inactive size button;
		-> Show active size button;
		"Get back to main loop L3"

		? [Client Owns Mouse Pointer] = NO -> GUI Owns mouse pointer;
			? [Menu On] = NO -> GUI still owning menu;
			? [Pointer Status] - PD LEFT BUTTON DOWN plus PD RIGHT BUTTON DOWN -> GUI still owning menu;
				[FS On] = NO;
				[Menu On] = NO;
				=> Reset Pulldown Menu;
				=> Refresh Display;
			"GUI still owning menu"
		"GUI Owns mouse pointer"

		? [Control Loop] = NULL -> No caller control loop specified;
		=> [Control Loop];
		"No caller control loop specified"

	=> End Control Loop;
	? [Quit Now] = YES -> GUI Returns to caller; (else) -> Wait User Input;

    "Show active exit button"
	? [Exit Shown As Active] = YES -> Get back to main loop L0;
	[Rectangle Gradients] = NULL;
	=> Update Exit Button Appearence;
	[Exit Shown As Active] = YES;
	-> Get back to main loop L0;

    "Show inactive exit button"
	? [Exit Shown As Active] = NO -> Get back to main loop L0;
	[Rectangle Gradients] = vector Inactive Button Colors;
	[Rectangle Effect] = [Inactive Button Effect];
	=> Update Exit Button Appearence;
	[Exit Shown As Active] = NO;
	-> Get back to main loop L0;

    "Show active title bar"
	? [Title Shown As Active] = YES -> Get back to main loop L1;
	=> Update Title Bar;
	[Title Shown As Active] = YES;
	-> Get back to main loop L1;

    "Show inactive title bar"
	? [Title Shown As Active] = NO -> Get back to main loop L1;
	=> Update Title Bar;
	[Title Shown As Active] = NO;
	-> Get back to main loop L1;

    "Show active menu button"
	? [Menu Shown As Active] = YES -> Get back to main loop L2;
	[Rectangle Gradients] = NULL;
	=> Internal Update Menu Button Appearence;
	[Menu Shown As Active] = YES;
	-> Get back to main loop L2;

    "Show inactive menu button"
	? [Menu Shown As Active] = NO -> Get back to main loop L2;
	[Rectangle Gradients] = vector Inactive Button Colors;
	[Rectangle Effect] = [Inactive Button Effect];
	=> Internal Update Menu Button Appearence;
	[Menu Shown As Active] = NO;
	-> Get back to main loop L2;

    "Show active size button"
	? [Size Shown As Active] = YES -> Get back to main loop L3;
	[Rectangle Gradients] = NULL;
	=> Update Size Button Appearence;
	[Size Shown As Active] = YES;
	-> Get back to main loop L3;

    "Show inactive size button"
	? [Size Shown As Active] = NO -> Get back to main loop L3;
	[Rectangle Gradients] = vector Inactive Button Colors;
	[Rectangle Effect] = [Inactive Button Effect];
	=> Update Size Button Appearence;
	[Size Shown As Active] = NO;
	-> Get back to main loop L3;

    "GUI Returns to caller"
	leave;

    "service On Change of file name box"
      ? [vector File name box buffer] = ZERO -> CFNB no incremental search match;
      ? [Number of files in table] = ZERO -> CFNB no incremental search match;
	A = ZERO;
	[Best FSIS match size] = ZERO;
      "CFNB search loop"
	B = [A plus vector File indexs table];
	B < 8; B + vector File names table;
	C = ZERO;
      "CFNB compare loop"
      ? [B] = ZERO -> CFNB compare stop;
      ? [C relating vector File name box buffer] = ZERO -> CFNB compare stop;
	D = [B];
	E = [C relating vector File name box buffer];
      ? D < 65 -> CFNB c1 right case;
      ? D > 90 -> CFNB c1 right case;
	D + 32;
      "CFNB c1 right case"
      ? E < 65 -> CFNB c2 right case;
      ? E > 90 -> CFNB c2 right case;
	E + 32;
      "CFNB c2 right case"
      ? D != E -> CFNB compare stop;
	B +;
	C +;
	-> CFNB compare loop;
      "CFNB compare stop"
      ? C <= [Best FSIS match size] -> CFNB no best match;
	[Best FSIS match index] = A;
	[Best FSIS match size]	= C;
      ? [C minus 1 relating vector File name box buffer] = ZERO -> CFNB no further search;
      "CFNB no best match"
	A +;
      ? A < [Number of files in table] -> CFNB search loop;
      "CFNB no further search"
      ? [Best FSIS match size] = ZERO -> CFNB no incremental search match;
	A = [Best FSIS match index];
	B = [SCROLLER SCOPE relating vector FS Scroller];
	B - [SCROLLER WINDOW relating vector FS Scroller];
      ? A < B -> CFNB position over match;
	A = B;
      "CFNB position over match"
      ? [SCROLLER READOUT relating vector FS Scroller] = A -> CFNB no incremental search match;
	[SCROLLER READOUT relating vector FS Scroller] = A;
	[Scroller Datascript] = vector FS Scroller;
	=> Update Scroller Position From Readout;
      "CFNB no incremental search match"
	=> PBL Redraw menu;
	[L2L Region] = vector FS Body Bounds;
	=> Update Area;
	A = [FNB Option ID];
	[A relating vector Menu Option OS Flags] | IHS Set Hover;
	=> FMM To Option A;
	[Last Lit Option] = UNDEFINED;
	[Balloon Text String] = NULL;
	[Is Menu Balloon] = NO;
	leave;

    (this function gathers informations about the current pointer position
     and stores them for later processing: it is automatically called along
     with "End Control Loop" in the iGUI's main control loop [above] - but
     if your application is setting up alternative loops, it might call both
     these functions while it waits for some event to happen; an example of
     this behaviour can be found in the network node's souce code, in file
     "node.txt", where there are such loops while waiting for a host name or
     address to be resolved; bulding a loop this way only allows to:
       - move the pointer around;
       - drag the window;
       - delay the application for the given time slice.
     ...pratically, this behaviour, where other iGUI controls are unreactive,
     is similar to what GUI-driven OS'es do while showing the "wait" cursor:
     the application temporarily enters such loops while waiting for internal
     processes to complete their tasks, specially when such processes should
     not be influenced or interrupted by other commands coming from the pull-
     down menu, from the tools bar, etc...)

"Begin Control Loop"
	[Arrow X In Previous Frame]  = [Arrow X In This Frame];
	[Arrow Y In Previous Frame]  = [Arrow Y In This Frame];
	[Arrow Region Left Before]   = [Arrow Region Left Now];
	[Arrow Region Top Before]    = [Arrow Region Top Now];
	[Arrow Region Right Before]  = [Arrow Region Right Now];
	[Arrow Region Bottom Before] = [Arrow Region Bottom Now];
	[iGUIcc Wheel Knot Before]   = [iGUIcc Wheel Knot Actual];
	[Pointer Command] = READ POINTER;
	isocall;
	[Arrow X In This Frame] = [Pointer X Coordinate]; [Arrow X In This Frame] - [Arrow Hot Spot X];
	[Arrow Y In This Frame] = [Pointer Y Coordinate]; [Arrow Y In This Frame] - [Arrow Hot Spot Y];
	[iGUIcc Wheel Knot Actual] = [Pointer Z Coordinate];
	A = [Arrow X In This Frame];
	B = [Arrow Y In This Frame];
	A / [Arrow Altitude Over Background];
	B / [Arrow Altitude Over Background];
	A + [Horizontal Arrow Shadow Drift];
	B + [Vertical Arrow Shadow Drift];
	A + [Arrow X In This Frame];
	B + [Arrow Y In This Frame];
	[Arrow Shadow X In This Frame] = A;
	[Arrow Shadow Y In This Frame] = B;
	? [Control Loop Idle Slice] = ZERO -> BCL J00;
	[Process Command] = SLEEP;
	[Sleep Timeout] = [Control Loop Idle Slice];
	isocall;
    "BCL J00"
	leave;

    (counterpart of "Begin Control Loop", it parses the informations from
     there, retraces the mouse cursor, and calls the function that allows
     the user to drag the display window)

"End Control Loop"
	? [Arrow Presence] >= ZERO -> ECL J00;
	leave;
    "ECL J00"
	[Arrow Region Left Now] = [Arrow X In This Frame];
	A = [Arrow Shadow X In This Frame];
	? [Arrow Shadow X In This Frame] >= [Arrow X In This Frame] -> ECL J01;
	[Arrow Region Left Now] = [Arrow Shadow X In This Frame];
	A = [Arrow X In This Frame];
    "ECL J01"
	[Arrow Region Top Now] = [Arrow Y In This Frame];
	B = [Arrow Shadow Y In This Frame];
	? [Arrow Shadow Y In This Frame] >= [Arrow Y In This Frame] -> ECL J02;
	[Arrow Region Top Now] = [Arrow Shadow Y In This Frame];
	B = [Arrow Y In This Frame];
    "ECL J02"
	C = [Arrow Region Width];
	? [Arrow Shadow Region Width] <= C -> ECL J03;
	C = [Arrow Shadow Region Width];
    "ECL J03"
	D = [Arrow Region Height];
	? [Arrow Shadow Region Height] <= D -> ECL J04;
	D = [Arrow Shadow Region Height];
    "ECL J04"
	[Arrow Region Right Now] = A; [Arrow Region Right Now] + C;
	[Arrow Region Bottom Now] = B; [Arrow Region Bottom Now] + D;
    "ECL J05"
	? [Balloon Text String] = NULL -> ECL J15;
	? [Fold Is Active] = YES -> ECL J15;
	[Balloon Window Left]	= [Balloon Text Padding];
	[Balloon Window Left]	+ [Balloon Border];
	[Balloon Window Left]	+;
	[Balloon Window Top]	= [Balloon Text Padding];
	[Balloon Window Top]	+ [Balloon Border];
	[Balloon Window Top]	+;
	[Balloon Window Right]	= [Balloon Wraparound Margin];
	[Balloon Window Right]	+ [Balloon Text Padding];
	[Balloon Window Right]	+ [Balloon Border];
	[Balloon Window Right]	+ [Balloon Text Padding];
	[Balloon Window Right]	+ [Balloon Border];
	[Balloon Window Right]	+;
	[Balloon Window Bottom] = [Display Height];
	[String] = [Balloon Text String];
	[Text X] = 0;
	[Text Y] = 0;
	[Text Display Width] = [Display Width];
	[Text Display Height] = [Display Height];
	[Text Window] = Balloon Window Left;
	[Text Word Wrap] = ON;
	[Text Ghost Mode] = ON;
	=> STD Write;
	[Balloon Left]	 = [Arrow X In This Frame];
	[Balloon Left]	 + [Balloon relative X Position];
	[Balloon Top]	 = [Arrow Y In This Frame];
	[Balloon Top]	 + [Balloon relative Y Position];
	[Balloon Width]  = [Width Of Latest Form];
	[Balloon Width]  + [Balloon Text Padding];
	[Balloon Width]  + [Balloon Text Padding];
	[Balloon Width]  + [Balloon Border];
	[Balloon Width]  + [Balloon Border];
	[Balloon Height] = [Height Of Latest Form];
	[Balloon Height] + [Balloon Text Padding];
	[Balloon Height] + [Balloon Text Padding];
	[Balloon Height] + [Balloon Border];
	[Balloon Height] + [Balloon Border];
	A = [Balloon Left]; A + [Balloon Width];
	? A < [Display Width] -> ECL J06;
	[Balloon Left] = [Display Width];
	[Balloon Left] - [Balloon Width];
    "ECL J06"
	A = [Balloon Top]; A + [Balloon Height];
	? A < [Display Height] -> ECL J07;
	[Balloon Top] = [Display Height];
	[Balloon Top] - [Balloon Height];
    "ECL J07"
	? [Tools Bar Active]  = NO	  -> ECL J08;
	? [Tool Tip Identity] = UNDEFINED -> ECL J08;
	[Balloon Top] - 33;
    "ECL J08"
	? [Balloon Left] >= ZERO -> ECL J09;
	[Balloon Left] = ZERO;
    "ECL J09"
	? [Balloon Top] >= ZERO -> ECL J10;
	[Balloon Top] = ZERO;
    "ECL J10"
	[Balloon Right]  = [Balloon Left];
	[Balloon Right]  + [Balloon Width];
	[Balloon Bottom] = [Balloon Top];
	[Balloon Bottom] + [Balloon Height];
	[Region To Normalize] = Balloon Left;
	=> Normalize Region;
	[Balloon Window Left]	+ [Balloon Left];
	[Balloon Window Top]	+ [Balloon Top];
	[Balloon Window Right]	+ [Balloon Left];
	[Balloon Window Bottom] + [Balloon Top];
    "ECL J11"
	[Balloon Left] - 2;
	? [Balloon Left] > [Arrow Region Left Now] -> ECL J12;
	[Arrow Region Left Now] = [Balloon Left];
    "ECL J12"
	[Balloon Left] + 2;
	[Balloon Top] - 2;
	? [Balloon Top] > [Arrow Region Top Now] -> ECL J13;
	[Arrow Region Top Now] = [Balloon Top];
    "ECL J13"
	[Balloon Top] + 2;
	[Balloon Right] + 2;
	? [Balloon Right] < [Arrow Region Right Now] -> ECL J14;
	[Arrow Region Right Now] = [Balloon Right];
    "ECL J14"
	[Balloon Right] - 2;
	[Balloon Bottom] + 2;
	? [Balloon Bottom] < [Arrow Region Bottom Now] -> ECL J15;
	[Arrow Region Bottom Now] = [Balloon Bottom];
    "ECL J15"
	[Balloon Bottom] - 2;
	[Arrow Coverage Left] = [Arrow Region Left Now];
	? [Arrow Coverage Left] < [Arrow Region Left Before] -> ECL J16;
	[Arrow Coverage Left] = [Arrow Region Left Before];
    "ECL J16"
	[Arrow Coverage Top] = [Arrow Region Top Now];
	? [Arrow Coverage Top] < [Arrow Region Top Before] -> ECL J17;
	[Arrow Coverage Top] = [Arrow Region Top Before];
    "ECL J17"
	[Arrow Coverage Right] = [Arrow Region Right Now];
	? [Arrow Coverage Right] > [Arrow Region Right Before] -> ECL J18;
	[Arrow Coverage Right] = [Arrow Region Right Before];
    "ECL J18"
	[Arrow Coverage Bottom] = [Arrow Region Bottom Now];
	? [Arrow Coverage Bottom] > [Arrow Region Bottom Before] -> ECL J19;
	[Arrow Coverage Bottom] = [Arrow Region Bottom Before];
    "ECL J19"
	[Region To Normalize] = Arrow Coverage Left;
	=> Normalize Region;
	[Source Layer] = Backdrop Layer;
	[Destination Layer] = [Display Origin];
	[L2L Region] = Arrow Coverage Left;
	=> Copy L2L Region;
    "ECL J20"
	[TGA Display Alignment] = [Display Width];
	[TGA Display Height] = [Display Height];
    "ECL J21"
	? [Balloon Text String] = NULL -> ECL J22;
	? [Fold Is Active]	= YES  -> ECL J22;
	[Rectangle Target Layer] = [Display Origin];
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = Balloon Left;
	[Rectangle Gradients] = vector Balloon Border Colors;
	[Rectangle Effect] = [Balloon Border Effect];
	=> Rectangle;
	[Balloon Left] + [Balloon Border];
	[Balloon Top] + [Balloon Border];
	[Balloon Right] - [Balloon Border];
	[Balloon Bottom] - [Balloon Border];
	[Region To Normalize] = Balloon Left;
	=> Normalize Region;
	[Rectangle Target Layer] = [Display Origin];
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = Balloon Left;
	[Rectangle Gradients] = vector Balloon Background Shaders;
	[Rectangle Effect] = [Balloon Background Effect];
	=> Rectangle;
	[String] = [Balloon Text String];
	[Ink] = [Balloon Text Color];
	[Text X] = 0;
	[Text Y] = 0;
	[Text Effect] = [Balloon Text Effect];
	[Text Display Width] = [Display Width];
	[Text Display Height] = [Display Height];
	[Text Display Origin] = [Display Origin];
	[Text Region] = Balloon Left;
	[Text Window] = Balloon Window Left;
	[Text Word Wrap] = ON;
	[Text Ghost Mode] = OFF;
	=> STD Write;
    "ECL J22"
	? [Pointer To Arrow Shadow] = NULL -> ECL J23;
	[TGA Target Layer] = [Display Origin];
	[TGA Picture Data] = [Pointer To Arrow Shadow];
	[TGA Picture Left] = [Arrow Shadow X In This Frame];
	[TGA Picture Top] = [Arrow Shadow Y In This Frame];
	[TGA Effect] = [Arrow Shadow Effect];
	[FX Transparent Color] = [Arrow Shadow Transparent Color];
	=> Load TGA Picture;
    "ECL J23"
	? [Pointer To Arrow Shape] = NULL -> ECL J24;
	[TGA Target Layer] = [Display Origin];
	[TGA Picture Data] = [Pointer To Arrow Shape];
	[TGA Picture Left] = [Arrow X In This Frame];
	[TGA Picture Top] = [Arrow Y In This Frame];
	[TGA Effect] = [Arrow Shape Effect];
	[FX Transparent Color] = [Arrow Shape Transparent Color];
	=> Load TGA Picture;
    "ECL J24"
	? [Do Not Retrace Arrow Region] = YES -> ECL J25;
	[Display Command] = RETRACE;
	[Display Live Region] = Arrow Coverage Left;
	isocall;
    "ECL J25"
	-> Allow Display Dragging;

    (retraces all the contents of the display, both the iGUI's controls
     and the work area, and involves calling the "work area manager" as
     pointed by the application)

"Refresh Display"
      ? [RD Disable] = YES -> RD Idle;
	=> Prepare Backdrop Layer;
	[Source Layer] = Backdrop Layer;
	[Destination Layer] = Primary Display;
	=> Copy L2L;
	=> RD Retrace Arrow;
	[Display Command] = RETRACE;
	[Display Live Region] = WHOLE DISPLAY;
	isocall;
      "RD Idle"
	leave;
    (this is an anti-flickering routine: it only traces the arrow over
     the backdrop layer but without immediately updating the "primary
     display" layer and the visible screen, as "End Control Loop" would
     otherwise do without setting flag "Do Not Retrace Arrow Region":
     in effects, if the arrow wasn't there after a complete retrace or
     a retrace including the arrow's region, the arrow would flicker,
     such as when a file selector or a scroller is being used and keeps
     getting updated to scroll around, but since the arrow itself gets
     normally retraced by "End Control Loop", and since that routine is
     in fact called at the true end of an iGUI control loop, any shows
     of a portion of the display from the hidden frame buffer memory to
     the visible display BEFORE the call to "End Control Loop" would
     cause the display to get updated with an area that has got proper
     background graphics, but NO superimposed shapes such as the arrow
     and its eventual shadow; later, the display would get updated again
     when "End Control Loop" is called to retrace the "arrow region",
     the portion of the display that contains the arrow at that moment;
     in the end, rapidly repeating this for several times makes the arrow
     alternately absent and present on the display at update time, and it
     results in an annoying flickering mouse pointer, which I absolutely
     hate, and so I'm trying hard to find the best spots where it'd be
     better to call "RD Retrace Arrow", to keep flickering out of my GUI)
    "RD Retrace Arrow"
	[Do Not Retrace Arrow Region] -->;
	[Do Not Retrace Arrow Region] = YES;
	=> End Control Loop;
	[Do Not Retrace Arrow Region] <--;
	leave;

    (changes the display's dimensions to [New Display Width] and [New
     Display Height]; if the display is in full-screen mode, it is forced
     to swap to windowed mode again; such resizing normally happens via
     the "adjust size" button, but the application may force a resize to
     specific dimensions by calling this function; warning: resizing to a
     width below 272 pixels crashes the iGUI)

"Resize Display"
	? [Display Status] - EXCLUSIVE -> Resize from unfull; => AutoUnfull; "Resize from unfull"
	[Pointer Delta X] = [New Display Width]; [Pointer Delta X] - [Display Width];
	[Pointer Delta Y] = [Display Height]; [Pointer Delta Y] - [New Display Height];
	-> Things To Do While Resizing;

    (retraces the display's contents without updating the frame buffer
     "Primary Display", could be performed to update the contents of the
     "Backdrop Layer", a hidden frame buffer, without showing them)

"Prepare Backdrop Layer"
      ? [Always Clear Work Area] = NO -> WAM Cares For Clearing;
	[Destination Layer] = Backdrop Layer;
	[L2L Region Color] = ZERO;
	=> Clear L2L;
	-> PBL All Black;
      "WAM Cares For Clearing"
	[Destination Layer] = Backdrop Layer;
	[L2L Region Color]  = ZERO;
	[L2L Region]	    = vector iGUI Caption Bar;	      => Clear L2L Region;
	[L2L Region]	    = vector iGUI Window Left Edge;   => Clear L2L Region;
	[L2L Region]	    = vector iGUI Window Right Edge;  => Clear L2L Region;
	[L2L Region]	    = vector iGUI Window Bottom Edge; => Clear L2L Region;
      "PBL All Black"
      ? [Work Area Manager] = NULL -> WAM Not set;
	=> [Work Area Manager];
      "WAM Not set"
	[UA Disable] = YES;
	[Rectangle Gradients] = NULL; => Update Exit Button Appearence;
	[Rectangle Gradients] = NULL; => Update Slep Button Appearence;
	[Rectangle Gradients] = NULL; => Update Fold Button Appearence;
	[Rectangle Gradients] = NULL; => Update Maxi Button Appearence;
	[Rectangle Gradients] = NULL; => Update Full Button Appearence;
	[Rectangle Gradients] = NULL;
      ? [Menu Shown As Active] = YES -> PBL Menu Active;
	[Rectangle Gradients] = vector Inactive Button Colors;
	[Rectangle Effect] = [Inactive Button Effect];
      "PBL Menu Active"
	=> Internal Update Menu Button Appearence;
	[Rectangle Gradients] = NULL;
      ? [Size Shown As Active] = YES -> PBL Size Active;
	[Rectangle Gradients] = vector Inactive Button Colors;
	[Rectangle Effect] = [Inactive Button Effect];
      "PBL Size Active"
	=> Update Size Button Appearence;
	=> Update Title Bar;
	=> Update Tools Bar;
	=> PBL Redraw menu;
	[UA Disable] = NO;
	leave;

    (calling "Prepare Backdrop Layer" followed by this function pratically
     obtains the same effect as calling "Refresh Display"; this function,
     in facts, copies any changes made to "Backdrop Layer" to the visible
     frame buffer, "Primary Display", and onto the physical screen)

"Update Layers"
      ? [UL Disable] = YES -> UL Idle;
	[Source Layer]	      = Backdrop Layer;
	[Destination Layer]   = Primary Display;
	=> Copy L2L;
	[Display Command]     = RETRACE;
	[Display Live Region] = WHOLE DISPLAY;
	isocall;
      "UL Idle"
	leave;

    (does what "Update Layers" do, but only for an area restricted by the
     bounds of the rectangular region whose vector pointer has been loaded
     into [L2L Region]: faster if you changed something on the backdrop but
     the affected area is much smaller than the whole display, and updating
     all the display would be a significant waste of time)

"Update Area"
      ? [UA Disable] = YES -> UA Idle;
	[Source Layer]	      = Backdrop Layer;
	[Destination Layer]   = Primary Display;
	=> Copy L2L Region;
	[L2L Region] -->;
	=> RD Retrace Arrow;
	<-- [L2L Region];
	[Display Command]     = RETRACE;
	[Display Live Region] = [L2L Region];
	isocall;
      "UA Idle"
	leave;

    (retraces the title bar, typically after changing the pointer to the
     actual string to be written there, which is [Window Title])

"Update Title Bar"
	[TR Bounds]			= vector Title Bar Bounds;
	[TR Picture Data]		= [p Window Caption];
	[TR Target Layer]		= Backdrop Layer;
	[TR Display Alignment]		= [Display Width];
	[TR Effect]			= service FX Raw;
	=> Tile Region;
	[Rectangle Display Alignment]	= [Display Width];
	[Rectangle Bounds]		= vector Title Bar Bounds;
	[Rectangle Target Layer]	= Backdrop Layer;
	[Rectangle Effect]		= service FX Alpha Light;
	[Rectangle Gradients]		= vector Title Bar Active Colors;
	? [Display Status] + ACTIVE -> UTB Show as active;
	[Rectangle Gradients]		= vector Title Bar Inactive Colors;
    "UTB Show as active"
	=> Rectangle;
	A = [vector Title Bar Bounds plus 2];
	[vector Title Bar Bounds plus 2] = [vector Title Bar Bounds plus 0];
	[vector Title Bar Bounds plus 2] + 9;
	? [vector Title Bar Bounds plus 2] <= A -> UTB Shadow within limits;
	[vector Title Bar Bounds plus 2] = A;
    "UTB Shadow within limits"
	[TR Bounds] = vector Title Bar Bounds;
	[TR Picture Data] = [p Menu Shadow Vertical];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Alpha Dim;
	A -->;
	=> Tile Region;
	<-- [vector Title Bar Bounds plus 2];
	[String]			= [Window Title];
	[Ink]				= [Title Bar Text Color];
	[Text X]			= [vector Title Bar Bounds plus 0];
	[Text X]			+ 5;
	[Text Y]			= 5;
	[Text Effect]			= [Title Bar Text Effect];
	[Text Display Width]		= [Display Width];
	[Text Display Height]		= [Display Height];
	[Text Display Origin]		= Backdrop Layer;
	[Text Region]			= vector Title Bar Bounds;
	[Text Window]			= NULL;
	[Text Word Wrap]		= OFF;
	[Text Ghost Mode]		= OFF;
	=> STD Write;
	[L2L Region]			= vector Title Bar Bounds;
	-> Update Area;

    (retraces the menu button, typically after changing the pointer to the
     actual string to be written there, which is [Menu Caption])

"Update Menu Button Appearence"
	[Rectangle Gradients] = NULL;
	-> Internal Update Menu Button Appearence;

    (sends the application to "dormant state", while in this state, the
     control loop is no longer called; instead, [Sleepy Control Loop] is
     called to check for possible background processing; the application
     requires either the user to click on the "sleep" button of the
     iconized window, or an explicit call to "Now Unslep" for it to awake
     from this state)

"Now Slep"
	? [Fold Is Active] = NO -> Slep from unfold; => AutoUnfold; "Slep from unfold"
	? [Display Status] - EXCLUSIVE -> Slep from unfull; => AutoUnfull; "Slep from unfull"
	[Destination Layer] = Backdrop Layer;
	[L2L Region Color] = ZERO;
	=> Clear L2L;
	[Global K Command] = K READ;
	[Global K Name] = Sleepy Windows Key;
	[Global K Data] = Sleepy Windows Data;
	isocall;
	? ok -> One or more sleepy windows;
	[Sleepy Windows Data] = ZERO; (first unit is a counter)
    "One or more sleepy windows"
	[vector Slep Button plus 0] = 1;
	[vector Slep Button plus 2] = 23;
	[vector Slep Button Hotspot plus 0] = 0;
	[vector Slep Button Hotspot plus 2] = 24;
	[Previous display width] = [Display Width];
	[Previous display height] = [Display Height];
	[Previous display X position] = [Display X Position];
	[Previous display Y position] = [Display Y Position];
	[Previous thread priority] = [Priority];
	[Display Width] = 126;
	[Display Height] = 25;
	[Display X Position] = [Sleepy Display X Position];
	? [Display X Position] != UNDEFINED -> NS Sleepy X position defined;
	[Display X Position] = [Display Physical Width]; [Display X Position] - 127;
	A = [Display X Position]; A % 126; [Display X Position] - A;
    "NS Sleepy X position defined"
	[Display Y Position] = [Sleepy Display Y Position];
	? [Display Y Position] != UNDEFINED -> NS Sleepy Y position defined;
	[Display Y Position] = [Display Physical Height]; [Display Y Position] - 28;
	A = [Display Y Position]; A % 25; [Display Y Position] - A;
    "NS Sleepy Y position defined"
	A = Sleepy Windows Data plus 1;
	B = [Sleepy Windows Data];
	C = [Display Y Position]; C / 25; C * 100000; (arbitrary, max tiles in a row)
	D = [Display X Position]; D / 126; C + D; (C holds the actual "tile code")
	? B = ZERO -> NS Sleepy position available;
	? B >= 254 -> NS One too many;
      "NS Check other sleepies"
	? [A] = C -> NS Sleepy position in use;
	A+; B ^ NS Check other sleepies;
	-> NS Sleepy position available;
      "NS Sleepy position in use"
	? [Display Y Position] > ZERO -> NS Move up;
	[Display Y Position] = [Display Physical Height]; [Display Y Position] - 28;
	A = [Display Y Position]; A % 25; [Display Y Position] - A;
	? [Display X Position] = ZERO -> NS One too many;
       "NS Move left"
	[Display X Position] - 126;
	-> NS Sleepy Y position defined;
       "NS Move up"
	[Display Y Position] - 25;
	-> NS Sleepy Y position defined;
    "NS Sleepy position available"
	[A] = C;
	[Sleepy Windows Data]+;
	[Global K Command] = K WRITE;
	[Global K Name] = Sleepy Windows Key;
	[Global K Data] = Sleepy Windows Data;
    "NS One too many"
	isocall;
	[Sleepy Display X Position] = [Display X Position];
	[Sleepy Display Y Position] = [Display Y Position];
	=> NS Update Sleeping Title Bar;
	[DraggingPad] = vector Sleeping Title Bar Bounds;
	[Priority] = VERY LOW PRIORITY;
	isocall;
	-> SlepUnslep Rendezvous;
    "NS Update Sleeping Title Bar"
	[TR Bounds] = vector Sleeping Title Bar Bounds;
	[TR Picture Data] = [p Window Caption];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Raw;
	=> Tile Region;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector Sleeping Title Bar Bounds;
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Effect] = service FX Alpha Light;
	[Rectangle Gradients] = vector Title Bar Active Colors;
	=> Rectangle;
	[TR Bounds] = vector Sleeping Title Bar Shadow;
	[TR Picture Data] = [p Menu Shadow Vertical];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Alpha Dim;
	=> Tile Region;
	[RMC String] = [Small Caption];
	[RMC Region] = vector Sleeping Title Bar Bounds;
	-> Rewrite Menu Caption;

    (redisplays the small caption text, the string pointed by variable
     [Small Caption]: to be used in sleepy control loops when an application
     thinks it's a good idea to show some informations concerning background
     processing via the small caption, but the small caption is only 100
     pixels in width, and holds only 12 characters using the default font,
     so the said application might try and be concise)

"Update Sleepy Title Bar"
	=> NS Update Sleeping Title Bar;
	[L2L Region] = vector Sleeping Title Bar Bounds;
	-> Update Area;

    (recovers normal execution from "dormant state": ideally, it's never
     explicity called, but, only from inside the sleepy control loop, it
     may be, if the application is currently in that state but for some
     reason it requests attention/interaction from the user)

"Now Unslep"
	=> Find Sleepy Window Record;
	? failed -> No sleepy window record to remove;
    "Copyback sleepy window record"
	[A] = [A plus 1];
	A+; B ^ Copyback sleepy window record;
	[Sleepy Windows Data]-;
	[Global K Command] = K WRITE;
	[Global K Name] = Sleepy Windows Key;
	[Global K Data] = Sleepy Windows Data;
	? [Sleepy Windows Data] > ZERO -> Keep sleepy windows global k;
	[Global K Command] = K DESTROY;
      "Keep sleepy windows global k"
	isocall;
    "No sleepy window record to remove"
	[Priority] = [Previous thread priority];
	isocall;
	[vector Slep Button plus 0] = 25;
	[vector Slep Button plus 2] = 47;
	[vector Slep Button Hotspot plus 0] = 24;
	[vector Slep Button Hotspot plus 2] = 47;
	[Display Width] = [Previous display width];
	[Display Height] = [Previous display height];
	[Display X Position] = [Previous display X position];
	[Display Y Position] = [Previous display Y position];
	isocall;
	[DraggingPad] = vector Title Bar Bounds;
	=> Prepare Backdrop Layer;
	-> SlepUnslep Rendezvous;

    (simply folds the display window: execution continues, but remember
     that the display will be only 25 pixels tall, and will not show any
     changes below the window's caption area)

"Now Fold"
	? [Display Status] - EXCLUSIVE -> Fold from unfull;
	=> AutoUnfull;
    "Fold from unfull"
	[Previous display height] = [Display Height];
	[Display Height] = 25;
	isocall;
	[Fold Is Active] = YES;
	-> Update Layers;

    (unfolds the display window: conterpart of the above)

"Now Unfold"
	[Display Height] = [Previous display height];
	isocall;
	[Fold Is Active] = NO;
	-> Refresh Display;

    (simply sends the display to full-size: may be called at any time)

"Now Maxi" (also known as) "service Maxi Button Action"
	? [Fold Is Active] = NO -> Maxi from unfold;
	=> AutoUnfold;
    "Maxi from unfold"
	? [Display Status] - EXCLUSIVE -> Maxi from unfull;
	=> AutoUnfull;
    "Maxi from unfull"
	[Pointer Delta X] = MAXIMUM WIDTH; [Pointer Delta X] - [Display Width];
	[Pointer Delta Y] = [Display Height]; [Pointer Delta Y] - MAXIMUM HEIGHT;
	-> Things To Do While Resizing;

    (sends the display to full-screen mode: eventually, to change the target
     physical resolution, [Fullscreen Width] and [Fullscreen Height] may be
     loaded with values different from the default, default values being
     declared by the client along with that couple variables, or given by the
     window's full-size dimensions when using "defstyle.txt"; if the desired
     resolution can't be displayed by the hardware, the display will go back
     to windowed mode)

"Now Full"
	? [Fold Is Active] = NO -> Full from unfold;
	=> AutoUnfold;
    "Full from unfold"
    (always preserve latest position to return it there later, well, that is,
     except if the display is already in full-screen, where X;Y coordinates
     are always forcely zero)
	? [Display Status] + EXCLUSIVE -> Full from full;
	[Previous display X position] = [Display X Position];
	[Previous display Y position] = [Display Y Position];
    "Full from full"
    (first update area coordinates to fit desired size)
	[Pointer Delta X] = [Fullscreen Width]; [Pointer Delta X] - [Display Width];
	[Pointer Delta Y] = [Display Height]; [Pointer Delta Y] - [Fullscreen Height];
	=> RES Update all bounds;
    (then send the display to exclusive mode)
	[Display Command] = SET EXCLUSIVE MODE;
	[Display Width]   = [Fullscreen Width];
	[Display Height]  = [Fullscreen Height];
	isocall;
	? ok -> Refresh Display;
    (if failed, the runtime module reverts it to windowed mode, but at this
     point we must expect the display to be refitted to the desktop screen,
     whose dimensions are given by [display physical...] variables while not
     using exclusive mode, and if the dimensions we failed to set were ABOVE
     those limits, we have to also inform the various iGUI elements' bounds,
     that they might live in a smaller display, still as large as possible,
     but not as large as originally expected)
    "Is physical smaller than logical"
	? [Fullscreen Width] < [Display Physical Width] -> NF Horizontally fitting;
	[Pointer Delta X] = [Display Physical Width]; [Pointer Delta X] - [Fullscreen Width];
	[Pointer Delta Y] = ZERO;
	=> RES Update all bounds;
      "NF Horizontally fitting"
	? [Fullscreen Height] < [Display Physical Height] -> NF Vertically fitting;
	[Pointer Delta Y] = [Fullscreen Height]; [Pointer Delta Y] - [Display Physical Height];
	[Pointer Delta X] = ZERO;
	=> RES Update all bounds;
      "NF Vertically fitting"
	-> Refresh Display;

    (reverts the display to windowed mode, if it was in full-screen mode)

"Now Unfull" (also known as) "AutoUnfull"
	[Display X Position] = [Previous display X position];
	[Display Y Position] = [Previous display Y position];
	[Display Command]    = SET COOPERATIVE MODE;
	isocall;
    (after the above command, display may have moved to fit physical limits)
	[Previous display X position] = [Display X Position];
	[Previous display Y position] = [Display Y Position];
    (check if former full-screen display now fits windowed mode display)
	-> Is physical smaller than logical;

    (installs the menu layout datascript pointed by [Menu To Install] as
     current pull-down menu; may be called at any type, and more than one
     menu layout could be used during the application's runtime: a good
     example of a menu change is Peterpaul Klein Haneveld's Yahtzee game,
     where two different menu layouts are used, one for dice board and
     game control, and the other while visualizing the high scores table)

"Install Menu"
	[Installed Menu Options] = ZERO;
	A = [Menu To Install];
	B = ZERO;
    "IM Copy menu title"
	[B plus vector App Menu Description] = [A];
	? [A] = NULL -> IM EMT;
	? B = 62 -> IM EMT;
	A+; B+; -> IM Copy menu title;
    "IM EMT"
	A+;
    "IM Decoding Loop"
	? [A] = NULL -> IM Finished;
	? [Installed Menu Options] >= MAX MENU OPTIONS -> IM Finished;
	B = [Installed Menu Options]; [Installed Menu Options]+;
	[B plus vector Menu Option Code] = [A];
	[B plus vector Menu Option Attributes] = [A plus 1];
	[B plus vector Menu Option String] = A;
	[B plus vector Menu Option String] + 2;
	A + 2;
    "IM Fetching next option"
	? [A] = NULL -> IM EOS;
	A+; -> IM Fetching next option;
    "IM EOS"
	[B plus vector Menu Option Manager] = [A plus 1];
	A + 2; -> IM Decoding Loop;
    "IM Finished"
	leave;

    (marks a menu option, i.e. replaces the option's first character name
     with ASCII code defined by constant "MENU MARKER", which is typically
     code 42, an asterisk; no change is made to the datascript giving the
     menu layout, the change is only affecting iGUI's internal buffers;
     menu option's code of affected option must be loaded in [Option Code])

"Mark Option"
	=> Find Opt Logical ID From Code;
	? failed -> MOP Error;
	A = [E plus vector Menu Option String];
	? [A] = NULL -> UMP Error;
	[A] = MENU MARKER;
    "MOP Error"
	fail;

    (unmarks a menu option, i.e. replaces the option's first character name
     with ASCII code defined by constant "MENU DEMARKER", which is typically
     code 32, an blank space; no change is made to the datascript giving the
     menu layout, the change is only affecting iGUI's internal buffers;
     menu option's code of affected option must be loaded in [Option Code])

"UnMark Option"
	=> Find Opt Logical ID From Code;
	? failed -> UMP Error;
	A = [E plus vector Menu Option String];
	? [A] = NULL -> UMP Error;
	[A] = MENU DEMARKER;
    "UMP Error"
	fail;

    (enables a menu option, that is, makes it clickable;
     if the option is already enabled, this call has no effect;
     menu option's code of affected option must be loaded in [Option Code])

"Enable Option"
	=> Find Opt Logical ID From Code;
	? failed -> ENOP Error;
	A = OPTION TYPE DISABLED; !A;
	[E plus vector Menu Option Attributes] & A;
    "ENOP Error"
	fail;

    (disables a menu option, that is, makes it unclickable;
     if the option is already disabled, this call has no effect;
     menu option's code of affected option must be loaded in [Option Code])

"Disable Option"
	=> Find Opt Logical ID From Code;
	? failed -> DISOP Error;
	[E plus vector Menu Option Attributes] | OPTION TYPE DISABLED;
    "DISOP Error"
	fail;

    (checks a text field for keyboard input: there are several variables
     to be loaded before calling this function, and the behaviour of text
     fields is explained where those variables are declared, that is, in
     this library's "workspace" period)

"Check Text Field"
	[ekey session id] = 19010001;
	=> negotiate ekey session;
      ? failed -> skip session 19010001;
	[key end    server] = service CTF Move end;
	[key home   server] = service CTF Move home;
	[key left   server] = service CTF Move left;
	[key right  server] = service CTF Move right;
	[key insert server] = service CTF Insert;
	[key delete server] = service CTF Delete;
	=> serve enhanced keystrokes;
	=> quit ekey session;
      "skip session 19010001"
	A = [Text Field Data];
	B = [Text Field Buffer];
	[Console Command] = GET CONSOLE INPUT;
	isocall; ? failed -> CTF Do nothing;
	? [Console Input] = 008 -> CTF Backspace;
	? [Console Input] = 009 -> CTF Tabstp;
	? [Console Input] = 013 -> CTF Return;
	? [Console Input] = 027 -> CTF Escape;
	? [Console Input] < 032 -> CTF Do nothing;
	? [Console Input] > 126 -> CTF Do nothing;
	C = [A plus 4]; C+; ? C >= [Text Field Size] -> CTF Do nothing;
	C = [A plus 5]; C+; ? C >= [Text Field Size] -> CTF Do nothing;
      ? [CTF Selection Buffer] != [Text Field Buffer] -> CTF INS NOW;
	=> CTF Delete selection;
	[CTF Selection Buffer] = ZERO;
	A = [Text Field Data];
	B = [Text Field Buffer];
    "CTF INS NOW"
	C = B; C + [A plus 4];
	D = B; D + [A plus 5];
    "CTF INS MOV"
	? C < D -> CTF INS EOL;
	[C plus 1] = [C];
	C-; -> CTF INS MOV;
    "CTF INS EOL"
	C = B; C + [A plus 5]; [C] = [Console Input];
	C = B; C + [A plus 4]; [C plus 1] = NULL;
	[A plus 4]+;
	[A plus 5]+;
	=> CTF Check right margin;
	=> CTF Retrace;
    "CTF Do nothing"
	leave;
    "CTF Backspace"
	? [A plus 4] <= ZERO -> CTF Do nothing;
	? [A plus 5] <= ZERO -> CTF Do nothing;
	C = B; C + [A plus 5]; C-;
	D = B; D + [A plus 4];
      "CTF BKSP Loop"
	? C >= D -> CTF BKSP Stop;
	[C] = [C plus 1]; C+; -> CTF BKSP Loop;
      "CTF BKSP Stop"
	[A plus 5]-;
	[A plus 4]-;
	=> CTF Check left margin;
	-> CTF Retrace;
    "CTF Escape"
	[CTF Selection Buffer] = ZERO;
	? [On Escape] = NULL -> CTF Do nothing;
	-> [On Escape];
    "CTF Return"
	[CTF Selection Buffer] = ZERO;
	? [On Return] = NULL -> CTF Do nothing;
	-> [On Return];
    "CTF Tabstp"
	[CTF Selection Buffer] = ZERO;
	? [On Tabstp] = NULL -> CTF Do nothing;
	-> [On Tabstp];
    "service CTF Insert"
      ? [KEY CONTROL] = OFF -> CTF Not copying;
      ? [CTF Selection Buffer] != [Text Field Buffer] -> CTF Do nothing;
	-> CTF Copy selection;
      "CTF Not copying"
      ? [KEY SHIFT] = OFF -> CTF Do nothing;
	=> CTF Paste clip;
	-> CTF Retrace;
    "service CTF Delete"
      ? [CTF Selection Buffer] != [Text Field Buffer] -> CTF Not deleting selection;
      ? [KEY SHIFT] = OFF -> CTF Not cutting;
	=> CTF Copy selection;
      "CTF Not cutting"
	=> CTF Delete selection;
	[CTF Selection Buffer] = ZERO;
	-> CTF Been deleting selection;
      "CTF Not deleting selection"
	A = [Text Field Data];
	B = [Text Field Buffer];
	? [A plus 4] <= ZERO -> CTF Do nothing;
	? [A plus 5] >= [A plus 4] -> CTF Do nothing;
	C = B; C + [A plus 5];
	D = B; D + [A plus 4];
      "CTF DEL Loop"
	? C >= D -> CTF DEL Stop;
	[C] = [C plus 1]; C+; -> CTF DEL Loop;
      "CTF DEL Stop"
	[A plus 4]-;
      "CTF Been deleting selection"
	-> CTF Retrace;
    "service CTF Move end"
	A = [Text Field Data];
	B = [Text Field Buffer];
	? [A plus 5] >= [A plus 4] -> CTF Do nothing;
	[CTF Start Selecting At] = [A plus 5];
	[CTF Stop Selecting At] = [A plus 4];
	=> CTF Selection common;
	[A plus 5] = [A plus 4];
	=> CTF Check right margin;
	-> CTF Retrace;
    "service CTF Move home"
	A = [Text Field Data];
	B = [Text Field Buffer];
	? [A plus 5] <= ZERO -> CTF Do nothing;
	[CTF Start Selecting At] = [A plus 5];
	[CTF Stop Selecting At] = ZERO;
	=> CTF Selection common;
	[A plus 5] = ZERO;
	[A plus 6] = ZERO;
	-> CTF Retrace;
    "service CTF Move left"
	A = [Text Field Data];
	B = [Text Field Buffer];
	? [A plus 5] <= ZERO -> CTF Do nothing;
	[CTF Start Selecting At] = [A plus 5];
	[A plus 5] -;
	[CTF Stop Selecting At] = [A plus 5];
	=> CTF Selection common;
	=> CTF Check left margin;
	-> CTF Retrace;
    "service CTF Move right"
	A = [Text Field Data];
	B = [Text Field Buffer];
	? [A plus 5] >= [A plus 4] -> CTF Do nothing;
	[CTF Start Selecting At] = [A plus 5];
	[A plus 5] +;
	[CTF Stop Selecting At] = [A plus 5];
	=> CTF Selection common;
	=> CTF Check right margin;
	-> CTF Retrace;
    "CTF Selection common"
      ? [KEY SHIFT] = ON -> CTF Selecting;
      ? [CTF Selection Buffer] != [Text Field Buffer] -> CTF No deselection;
	[CTF Selection Buffer] = ZERO;
      "CTF No deselection"
	leave;
      "CTF Selecting"
      ? [CTF Selection Buffer] = [Text Field Buffer] -> CTF No selection start;
	[CTF Selection Buffer] = [Text Field Buffer];
	[CTF Selection Buffer Size] = [Text Field Size];
	[CTF Selection Start] = [CTF Start Selecting At];
      "CTF No selection start"
	[CTF Selection Stop] = [CTF Stop Selecting At];
	leave;
    "CTF Retrace"
	? [CTF Fake Retrace] = TRUE -> CTFNoChgNotify;
      ? [On Change] = NULL -> CTFNoChgNotify;
	=> [On Change];
      "CTFNoChgNotify"
	-> CTF Refresh;
    "CTF Check left margin"
	[CTF Fake Retrace] = TRUE; => CTF Retrace; [CTF Fake Retrace] = FALSE;
	A = [Text Field Data];
	C = [vector CTF Cursor plus 0]; C - [A plus 0];
	D = [Text Field LeftSide Tolerance]; D + [STD Font Width];
	? C >= D -> CTF Within left margin;
	[A plus 6] + D;
	[A plus 6] - C;
	? [A plus 6] <= ZERO -> CTF Within left margin;
	[A plus 6] = ZERO;
      "CTF Within left margin"
	leave;
    "CTF Check right margin"
	[CTF Fake Retrace] = TRUE; => CTF Retrace; [CTF Fake Retrace] = FALSE;
	A = [Text Field Data];
	C = [A plus 2]; C - [vector CTF Cursor plus 0];
	C - [Text Field RightSide Tolerance]; C - [STD Font Width];
	? C >= ZERO -> CTF Within right margin;
	[A plus 6] + C;
    "CTF Within right margin"
	leave;
    "CTF Load selection registers"
	A = [Text Field Data];
	B = [CTF Selection Start];
	C = [CTF Selection Stop];
      ? B < C -> CTF LSR properly ordered;
	D = B;
	B = C;
	C = D;
      "CTF LSR properly ordered"
      ? B >= [A plus 4] -> CTF LSR invalid selection;
      ? C > [A plus 4] -> CTF LSR invalid selection;
	end;
      "CTF LSR invalid selection"
	fail;
    "CTF Copy selection"
	=> CTF Load selection registers;
      ? failed -> CTF CS no selection;
	B + [Text Field Buffer];
	C + [Text Field Buffer];
	[C] -->;
	[C] = NULL;
	[clip command] = write clip;
	[clip string] = B;
	[clip size] = minus 1;
	isocall;
	<-- [C];
      "CTF CS no selection"
	leave;
    "CTF Delete selection"
	=> CTF Load selection registers;
      ? failed -> CTF DS no selection;
	[A plus 5] = B;
	D = [A plus 4];
	B + [Text Field Buffer];
	C + [Text Field Buffer];
	D + [text Field Buffer];
      "CTF DS Loop"
      ? C > D -> CTF DS Stop;
	[B] = [C];
	B +;
	C +;
	-> CTF DS Loop;
      "CTF DS Stop"
	[A plus 4] = B; [A plus 4] -;
	[A plus 4] - [Text Field Buffer];
	=> CTF Check left margin;
      "CTF DS no selection"
	leave;
    "CTF Paste clip"
      ? [CTF Selection Buffer] != [Text Field Buffer] -> CTF Paste now;
	=> CTF Delete selection;
	[CTF Selection Buffer] = ZERO;
    "CTF Paste now"
	[clip command] = get clip size;
	isocall;
      ? failed -> CTF No clip;
	[clip size] -;
      ? [clip size] <= 0 -> CTF No clip;
	A = [Text Field Data];
	B = [Text Field Size];
	B - [A plus 4];
	B -;
      ? B <= 0 -> CTF No room;
      ? [clip size] <= B -> CTF Paste full;
	[clip size] = B;
    "CTF Paste full"
	B = [A plus 4];
	B - [A plus 5];
	B +;
      ? B <= 0 -> CTF No room;
	C = [A plus 5];
	D = C;
	D + [clip size];
	C + [Text Field Buffer];
	D + [Text Field Buffer];
	C + B;
	D + B;
    "CTF Paste loop"
	C -;
	D -;
	[D] = [C];
	B ^ CTF Paste loop;
	[D] -->;
	[clip command] = read clip;
	[clip string] = [Text Field Buffer];
	[clip string] + [A plus 5];
	[clip size] +;
	isocall;
	[clip size] -;
	[D] <--;
	B = [clip size];
	C = [Text Field Buffer];
	C + [A plus 5];
    "CTF Trash loop"
	D = [C];
	C +;
      ? D < 32 -> CTF Not accepted;
      ? D > 126 -> CTF Not accepted;
	-> CTF Accepted;
      "CTF Not accepted"
	[C minus 1] = 32;
      "CTF Accepted"
	B ^ CTF Trash loop;
	[A plus 4] + [clip size];
	[A plus 5] + [clip size];
	=> CTF Check right margin;
    "CTF No room" (or) "CTF No clip"
	leave;

    (redraws a text field: the variables to be loaded for this function call
     are exactly the same as the abovely described "Check Text Field")

"CTF Refresh"
	[Text Highlight Start]	-->;
	[Text Highlight Stop]	-->;
	[Text Highlight Start]	= 0;
	[Text Highlight Stop]	= 0;
      ? [Text Field Buffer]    != [CTF Selection Buffer] -> CTF Buffer has no selection;
	[Text Highlight Start]	= [CTF Selection Start];
	[Text Highlight Stop]	= [CTF Selection Stop];
	[Text Highlight Start]	+ [CTF Selection Buffer];
	[Text Highlight Stop]	+ [CTF Selection Buffer];
      ? [Text Highlight Start] <= [Text Highlight Stop] -> CTF Buffer has no selection;
	[Text Highlight Start]	-->;
	[Text Highlight Stop]	-->;
	[Text Highlight Start]	<--;
	[Text Highlight Stop]	<--;
      "CTF Buffer has no selection"
	[String]		= [Text Field Buffer];
	[Ink]			= [Text Field Text Color];
	[Text X]		= ZERO;
	[Text Y]		= ZERO;
	[Text Effect]		= [Text Field Text Effect];
	[Text Display Width]	= [Display Width];
	[Text Display Height]	= [Display Height];
	[Text Display Origin]	= Backdrop Layer;
	[Text Word Wrap]	= OFF;
	=> CTFR Get cursor pointer;
  (>>>) [C] -->;
	[C] = NULL;
	[Text Region] = NULL;
	[Text Window] = NULL;
	[Text Ghost Mode] = ON;
	=> STD Write;
      ? [CTF Fake Retrace] = TRUE -> CTFR Fake retrace j1;
      ? [Text Field Behavior] + TXF NOREDRAW -> CTFR Fake retrace j1;
	A = [Text Field Data];
	[Text X] = [A plus 6];
	[Text Region] = [Text Field Data];
	[Text Window] = [Text Field Data];
	[Text Ghost Mode] = OFF;
	[Width Of Latest Form] -->;
	=> STD Write;
	<-- [Width Of Latest Form];
      "CTFR Fake retrace j1"
	A = [Text Field Data];
	B = vector CTF Cursor;
	[B plus 0] = [A plus 0];
	[B plus 0] + [Width Of Latest Form];
	[B plus 0] + [A plus 6];
	[B plus 0] + [Text Field Cursor Shift];
	[B plus 2] = [B plus 0];
	[B plus 2] + [Text Field Cursor Width];
	[B plus 1] = [A plus 1];
	[B plus 3] = [A plus 3];
      ? [CTF Fake Retrace] = TRUE -> CTFR Fake retrace j2;
      ? [Text Field Behavior] + TXF NOREDRAW -> CTFR Fake retrace j2;
      ? [Is Active Text Field] = NO -> CTFR This field is inactive so theres no cursor;
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector CTF Cursor;
	[Rectangle Gradients] = vector Text Cursor Colors;
	[Rectangle Effect] = [Text Cursor Effect];
	=> Rectangle;
      "CTFR This field is inactive so theres no cursor"
	=> CTFR Get cursor pointer;
  (<<<) <-- [C];
	[String] + [A plus 5];
	[Text X] + [Width Of Latest Form];
	=> STD Write;
      ? [Text Field Behavior] + TXF NOUPDATE -> CTFR Common exit;
	[L2L Region] = [Text Field Data];
	=> Update Area;
	-> CTFR Common exit;
      "CTFR Fake retrace j2"
	=> CTFR Get cursor pointer;
  (<<<) <-- [C];
    "CTFR Common exit"
	<-- [Text Highlight Stop];
	<-- [Text Highlight Start];
	leave;
    "CTFR Get cursor pointer"
	A = [Text Field Data];
	C = [Text Field Buffer];
	C + [A plus 5];
	leave;

    (parses a question's datascript, pointed by [Question Datascript], and
     shows the resulting question box: this will temporarily halt the
     application's normal execution flow, to avoid interferences; this
     function returns when the user clicks an option that is associated
     with a NULL service subroutine pointer, that is, an option that does
     nothing; clicking an option which is associated to an effective
     pointer, not NULL, also causes the function to return but AFTER having
     executed the given service subroutine; this function will prompt the
     user for maximization of the display via the "On Question Overscan"
     question datascript, a question datascript defined by the client, of
     which a default version is declared by defstyle.txt, if the display
     results too small to display the original question box)

"Question"
	[vector Q Whole Display Bounds plus 0] = ZERO;
	[vector Q Whole Display Bounds plus 1] = ZERO;
	[vector Q Whole Display Bounds plus 2] = [Display Width];
	[vector Q Whole Display Bounds plus 3] = [Display Height];
	[vector Q Whole Display Bounds plus 2]-;
	[vector Q Whole Display Bounds plus 3]-;
	[vector Q Test Text Box plus 0] = ZERO;
	[vector Q Test Text Box plus 1] = ZERO;
	[vector Q Test Text Box plus 2] = [Display Width];
	[vector Q Test Text Box plus 3] = [Display Height];
	[vector Q Test Text Box plus 2] - [Question Text Padding];
	[vector Q Test Text Box plus 2] - [Question Text Padding];
	[vector Q Test Text Box plus 2] - [Question Border];
	[vector Q Test Text Box plus 2] - [Question Border];
	[vector Q Test Text Box plus 2] - [STD Font Width];
	[vector Q Test Text Box plus 2] - [Text Intercharspacing];
	[vector Q Test Text Box plus 3] - [Question Text Padding];
	[vector Q Test Text Box plus 3] - [Question Text Padding];
	[vector Q Test Text Box plus 3] - [Question Border];
	[vector Q Test Text Box plus 3] - [Question Border];
	[vector Q Test Text Box plus 3] - [Question Opt Spacing];
	[vector Q Test Text Box plus 3] - [Question Opt Padding];
	[vector Q Test Text Box plus 3] - [Question Opt Padding];
	[vector Q Test Text Box plus 3] - [STD Font Body];
	[vector Q Test Text Box plus 3] - [Text Interlinespacing];
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector Q Whole Display Bounds;
	[Rectangle Gradients] = vector All Controls Off;
	[Rectangle Effect] = service FX Alpha Dim;
	=> Rectangle;
	[Q Options Count] = ZERO;
	[Q Fields Count] = ZERO;
	[Q Datascript ptr] = [Question Datascript];
	[vector Q Options Data plus 0] = [Question Opt Spacing];
    "Q Body decoding loop"
	A = [Q Datascript ptr]; ? [A] != NULL -> Q Body no separator;
	[String]		= [Question Datascript];
	[Text X]		= 0;
	[Text Y]		= 0;
	[Text Region]		= vector Q Test Text Box;
	[Text Window]		= vector Q Test Text Box;
	[Text Word Wrap]	= ON;
	[Text Ghost Mode]	= ON;
	=> STD Write;
	[Width Of Question Form] = [Width Of Latest Form];
	[Height Of Question Form] = [Height Of Latest Form];
	[Q Datascript ptr]+;
	[Q String ptr] = [Q Datascript ptr];
	-> Q Options decoding loop;
    "Q Body no separator"
	[Q Datascript ptr]+;
	-> Q Body decoding loop;
    "Q Options decoding loop"
	A = [Q Datascript ptr];
	? [A] != NULL -> Q Options no separator;
	A = [Q String ptr];
	? [A plus 1] != 47 -> Q Option is not a field;
	? [A plus 0] = 70 -> Q Option is a field;
	? [A plus 0] = 83 -> Q Option is a field;
	-> Q End options; (declaration error)
      "Q Option is a field"
	? [Q Fields Count] >= MAX FIELDS IN QUESTION -> Q Too many fields;
	A = [Q Fields Count];
	[A plus vector Q Field Title] = [Q String ptr];
	[A plus vector Q Field Title] + 2;
	B = [Q String ptr];
	[A plus vector Q Field Classification] = [B];
	B = [Q Datascript ptr];
	[A plus vector Q Field Buffer] = [B plus 1];
	[A plus vector Q Field Buffer Size] = [B plus 2];
	C = [STD Font Width];
	C + [Text Intercharspacing];
	D = [B plus 3];
	D * C;
	[A plus vector Q Field Content Width] = D;
	E = [Q Datascript ptr];
	E - [Q String ptr];
	E - 2;
	E * C;
	[A plus vector Q Field Title Width] = E;
	E + D;
	E + 2; (field selection border is 1 pixel, and fixed)
	E + [Question Field Padding];
	E + [Question Field Padding];
	E + [Question Field Padding];
	? E <= [Width Of Question Form] -> Q Field is shorter than text;
	[Width Of Question Form] = E;
    "Q Field is shorter than text"
	? [Q Fields Count] = ZERO -> Q First Field Placement;
	? [A plus vector Q Field Classification minus 1] = 83 -> Q Other Field Placement;
	[Height Of Question Form] + [Question Opt Spacing];
	-> Q Other Field Placement;
      "Q First Field Placement"
	[Height Of Question Form] + [Question Text Padding];
      "Q Other Field Placement"
	[A plus vector Q Field Displacement] = [Height Of Question Form];
	[Height Of Question Form] + [Question Field Padding];
	[Height Of Question Form] + [STD Font Body];
	[Height Of Question Form] + [Question Field Padding];
	[Height Of Question Form] + 2; (field selection border)
	[Q Fields Count]+;
    "Q Too many fields"
	[Q Datascript ptr] + 4;
	[Q String ptr] = [Q Datascript ptr]; (new ptr to next option or field)
	A = [Q Datascript ptr]; ? [A] = NULL -> Q End options; (declaration error)
	-> Q Options decoding loop;
    "Q Option is not a field"
	? [Q Options Count] >= MAX OPTIONS IN QUESTION -> Q End options;
	[String]		= [Q String ptr];
	[Text X]		= ZERO;
	[Text Y]		= ZERO;
	[Text Region]		= NULL;
	[Text Window]		= NULL;
	[Text Word Wrap]	= OFF;
	[Text Ghost Mode]	= ON;
	=> STD Write;
	A = [Q Options Count];
	A * 7; A + vector Q Options Data;
	[A plus 2] = [A plus 0];
	[A plus 2] + [Width Of Latest Form];
	[A plus 2] + [Question Opt Padding];
	[A plus 2] + [Question Opt Padding];
	[A plus 4] = ZERO; (question hotspot status)
	[A plus 5] = [Q String ptr];
	[A plus 7] = [A plus 2]; (left margin coordinate of next option)
	[A plus 7] + [Question Opt Spacing];
	? [A plus 7] <= [Width Of Question Form] -> Q Option is shorter than text;
	[Width Of Question Form] = [A plus 7];
      "Q Option is shorter than text"
	[Q Datascript ptr]+; (skip null terminator)
	[A plus 6] = [Q Datascript ptr]; (pointer to management subroutine)
	[Q Datascript ptr]+; (skip parameter)
	[Q String ptr] = [Q Datascript ptr]; (new pointer to next option's string)
	[Q Options Count]+; (add option)
	A = [Q Datascript ptr]; ? [A] = NULL -> Q End options;
	-> Q Options decoding loop;
    "Q Options no separator"
	[Q Datascript ptr]+;
	-> Q Options decoding loop;
    "Q End options"
	? [Q Options Count] = ZERO -> Q Empty;
	? [Width Of Question Form] < [STD Font Width] -> Q Empty;
	? [Height Of Question Form] < [STD Font Body] -> Q Empty;
	[Height Of Question Body] = [Height Of Question Form];
	[Height Of Question Form] + [STD Font Body];
	[Height Of Question Form] + [Question Opt Padding];
	[Height Of Question Form] + [Question Opt Padding];
	[Height Of Question Form] + [Question Opt Spacing];
	[Width Of Question Form] + [Question Text Padding];
	[Width Of Question Form] + [Question Text Padding];
	[Width Of Question Form] + [Question Border];
	[Width Of Question Form] + [Question Border];
	[Height Of Question Form] + [Question Text Padding];
	[Height Of Question Form] + [Question Text Padding];
	[Height Of Question Form] + [Question Border];
	[Height Of Question Form] + [Question Border];
	A = [Display Width]; A - [Width Of Question Form]; A >> 1;
	B = [Display Height]; B - [Height Of Question Form]; B >> 1;
	? A < 2 -> Q Overscan;
	? B < 2 -> Q Overscan;
	[vector Question Form Bounds plus 0] = A;
	[vector Question Form Bounds plus 1] = B;
	A + [Width Of Question Form];
	B + [Height Of Question Form];
	A + 2;
	B + 2;
	? A >= [Display Width] -> Q Overscan;
	? B >= [Display Height] -> Q Overscan;
	[vector Question Form Bounds plus 2] = A;
	[vector Question Form Bounds plus 3] = B;
	[Current Level In Show] -->;
	[Current Level In Show] = minus 1;
	[SL X Start] = [vector Question Form Bounds plus 0];
	[SL Y Start] = [vector Question Form Bounds plus 3];
	[SL X End]   = [vector Question Form Bounds plus 2];
	[SL Y End]   = [SL Y Start];
	[SL X Delta] = 1;
	[SL Y Delta] = 0;
	=> Shadowline;
	[SL X Start] = [vector Question Form Bounds plus 2];
	[SL Y Start] = [vector Question Form Bounds plus 1];
	[SL X Delta] = 0;
	[SL Y Delta] = 1;
	=> Shadowline;
	<-- [Current Level In Show];
	? [Question Border] <= 0 -> Q No border around form;
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector Question Form Bounds;
	[Rectangle Gradients] = vector Question Border Colors;
	[Rectangle Effect] = [Question Border Effect];
	=> Rectangle;
    "Q No border around form"
	[vector Question Form Bounds plus 0] + [Question Border];
	[vector Question Form Bounds plus 1] + [Question Border];
	[vector Question Form Bounds plus 2] - [Question Border];
	[vector Question Form Bounds plus 3] - [Question Border];
	[TR Bounds] = vector Question Form Bounds;
	[TR Picture Data] = [p Dialog Filler];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = [Question Body Effect];
	=> Tile Region;
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector Question Form Bounds;
	[Rectangle Gradients] = vector Question Body Colors;
	[Rectangle Effect] = service FX Alpha Light;
	=> Rectangle;
	? [Q Fields Count] = ZERO -> Q No fields to fill data for;
	[Q Current option to check for] = ZERO;
	A = vector Q Fields Data; (CTF structure)
	B = vector Q Fields Hotspot; (not including fixed border)
	C = [Q Fields Count];
	D = ZERO;
    "Q Fill remaining fields data"
	[A plus 0] = [vector Question Form Bounds plus 0];
	[A plus 0] + [Question Text Padding];
	[A plus 0] + [D plus vector Q Field Title Width];
	[A plus 0] + [Question Field Padding];
	[A plus 0]+;
	[A plus 0] + [Question Field Padding];
	[A plus 1] = [vector Question Form Bounds plus 1];
	[A plus 1] + [Question Text Padding];
	[A plus 1] + [D plus vector Q Field Displacement];
	[A plus 1]+;
	[A plus 1] + [Question Field Padding];
	[A plus 2] = [A plus 0];
	[A plus 2] + [D plus vector Q Field Content Width];
	[A plus 3] = [A plus 1];
	[A plus 3] + [STD Font Body];
		[A plus 4] = ZERO;
		E = [D plus vector Q Field Buffer];
	    "Q Find end of predefined text"
		? [E] = NULL -> Q Found end of predefined text;
		E+; [A plus 4]+; -> Q Find end of predefined text;
	    "Q Found end of predefined text"
	[A plus 5] = ZERO;
	[A plus 6] = ZERO;
	[B plus 0] = [vector Question Form Bounds plus 0];
	[B plus 0] + [Question Text Padding];
	[B plus 0] + [D plus vector Q Field Title Width];
	[B plus 0] + [Question Field Padding];
	[B plus 0]+;
	[B plus 1] = [vector Question Form Bounds plus 1];
	[B plus 1] + [Question Text Padding];
	[B plus 1] + [D plus vector Q Field Displacement];
	[B plus 1]+;
	[B plus 2] = [B plus 0];
	[B plus 2] + [Question Field Padding];
	[B plus 2] + [D plus vector Q Field Content Width];
	[B plus 2] + [Question Field Padding];
	[B plus 3] = [B plus 1];
	[B plus 3] + [Question Field Padding];
	[B plus 3] + [STD Font Body];
	[B plus 3] + [Question Field Padding];
	[B plus 4] = ZERO;
	A-->; B-->; C-->; D-->;
		[String]		= [D plus vector Q Field Title];
		[Ink]			= [Question Text Color];
		[Text X]		= [vector Question Form Bounds plus 0];
		[Text X]		+ [Question Text Padding];
		[Text Y]		= [vector Question Form Bounds plus 1];
		[Text Y]		+ [Question Text Padding];
		[Text Y]		+ [D plus vector Q Field Displacement];
		[Text Y]		+ [Question Field Padding];
		[Text Y]		+;
		[Text Effect]		= [Question Text Effect];
		[Text Display Width]	= [Display Width];
		[Text Display Height]	= [Display Height];
		[Text Display Origin]	= Backdrop Layer;
		[Text Region]		= NULL;
		[Text Window]		= NULL;
		[Text Word Wrap]	= OFF;
		[Text Ghost Mode]	= OFF;
		=> STD Write;
	<--D; <--C; <--B; <--A;
	? [D plus vector Q Field Classification] = 83 -> Q String viewer jumper 1;
	A-->; B-->; C-->; D-->;
		[B plus 0]-;
		[B plus 1]-;
		[B plus 2]+;
		[B plus 3]+;
		[Rectangle Target Layer] = Backdrop Layer;
		[Rectangle Display Alignment] = [Display Width];
		[Rectangle Bounds] = B;
		[Rectangle Gradients] = vector Question Field Edge Colors;
		[Rectangle Effect] = [Question Field Edge Effect];
		=> Rectangle;
	<--D; <--C; <--B; <--A;
	A-->; B-->; C-->; D-->;
		[B plus 0]+;
		[B plus 1]+;
		[B plus 2]-;
		[B plus 3]-;
		[Q Field To Retrace] = D;
		=> Q Retrace Field;
	<--D; <--C; <--B; <--A;
      "Q String viewer jumper 1"
	A-->; B-->; C-->; D-->;
		[Is Active Text Field] = NO;
		? D != ZERO -> Q Field is not active now;
		? [D plus vector Q Field Classification] = 83 -> Q Field is not active now;
		[Is Active Text Field] = YES;
	    "Q Field is not active now"
		[Text Field Data] = A;
		[Text Field Buffer] = [D plus vector Q Field Buffer];
		[Text Field Behavior] = NULL;
		=> CTF Refresh;
	<--D; <--C; <--B; <--A;
	A + 7;
	B + 5;
	D+;
	C ^ Q Fill remaining fields data;
    "Q No fields to fill data for"
	[Q Current option to check for] = ZERO;
	A = vector Q Options Data;
	B = [Q Options Count];
    "Q Fill remaining options data"
	[A plus 0] + [vector Question Form Bounds plus 0];
	[A plus 1] = [Height Of Question Body];
	[A plus 1] + [Question Text Padding];
	[A plus 1] + [Question Text Padding];
	[A plus 1] + [vector Question Form Bounds plus 1];
	[A plus 2] + [vector Question Form Bounds plus 0];
	[A plus 3] = [A plus 1];
	[A plus 3] + [STD Font Body];
	[A plus 3] + [Question Opt Padding];
	[A plus 3] + [Question Opt Padding];
	[A plus 2]-;
	[A plus 3]-;
	A-->; B-->;
		[A plus 0]-;
		[A plus 1]-;
		[A plus 2]+;
		[A plus 3]+;
		[Rectangle Target Layer] = Backdrop Layer;
		[Rectangle Display Alignment] = [Display Width];
		[Rectangle Bounds] = A;
		[Rectangle Gradients] = vector Question Option Edge Colors;
		[Rectangle Effect] = [Question Opt Edge Effect];
		=> Rectangle;
	<--B; <--A;
	A-->; B-->;
		[A plus 0]+;
		[A plus 1]+;
		[A plus 2]-;
		[A plus 3]-;
		[Rectangle Target Layer] = Backdrop Layer;
		[Rectangle Display Alignment] = [Display Width];
		[Rectangle Bounds] = A;
		[Rectangle Effect] = [Question Opt Body Effect];
		[Rectangle Gradients] = vector Question Default Option Body;
	      ? [Q Current option to check for] = [Q Default Option] -> Q Color Set;
		[Rectangle Gradients] = vector Question Generic Option Body;
	      "Q Color Set"
		=> Rectangle;
		[Q Current option to check for]+;
	<--B; <--A;
	A-->; B-->;
		[String]		= [A plus 5];
		[Ink]			= [Question Opt Color];
		[Text X]		= [A plus 0];
		[Text X]		+ [Question Opt Padding];
		[Text Y]		= [A plus 1];
		[Text Y]		+ [Question Opt Padding];
		[Text Effect]		= [Question Opt Text Effect];
		[Text Display Width]	= [Display Width];
		[Text Display Height]	= [Display Height];
		[Text Display Origin]	= Backdrop Layer;
		[Text Region]		= NULL;
		[Text Window]		= NULL;
		[Text Word Wrap]	= ON;
		[Text Ghost Mode]	= OFF;
		=> STD Write;
	<--B; <--A;
	A + 7;
	B ^ Q Fill remaining options data;
	[vector Question Form Bounds plus 0] + [Question Text Padding];
	[vector Question Form Bounds plus 1] + [Question Text Padding];
	[vector Question Form Bounds plus 2] - [Question Text Padding];
	[vector Question Form Bounds plus 3] - [Question Text Padding];
	[String]		= [Question Datascript];
	[Ink]			= [Question Text Color];
	[Text X]		= 0;
	[Text Y]		= 0;
	[Text Effect]		= [Question Text Effect];
	[Text Display Width]	= [Display Width];
	[Text Display Height]	= [Display Height];
	[Text Display Origin]	= Backdrop Layer;
	[Text Region]		= vector Question Form Bounds;
	[Text Window]		= vector Question Form Bounds;
	[Text Word Wrap]	= ON;
	[Text Ghost Mode]	= OFF;
	=> STD Write;
	=> Update Layers;
	[vector Question Form Bounds plus 0] - [Question Text Padding];
	[vector Question Form Bounds plus 1] - [Question Text Padding];
	[vector Question Form Bounds plus 2] + [Question Text Padding];
	[vector Question Form Bounds plus 3] + [Question Text Padding];
		[Q Quit] = NO;
		[Q Selected Field] = ZERO;
	    "Q PreWait RET Release"
		? [KEY RETURN] = ON -> Q PreWait RET Release;
	    "Q PreWait ESC Release"
		? [KEY RETURN] = ON -> Q PreWait ESC Release;
	    "Q Control"
		=> Begin Control Loop;
			[Balloon Text String] = NULL;
			? [Q Fields Count] = ZERO -> Q No fields to animate;
			A = [Q Selected Field];
			? [A plus vector Q Field Classification] = 83 -> Q String viewer jumper 2;
			[Text Field Data] = A;
			[Text Field Data] * 7;
			[Text Field Data] + vector Q Fields Data;
			[Text Field Size] = [A plus vector Q Field Buffer Size];
			[Text Field Buffer] = [A plus vector Q Field Buffer];
			[On Change] = service On Change of question text field;
			[On Return] = NULL;
			[On Escape] = NULL;
			[On Tabstp] = service Q Next Text Field;
			[Is Active Text Field] = YES;
			[Text Field Behavior] = NULL;
			=> Check Text Field;
		      "Q String viewer jumper 2"
			[Q Current option to check for] = vector Q Fields Hotspot;
			[Q Remaining options to check for] = [Q Fields Count];
			[Q Examined Field] = ZERO;
		    "Q Animate fields"
			A = [Q Examined Field];
			? [A plus vector Q Field Classification] = 83 -> Q String viewer jumper 3;
			[Hot Spot Data] = [Q Current option to check for];
			[While Hovering] = NULL;
			[When Hovering] = service When Hovering Question Option;
			[When No Longer Hovering] = service When No Longer Hovering Question Option;
			[When Pushing] = NULL;
			[When No Longer Pushing] = service Question Field Selection;
			=> Check Hot Spot;
		      "Q String viewer jumper 3"
			[Q Examined Field]+;
			[Q Current option to check for] + 5;
			[Q Remaining options to check for] ^ Q Animate fields;
		    "Q No fields to animate"
			[Q Current option to check for] = vector Q Options Data;
			[Q Remaining options to check for] = [Q Options Count];
		    "Q Wait for answer"
			[Hot Spot Data] = [Q Current option to check for];
			[While Hovering] = NULL;
			[When Hovering] = service When Hovering Question Option;
			[When No Longer Hovering] = service When No Longer Hovering Question Option;
			[When Pushing] = NULL;
			[When No Longer Pushing] = service Question Option Action;
			=> Check Hot Spot;
			? [Q Quit] = YES -> Q Bye;
			[Q Current option to check for] + 7;
			[Q Remaining options to check for] ^ Q Wait for answer;
		=> End Control Loop;
		? [KEY ESCAPE] = ON -> Q Wait ESC Release;
		? [KEY RETURN] = ON -> Q Wait RET Release;
		-> Q Control;
    "Q Wait RET Release"
	? [KEY RETURN] = ON -> Q Wait RET Release;
	-> service Q Apply Default Option;
    "Q Wait ESC Release"
	? [KEY ESCAPE] = ON -> Q Wait ESC Release;
    "Q Empty"
	=> Refresh Display;
    "Q Bye"
	leave;

    (installs tools bar layout described by the datascript pointed by
     [Tools Bar To Install]; if your application uses a tools bar,
     remember to also enable it via the "Enable Tools Bar" function,
     because by default the tools bar is disabled; enabling the tools bar
     automatically subtracts 23 pixels from the bottom of the work area
     to make room for the bar itself, while it's active)

"Install Tools Bar"
	[Installed Tools Bar Options] = ZERO;
	A = [Tools Bar To Install];
	B = ZERO;
    "ITB Copy layout"
	[B plus Installed Tools Pointers] = [A];
	? [A] = NULL -> ITB End layout;
	? B = 255 -> ITB End layout;
	A+; B+; -> ITB Copy layout;
    "ITB End layout"
	[Installed Tools Bar Options] = B;
	leave;

    (enables the tools bar, if a tools bar is installed)

"Enable Tools Bar"
	? [Tools Bar Active] = YES -> ETB Already;
	[vector Work Area plus 3] = [Display Height];
	[vector Work Area plus 3] - 25;
	[Tools Bar Active] = YES;
	=> Refresh Display;
    "ETB Already"
	leave;

    (disables the tools bar)

"Disable Tools Bar"
	? [Tools Bar Active] = NO -> DTB Already;
	[vector Work Area plus 3] = [Display Height];
	[vector Work Area plus 3] - 2;
	[Tools Bar Active] = NO;
	=> Refresh Display;
    "DTB Already"
	leave;

    (updates the installed tools bar, if any: this is ideally called to
     reflect changes made to single tools bar's buttons; those buttons
     are also datascripts, but their contents can be changed in realtime;
     an example of such changes is given in ArtSCII 1.2 source code)

"Update Tools Bar"
	? [Tools Bar Active] = NO -> UTSB Idle;
	[TR Bounds] = vector Tools Bar Bounds;
	[TR Picture Data] = [p Tools Bar Filler];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Raw;
	=> Tile Region;
	[UT Bounds plus 0] = [vector Tools Bar Bounds plus 0];
	[UT Bounds plus 1] = [vector Tools Bar Bounds plus 1];
	[UT Bounds plus 2] = [UT Bounds plus 0]; [UT Bounds plus 2] + 23;
	[UT Bounds plus 3] = [UT Bounds plus 1]; [UT Bounds plus 3] + 23;
	A = ZERO;
    "UTSB Draw tools"
	? A >= [Installed Tools Bar Options] -> UTSB No further tools;
	? [UT Bounds plus 2] >= [Display Width] -> UTSB No further tools;
	? [A plus Installed Tools Pointers] = TOOLS BAR SEPARATOR -> UTSB Manage separator;
	[UT Datascript pointer] = [A plus Installed Tools Pointers];
	[Rectangle Gradients] = NULL;
	[UT Copy tip] = NO;
	A -->; => Update Tool; <-- A;
	B = A; B+; ? B < [Installed Tools Bar Options] -> UTSB No shadow here;
	A -->; => UTSB Draw shadow; <-- A;
	-> UTSB No further tools;
    "UTSB No shadow here"
	[UT Bounds plus 0] + 24;
	[UT Bounds plus 2] + 24;
	A+; -> UTSB Draw tools;
    "UTSB Manage separator"
	[UT Bounds plus 0] - 24;
	[UT Bounds plus 2] - 24;
	? A = ZERO -> UTSB MS Coupled separators so no shadow here;
	? [A plus Installed Tools Pointers minus 1] != TOOLS BAR SEPARATOR -> UTSB MS Draw shadow;
	-> UTSB MS Coupled separators so no shadow here;
    "UTSB MS Draw shadow"
	A -->; => UTSB Draw shadow; <-- A;
    "UTSB MS Coupled separators so no shadow here"
	[UT Bounds plus 0] + 28;
	[UT Bounds plus 2] + 28;
	A+; -> UTSB Draw tools;
    "UTSB No further tools"
	[L2L Region] = vector Tools Bar Bounds;
	=> Update Area;
    "UTSB Idle"
	leave;
    "UTSB Draw shadow"
	[UT Shadow Bounds plus 0] = [UT Bounds plus 2];
	[UT Shadow Bounds plus 1] = [UT Bounds plus 1];
	[UT Shadow Bounds plus 2] = [UT Bounds plus 2]; [UT Shadow Bounds plus 2] + 9;
	[UT Shadow Bounds plus 3] = [UT Bounds plus 3];
	[TR Bounds] = UT Shadow bounds;
	[TR Picture Data] = [p Menu Shadow Vertical];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Alpha Dim;
	-> Tile Region;

    (retraces a scroller's actual shape, with the scrollpad in its actual
     position, on the display: variable [Scroller Datascript], before
     calling this function, must be loaded with the pointer to the datascript
     describing the scroller to draw; details on scrollers' behaviour can be
     found in the source code of the "Network Node", node.txt)

"Draw Scroller"
      ? [Last Locked Scroller] != UNDEFINED -> DS Dont Mark;
	A = [Scroller Datascript];
	[Last Locked Scroller] = [A plus 0];
      "DS Dont Mark"
	=> Compute Scroller Dimensions;
	[TR Bounds] = D; [TR Bounds] +;
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Raw;
	C -->; D -->; E -->; => Tile Region; <-- E; <-- D; <-- C;
	=> Compute Scrollpad Dimensions;
	[TR Bounds] = Scrollpad Bounds;
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Alpha Dim;
	[Region to Normalize] = Scrollpad Bounds;
	=> Normalize Region;
	=> Tile Region;
	D = [Scroller Datascript];
	? [Last Locked Scroller] != [D plus 0] -> DS No Visible Mark;
	D -->;
	[DS Shadow Bounds plus 0] = [Scrollpad Bounds plus 0];
	[DS Shadow Bounds plus 0] + [Scrollpad Bounds plus 2];
	[DS Shadow Bounds plus 0] > 1;
	[DS Shadow Bounds plus 0] - 2;
	[DS Shadow Bounds plus 1] = [Scrollpad Bounds plus 1];
	[DS Shadow Bounds plus 1] + [Scrollpad Bounds plus 3];
	[DS Shadow Bounds plus 1] > 1;
	[DS Shadow Bounds plus 1] - 2;
	[DS Shadow Bounds plus 2] = [DS Shadow Bounds plus 0]; [DS Shadow Bounds plus 2] + 4;
	[DS Shadow Bounds plus 3] = [DS Shadow Bounds plus 1]; [DS Shadow Bounds plus 1] + 4;
	[TR Bounds] = DS Shadow Bounds;
	[TR Picture Data] = [DS Pad Hole];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Raw;
	[Region to Normalize] = DS Shadow Bounds;
	=> Normalize Region;
	=> Tile Region;
	[TR Effect] = service FX Alpha Dim;
	[TR Picture Data] = [DS Pad Hole Shadow];
	=> Tile Region;
	<-- D;
      "DS No Visible Mark"
	? [Scroller Direction] = HORIZONTAL -> DS Horiz;
	[DS Shadow Bounds plus 0] = [Scrollpad Bounds plus 0];
	[DS Shadow Bounds plus 1] = [Scrollpad Bounds plus 3]; [DS Shadow Bounds plus 1] + 1;
	[DS Shadow Bounds plus 2] = [Scrollpad Bounds plus 2];
	[DS Shadow Bounds plus 3] = [Scrollpad Bounds plus 3]; [DS Shadow Bounds plus 3] + 10;
	? [DS Shadow Bounds plus 1] > [D plus 4] -> DS No shadow;
	? [DS Shadow Bounds plus 3] < [D plus 4] -> DS Vert shadow in range;
	[DS Shadow Bounds plus 3] = [D plus 4];
      "DS Vert shadow in range"
	[TR Bounds] = DS Shadow bounds;
	[TR Picture Data] = [p Menu Shadow Horizontal];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Alpha Dim;
	D -->; => Tile Region; <-- D;
	-> DS No shadow;
      "DS Horiz"
	[DS Shadow Bounds plus 0] = [Scrollpad Bounds plus 2]; [DS Shadow Bounds plus 0] + 1;
	[DS Shadow Bounds plus 1] = [Scrollpad Bounds plus 1];
	[DS Shadow Bounds plus 2] = [Scrollpad Bounds plus 2]; [DS Shadow Bounds plus 2] + 10;
	[DS Shadow Bounds plus 3] = [Scrollpad Bounds plus 3];
	? [DS Shadow Bounds plus 0] > [D plus 3] -> DS No shadow;
	? [DS Shadow Bounds plus 2] < [D plus 3] -> DS Horiz shadow in range;
	[DS Shadow Bounds plus 2] = [D plus 3];
      "DS Horiz shadow in range"
	[TR Bounds] = DS Shadow bounds;
	[TR Picture Data] = [p Menu Shadow Vertical];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Alpha Dim;
	=> Tile Region;
      "DS No shadow"
	? [DS Refresh] = NO -> DS Skip refresh;
	[L2L Region] = [Scroller Datascript];
	[L2L Region] +;
	=> Update Area;
    "DS Skip refresh"
	leave;

    (checks a scroller's scrollpad for dragging operations: variable
     [Scroller Datascript], before calling this function, must be loaded with
     the pointer to the datascript describing the scroller to check; details
     on scrollers' behaviour can be found in the source code of the "Network
     Node", node.txt)

"Check Scroller"
	D = [Scroller Datascript];
      ? [Last Locked Scroller] != [D plus 0] -> CS No wheel move;
	A = [iGUIcc Wheel Knot Before];
	A - [iGUIcc Wheel Knot Actual];
      ? A = ZERO -> CS No wheel move;
	A -->;
	=> Compute Scroller Dimensions;
	=> Compute Scrollpad Dimensions;
	<-- A;
      ? [CS Range] <= ZERO -> CS Out of area;
	B = [D plus 0];
	B & SB WHEEL MULTIPLY;
	C = 32;
	C - [Wheel Multiplication Factor];
	B > C;
	B + [Wheel Doublings Per Knot];
	A << B;
	-> CS Reentry after wheel move;
      "CS No wheel move"
      ? [Pointer Status] - PD LEFT BUTTON DOWN -> CS No longer pushing;
	=> Compute Scroller Dimensions;
	=> Compute Scrollpad Dimensions;
      ? [Lock On Scroller] = [D plus 0] -> CS Locked on scrollpad;
      ? [Pointer X Coordinate] < [D plus 1] -> CS Out of area;
      ? [Pointer X Coordinate] > [D plus 3] -> CS Out of area;
      ? [Pointer Y Coordinate] < [D plus 2] -> CS Out of area;
      ? [Pointer Y Coordinate] > [D plus 4] -> CS Out of area;
      ? [Last Locked Scroller] = [D plus 0] -> CS Not marking;
      (scroller is just marked as selected here, not yet locked:
       the following call marks a hole in the middle of the scroll pad
       to mean that the mouse wheel focus has been set to that scroller,
       by setting [Last Locked Scroller] to the identity of this scroller,
       and the calling "Refresh Display", which also calls the client's
       specificed work area manager; presumably, the work area manager is
       where any scrollers on the backdrop layer get retraced, and again,
       presumably, those scrollers are retraced calling "Draw Scroller",
       which is the routine that finally checks which of them corresponds
       to [Last Locked Scroller], and draws the hole there.)
	[Last Locked Scroller] = [D plus 0];
	D -->;
	=> Refresh Display;
	<-- D;
      "CS Not marking"
      ? [CS Range] <= ZERO -> CS Out of area;
      ? [Scroller Direction] = HORIZONTAL -> CS Parse horizontal track extremes;
      ? [Pointer Y Coordinate] < [Scrollpad Bounds plus 1] -> CS Hovering top track;
      ? [Pointer Y Coordinate] > [Scrollpad Bounds plus 3] -> CS Hovering bottom track;
	-> CS Locked on scrollpad;
      "CS Parse horizontal track extremes"
      ? [Pointer X Coordinate] < [Scrollpad Bounds plus 0] -> CS Hovering top track; (L side of track)
      ? [Pointer X Coordinate] > [Scrollpad Bounds plus 2] -> CS Hovering bottom track; (R side of track)
      "CS Locked on scrollpad"
	[Lock On Scroller] = [D plus 0];
	A = [Arrow X In This Frame];
	A - [Arrow X In Previous Frame];
      ? [Scroller Direction] = HORIZONTAL -> CS Horiz;
	A = [Arrow Y In This Frame];
	A - [Arrow Y In Previous Frame];
      "CS Horiz"
      ? A = ZERO -> CS Out of area;
	A + [D plus 5];
      ? A >= ZERO -> CS Pos high enough;      A = ZERO;       "CS Pos high enough"
      ? A <= [CS Range] -> CS Pos low enough; A = [CS Range]; "CS Pos low enough"
	[D plus 5] = A;
	A * [CS Gap];
	B = A;
	A / [CS Range];
	B % [CS Range];
	C = [CS Range]; C > 1;
      ? B < C -> CS Approximate below;
	A+;
      "CS Approximate below"
	[D plus 8] = A;
	-> CS Reentry after change;
      "CS Hovering top track"
	A = minus 1;
	-> CS Take beat;
      "CS Hovering bottom track"
	A = (plus) 1;
       (-> CS Take beat;)
      "CS Take beat"
	[Timer Command] = READ COUNTS;
	isocall;
	[Scroller adv ticks elapse] = [Counts];
	[Scroller adv ticks elapse] - [Scroller adv ticks former];
	[Scroller adv ticks elapse] / [Counts Per Millisecond];
      ? [Scroller adv ticks elapse] '< [Scroller Adv Ticks Delay] -> CS Out of area;
	[Scroller adv ticks former] = [Counts];
      "CS Reentry after wheel move"
	[D plus 8] + A;
      ? [D plus 8] >= ZERO -> CS Low within window;	 [D plus 8] = ZERO;	"CS Low within window"
      ? [D plus 8] <= [CS Gap] -> CS High within window; [D plus 8] = [CS Gap]; "CS High within window"
	=> USPFR Change on adv;
      "CS Reentry after change"
      ? [D plus 0] + SB NOREDRAW ON CHANGE -> CS Changed but dont redraw;
	[DS Refresh] = YES; => Draw Scroller; [DS Refresh] = NO;
      "CS Changed but dont redraw"
	[Scroller Variation Flag] = ON;
	leave;
      "CS No longer pushing"
	[Lock On Scroller] = UNDEFINED;
	[Scroller adv ticks former] = ZERO;
      "CS Out of area"
	[Scroller Variation Flag] = OFF;
	leave;

    (updates a scroller's scrollpad position to resynchronize it with the
     actual "readout" of the scroller; it's used when the readout is forcely
     moved by the application, normally because it got off the limits of the
     scroller's scope, which may behave differently on a per-application
     basis: variable [Scroller Datascript], before calling this function,
     must be loaded with the pointer to the datascript describing the
     scroller to check; details on scrollers' behaviour can be found in the
     source code of the "Network Node", node.txt; notice that calling this
     function, on itself, does NOT implicitly redraw the scroller, it only
     updates the variable, within the scroller's datascript, which holds the
     actual position, in pixels, of the pad relatively to the scroller's top
     or left edge, depending on the scroller's orientation)

"Update Scroller Position From Readout"
	=> Compute Scroller Dimensions;
	=> Compute Scrollpad Dimensions;
      "USPFR Change on adv"
	A = [D plus 8];
	A * [CS Range];
      ? [CS Gap] = ZERO -> USPFR DBZ Guard;
	A / [CS Gap];
      "USPFR DBZ Guard"
      ? A >= ZERO -> USPFR Pos high enough; A = ZERO; "USPFR Pos high enough"
      ? A <= [CS Range] -> USPFR Pos low enough; A = [CS Range]; "USPFR Pos low enough"
	[D plus 5] = A;
	leave;

    (internal)

    (internal subroutines follow - not intended for direct calls)

"Load Resident Graphics"
	A = ZERO;
	B = RGFX PARTS COUNT;
    "LRG Loop"
	[A relating SX Pointers] = [A relating vector RGFX Buffers];
	[File Name]		 = STOCK FILE;
	[File Command]		 = READ;
	[File Position] 	 = [A relating vector RGFX Positions];
	[Block Pointer] 	 = [A relating vector RGFX Buffers];
	[Block Size]		 = [A relating vector RGFX Sizes];
	isocall;
	A +;
	B ^ LRG Loop;
	leave;

"Shadowline"
	[Shadow Layer Mask] = 1000000h; ? [Current Level In Show] < 0 -> In Root Menu;
	[Shadow Layer Mask] = 2000000h; [Shadow Layer Mask] < [Current Level In Show];
    "In Root Menu"
	[TGA Target Layer] = Backdrop Layer;
      "SL Reentry from balloon"
	[TGA Effect] = service FX Shadow;
	[TGA Display Alignment] = [Display Width];
	[TGA Display Height] = [Display Height];
	[TGA Picture Left] = [SL X Start];
	[TGA Picture Top] = [SL Y Start];
      "SL Loop"
	  ? [SL X Delta] != 0 -> SL Running Horizontally;
	  ? [SL Y Delta] != 0 -> SL Running Vertically;
	"SL Running Horizontally"
	  ? [TGA Picture Left] = [SL X Start] -> SL Left Corner;
	  ? [TGA Picture Left] = [SL X End] -> SL Bottom Right Corner;
	  [TGA Picture Data] = [p Menu Shadow Horizontal];
	  -> SL Intermediate;
	"SL Running Vertically"
	  ? [TGA Picture Top] = [SL Y Start] -> SL Top Corner;
	  ? [TGA Picture Top] = [SL Y End] -> SL Bottom Right Corner;
	  [TGA Picture Data] = [p Menu Shadow Vertical];
	  -> SL Intermediate;
	"SL Left Corner"
	  [TGA Picture Data] = [p Menu Shadow Left Corner];
	  -> SL Intermediate;
	"SL Top Corner"
	  [TGA Picture Data] = [p Menu Shadow Top Corner];
	  -> SL Intermediate;
	"SL Bottom Right Corner"
	  [TGA Picture Data] = [p Menu Shadow Bottom Right Corner];
	  -> SL Intermediate;
	"SL Intermediate"
	  => Load TGA Picture;
	  [TGA Picture Left] + [SL X Delta]; ? [TGA Picture Left] > [SL X End] -> SL Break;
	  [TGA Picture Top] + [SL Y Delta]; ? [TGA Picture Top] > [SL Y End] -> SL break;
	  -> SL Loop;
    "SL Break"
	leave;
    "service FX Shadow"
	? [A] + [Shadow Layer Mask] -> Avoid reshadowing pixel;
	A -->;
	C = [A]; D = C; E = C;
	C & FFh; D & FF00h; E & FF0000h;
	A = B; A & FFh; C - A;
	A = B; A & FF00h; D - A;
	A = B; A & FF0000h; E - A;
	? C >= 0 -> FX Shadow Blue High Ok;
	C = 0;
    "FX Shadow Blue High Ok"
	? D >= 0 -> FX Shadow Green High Ok;
	D = 0;
    "FX Shadow Green High Ok"
	? E >= 0 -> FX Shadow Red High Ok;
	E = 0;
    "FX Shadow Red High Ok"
	C | D;
	C | E;
	<-- A;
	B = [A];
	B & FF000000h;
	B | [Shadow Layer Mask];
	C | B;
	[A] = C;
      "Avoid reshadowing pixel"
	leave;

"PBL Redraw menu"
	[Current Level In Show] = minus 1;
	? [Menu On] = NO -> GUI Not showing menu;
	[FS On] = NO;
	[OnScreen Menu Options] = ZERO;
	[SML Attr] = NULL;
	[SML Code Mask] = 00FFFFFFh;
	[SML Code Low]	= 01000000h;
	[SML Code High] = FF000000h;
	[SML Left] = [Display Width];
	[SML Left] - 126;
	[SML Left] + [Menu Padding];
	[SML Left] + [Menu Borders];
	[SML Top] = 25;
	[SML Top] + [Menu Padding];
	[SML Top] + [Menu Borders];
	[SML Top] + [Menu Cell Spacing];
	[SML Width] = 1;
	[SML Height] = 1;
	[Text Ghost Mode] = ON;
	=> Show Menu Level;
	A = vector Menu Level Bounds;
	[A plus 0] = [SML Left];
	[A plus 1] = [SML Top];
	[A plus 2] = [SML Left]; [A plus 2] + [SML Width];
	[A plus 3] = [SML Top]; [A plus 3] + [SML Height];
	[A plus 0] - [Menu Padding];
	[A plus 1] - [Menu Padding];
	[A plus 2] + [Menu Padding];
	[A plus 3] + [Menu Padding];
	[A plus 0] - [Menu Borders];
	[A plus 1] - [Menu Borders];
	[A plus 2] + [Menu Borders];
	[A plus 3] + [Menu Borders];
	[Region To Normalize] = vector Menu Level Bounds;
	=> Normalize Region;
	[SL X Start] = [vector Menu Level Bounds plus 0];
	[SL Y Start] = [vector Menu Level Bounds plus 3];
	[SL X End]   = [vector Menu Level Bounds plus 2];
	[SL Y End]   = [SL Y Start];
	[SL X Delta] = 1;
	[SL Y Delta] = 0;
	=> Shadowline;
	[SL X Start] = [vector Menu Level Bounds plus 2];
	[SL Y Start] = [vector Menu Level Bounds plus 1];
	[SL X Delta] = 0;
	[SL Y Delta] = 1;
	=> Shadowline;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector Menu Level Bounds;
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Effect] = service FX Raw;
	[Rectangle Gradients] = vector Menu Borders Colors;
	=> Rectangle;
	A = vector Menu Level Bounds;
	[A plus 0] + [Menu Borders];
	[A plus 1] + [Menu Borders];
	[A plus 2] - [Menu Borders];
	[A plus 3] - [Menu Borders];
	[Region To Normalize] = vector Menu Level Bounds;
	=> Normalize Region;
	[TR Bounds] = vector Menu Level Bounds;
	[TR Picture Data] = [p Menu Filler];
	[TR Target Layer] = Backdrop Layer;
	[TR Display Alignment] = [Display Width];
	[TR Effect] = service FX Raw;
	=> Tile Region;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector Menu Level Bounds;
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Effect] = service FX Alpha Light;
	[Rectangle Gradients] = vector Menu Background Colors;
	=> Rectangle;
	[Text Ghost Mode] = OFF;
	=> Show Menu Level;
	[Current Level In Show] = ZERO;
	    "GUI Showing submenus"
		? [Current Level In Show] >= [OnScreen Menu Levels] -> GUI No more levels;
		A = [Current Level In Show];
		[SML Attr] = [A plus vector Menu Level OS Attr];
		[SML Code Mask] = [A plus vector Menu Level OS Mask];
		[SML Code Low] = [A plus vector Menu Level OS Low];
		[SML Code High] = [A plus vector Menu Level OS High];
		[SML Left] = [A plus vector Menu Level OS X];
		[SML Left] - [Menu Padding];
		[SML Left] - [Menu Borders];
		[SML Top] = [A plus vector Menu Level OS Y];
		[SML Top] + [Menu Spacing];
		[SML Top] + [Menu Borders];
		[SML Width] = 1;
		[SML Height] = 1;
		[Text Ghost Mode] = ON;
		=> Show Menu Level;
		A = [Current Level In Show];
		[SML Left] = [A plus vector Menu Level OS X];
		[SML Left] - [Menu Padding];
		[SML Left] - [Menu Padding];
		[SML Left] - [Menu Borders];
		[SML Left] - [Menu Borders];
		[SML Left] - [SML Width];
		A = vector Menu Level Bounds;
		[A plus 0] = [SML Left];
		[A plus 1] = [SML Top];
		[A plus 2] = [SML Left]; [A plus 2] + [SML Width];
		[A plus 3] = [SML Top]; [A plus 3] + [SML Height];
		[A plus 0] - [Menu Padding];
		[A plus 1] - [Menu Padding];
		[A plus 2] + [Menu Padding];
		[A plus 3] + [Menu Padding];
		[A plus 0] - [Menu Borders];
		[A plus 1] - [Menu Borders];
		[A plus 2] + [Menu Borders];
		[A plus 3] + [Menu Borders];
		[Region To Normalize] = vector Menu Level Bounds;
		=> Normalize Region;
		[SL X Start] = [vector Menu Level Bounds plus 0];
		[SL Y Start] = [vector Menu Level Bounds plus 3];
		[SL X End]   = [vector Menu Level Bounds plus 2];
		[SL Y End]   = [SL Y Start];
		[SL X Delta] = 1;
		[SL Y Delta] = 0;
		=> Shadowline;
		[SL X Start] = [vector Menu Level Bounds plus 2];
		[SL Y Start] = [vector Menu Level Bounds plus 1];
		[SL X Delta] = 0;
		[SL Y Delta] = 1;
		=> Shadowline;
		[Rectangle Display Alignment] = [Display Width];
		[Rectangle Bounds] = vector Menu Level Bounds;
		[Rectangle Target Layer] = Backdrop Layer;
		[Rectangle Effect] = service FX Raw;
		[Rectangle Gradients] = vector Menu Borders Colors;
		=> Rectangle;
		A = vector Menu Level Bounds;
		[A plus 0] = [SML Left];
		[A plus 1] = [SML Top];
		[A plus 2] = [SML Left]; [A plus 2] + [SML Width];
		[A plus 3] = [SML Top]; [A plus 3] + [SML Height];
		[A plus 0] - [Menu Padding];
		[A plus 1] - [Menu Padding];
		[A plus 2] + [Menu Padding];
		[A plus 3] + [Menu Padding];
		[Region To Normalize] = vector Menu Level Bounds;
		=> Normalize Region;
		[TR Bounds] = vector Menu Level Bounds;
		[TR Picture Data] = [p Menu Filler];
		[TR Target Layer] = Backdrop Layer;
		[TR Display Alignment] = [Display Width];
		[TR Effect] = service FX Raw;
		=> Tile Region;
		[Rectangle Display Alignment] = [Display Width];
		[Rectangle Bounds] = vector Menu Level Bounds;
		[Rectangle Target Layer] = Backdrop Layer;
		[Rectangle Effect] = service FX Alpha Light;
		[Rectangle Gradients] = vector Menu Background Colors;
		=> Rectangle;
		[Text Ghost Mode] = OFF;
		=> Show Menu Level;
		[Current Level In Show]+;
		-> GUI Showing submenus;
	    "GUI No more levels"
    "GUI Not showing menu"
	leave;

"Reset Pulldown Menu"
      ? [Menu On] = YES -> RPM Its not necessary to deselect the actual scroller;
	[Last Locked Scroller] = UNDEFINED;
      "RPM Its not necessary to deselect the actual scroller"
	[Last Lit Option] = UNDEFINED;
	[OnScreen Menu Levels] = ZERO;
	[OnScreen Menu Options] = ZERO;
	[Balloon Text String] = NULL;
      ? [Lock On Scroller] != [vector FS Scroller] -> RPM FS scroller unlocked;
	[Lock On Scroller] = UNDEFINED;
      "RPM FS scroller unlocked"
      ? [Prefileselect Directory] = NULL -> RPM No recorded path changes;
	[File Command] = SET DIR;
	[File Name] = Prefileselect Directory;
	isocall;
	[Prefileselect Directory] = NULL;
      "RPM No recorded path changes"
	leave;

"Show Menu Level"
	? [SML Attr] + OPTION TYPE FILE SELECTOR -> Show File Selector;
	A = ZERO;
	[SML Option Top] = [SML Top];
	[First Option In Level] = IS FIRST OPTION IN LEVEL;
    "SML Parsing menu"
	? A >= [Installed Menu Options] -> SML Stop parsing menu;
		B = [A plus vector Menu Option Code];
		? B + [SML Code Mask] -> SML Skip option;
		? B '< [SML Code Low] -> SML Skip option;
		? B '> [SML Code High] -> SML Skip option;
		? [OnScreen Menu Options] >= MAX ONSCREEN OPTIONS -> SML Skip option;
			C = ZERO;
			D = [A plus vector Menu Option String];
		    "SML Copying option string"
			[C plus vector SML String buffer] = [D];
			? [D] = NULL -> SML Finished copying option string;
			C+; D+; -> SML Copying option string;
		    "SML Finished copying option string"
			A-->;
				[String]		= vector SML String buffer;
				[Ink]			= [Menu Text Color];
				? [A plus vector Menu Option Attributes] - OPTION TYPE DISABLED -> SML Option Enabled;
				[Ink]			= [Menu Disabled Text Color];
			    "SML Option Enabled"
				[Text X]		= [SML Left];
				? [Text Ghost Mode] = OFF -> SML Really writing;
				[Text X]		= ZERO;
			    "SML Really writing"
				[Text Y]		= [SML Option Top];
				[Text Effect]		= [Menu Text Effect];
				[Text Display Width]	= [Display Width];
				[Text Display Height]	= [Display Height];
				[Text Display Origin]	= Backdrop Layer;
				[Text Region]		= NULL;
				[Text Window]		= NULL;
				[Text Word Wrap]	= OFF;
				=> STD Write;
				? [Text Ghost Mode] = ON -> SML Not really writing;
				<--A;
					E = [OnScreen Menu Options];
					B = [A plus vector Menu Option String];
					[E plus vector Menu Option OS Code] = [A plus vector Menu Option Code];
					[E plus vector Menu Option OS Attr] = [A plus vector Menu Option Attributes];
					[E plus vector Menu Option OS Man] = [A plus vector Menu Option Manager];
					[E plus vector Menu Option OS X] = [SML Left];
					[E plus vector Menu Option OS X] - [Menu Padding];
					[E plus vector Menu Option OS X] - [Menu Borders];
					[E plus vector Menu Option OS Y] = [SML Option Top];
					[E plus vector Menu Option OS Y] - [Menu Spacing];
					[E plus vector Menu Option OS W] = [SML Width];
					[E plus vector Menu Option OS W] + [Menu Padding];
					[E plus vector Menu Option OS W] + [Menu Padding];
					[E plus vector Menu Option OS W] + [Menu Borders];
					[E plus vector Menu Option OS W] + [Menu Borders];
					[E plus vector Menu Option OS H] = [Height Of Latest Form];
					[E plus vector Menu Option OS H] + [Menu Spacing];
					[E plus vector Menu Option OS Flags] = [First Option In Level];
				      ? [First Option In Level] = ZERO -> SML Dont take note;
					[First Option In Level] = ZERO;
					[Last Level First Option Index] = [OnScreen Menu Options];
				      "SML Dont take note"
					[OnScreen Menu Options]+;
				A-->;
			    "SML Not really writing"
				[SML Option Top] + [Menu Spacing];
				[SML Option Top] + [Height Of Latest Form];
				? [Width Of Latest Form] <= [SML Width] -> SML No width record;
				[SML Width] = [Width Of Latest Form];
			    "SML No width record"
				A = [SML Width];		  (1)
				A + [Menu Borders];		  (2)
				A + [Menu Padding];		  (3)
				A + [Menu Cell Spacing];	  (4 - just for the sake of simmetry)
				A + 2;				  (5 - considering black 1px edge)
				B = [SML Left];
				B + A;
				? B < [Display Width] -> SML No right margin correction;
				[SML Left] = [Display Width];
				[SML Left] - A;
			    "SML No right margin correction"
			<--A;
	    "SML Skip option"
	A+; -> SML Parsing menu;
    "SML Stop parsing menu"
	[SML Height] = [SML Option Top];
	[SML Height] - [SML Top];
	[SML Height] - [Menu Spacing];
	A = [SML Height]; A + [SML Top];
	A + [Menu Padding]; A + [Menu Borders];
	? A < [Display Height] -> SML No bottom margin correction;
	[SML Top] = [Display Height];
	[SML Top]-;
	[SML Top] - [SML Height];
	[SML Top] - [Menu Padding];
	[SML Top] - [Menu Borders];
	B = 25; B + [Menu Padding]; B + [Menu Borders];
	? [SML Top] >= B -> SML No bottom margin correction;
	[SML Top] = B;
    "SML No bottom margin correction"
	? [First Option In Level] = IS FIRST OPTION IN LEVEL -> SML Void Level;
	E = [OnScreen Menu Options]; E-;
	[E plus vector Menu Option OS Flags] | IS LAST OPTION IN LEVEL;
    "SML Void Level"
	leave;

"Show File Selector"
	[FS On] = YES;
	[SML Width] = [File Selector Width];
	[SML Width] + [File Selector Scrollbar Width];
	A = [SML Width]; A + [SML Left];
	A + [Menu Padding]; A + [Menu Borders];
      ? A < [Display Width] -> SFS No right margin correction;
	[SML Left] = [Display Width];
	[SML Left] - [Menu Padding];
	[SML Left] - [Menu Borders];
	[SML Left] - [SML Width];
      "SFS No right margin correction"
	A = vector FS Text Region;
	[A plus 0] = [SML Left];
	[A plus 1] = [SML Top];
	[A plus 2] = [SML Left];
	[A plus 2] + [File Selector Width];
	[A plus 3] = [Display Height];
	A = [vector FS Scroller plus SCROLLER READOUT];
	[SML Code High] = [Number of files in table];
      ? [SML Code High] <= MAX FILES IN SHOW -> SFS CH In range;
	[SML Code High] = MAX FILES IN SHOW;
      "SFS CH In range"
	[SML Code High] + A;
	[First Option In Level] = IS FIRST OPTION IN LEVEL;
	[Number of FS objects in show] = ZERO;
	[SML Option Top] = [SML Top];
    "SFS Parsing menu"
	? A >= [SML Code High] -> SFS Stop parsing menu;
	? A >= [Number of files in table] -> SFS Stop parsing menu;
	? [OnScreen Menu Options] >= MAX ONSCREEN OPTIONS minus 1 -> SFS Stop parsing menu;
	[Ink] = [Menu Text Color];
      ? A >= [Number of dirs in table] -> SFS Show as file;
	[Ink] = [Directory Name Color];
      "SFS Show as file"
	C = ZERO;
	D = [A plus vector File indexs table];
	D < 8; D + vector File names table;
    "SFS Copying option string"
	[C plus vector SML String buffer] = [D];
      ? [D] = ZERO -> SFS Finished copying option string;
	C+; D+; -> SFS Copying option string;
      "SFS Finished copying option string"
	[String]		= vector SML String buffer;
	[Text X]		= [SML Left];
	[Text Y]		= [SML Option Top];
	[Text Effect]		= [Menu Text Effect];
	[Text Display Width]	= [Display Width];
	[Text Display Height]	= [Display Height];
	[Text Display Origin]	= Backdrop Layer;
	[Text Region]		= vector FS Text Region;
	[Text Window]		= NULL;
	[Text Word Wrap]	= OFF;
	A -->;
	=> STD Write;
	<-- A;
      ? [Text Ghost Mode] = ON -> SFS Not Really writing j1;
	E = [OnScreen Menu Options];
	[E plus vector Menu Option OS Code] = A;
	[E plus vector Menu Option OS Attr] = OPTION TYPE FILENAME;
	[E plus vector Menu Option OS X] = [SML Left];
	[E plus vector Menu Option OS X] - [Menu Padding];
	[E plus vector Menu Option OS X] - [Menu Borders];
	[E plus vector Menu Option OS Y] = [SML Option Top];
	[E plus vector Menu Option OS Y] - [Menu Spacing];
	[E plus vector Menu Option OS W] = [SML Width];
	[E plus vector Menu Option OS W] + [Menu Padding];
	[E plus vector Menu Option OS W] + [Menu Padding];
	[E plus vector Menu Option OS W] + [Menu Borders];
	[E plus vector Menu Option OS W] - [File Selector Scrollbar Width];
	[E plus vector Menu Option OS H] = [Height Of Latest Form];
	[E plus vector Menu Option OS H] + [Menu Spacing];
	[E plus vector Menu Option OS Flags] = [First Option In Level];
      ? [First Option In Level] = ZERO -> SFS Dont take note;
	[First Option In Level] = ZERO;
	[Last Level First Option Index] = [OnScreen Menu Options];
      "SFS Dont take note"
	[OnScreen Menu Options]+;
    "SFS Not really writing j1"
	[SML Option Top] + [Height Of Latest Form];
	[SML Option Top] + [Menu Spacing];
	[Number of FS objects in show]+;
	A+;
	-> SFS Parsing menu;
    "SFS Stop parsing menu"
      ? [Text Ghost Mode] = ON -> SFS Not really writing j2;
	E = [OnScreen Menu Options]; [FNB Option ID] = E;
	[E plus vector Menu Option OS Code] = [SML Code High];
	[E plus vector Menu Option OS Attr] = OPTION TYPE FILENAMEBOX;
	[E plus vector Menu Option OS X] = [SML Left];
	[E plus vector Menu Option OS X] - [Menu Padding];
	[E plus vector Menu Option OS X] - [Menu Borders];
	[E plus vector Menu Option OS Y] = [SML Option Top];
	[E plus vector Menu Option OS Y] - [Menu Spacing];
	[E plus vector Menu Option OS W] = [SML Width];
	[E plus vector Menu Option OS W] + [Menu Padding];
	[E plus vector Menu Option OS W] + [Menu Padding];
	[E plus vector Menu Option OS W] + [Menu Borders];
	[E plus vector Menu Option OS W] + [Menu Borders];
	[E plus vector Menu Option OS H] = [Height Of Latest Form];
	[E plus vector Menu Option OS H] + [Menu Spacing];
	[E plus vector Menu Option OS Flags] = [First Option In Level];
	[E plus vector Menu Option OS Flags] | IS LAST OPTION IN LEVEL;
	B = vector FSTF;
	[B plus 0] = [E plus vector Menu Option OS X];
	[B plus 0] + [Menu Padding];
	[B plus 0] + [Menu Borders];
	[B plus 1] = [E plus vector Menu Option OS Y];
	[B plus 1] + [Menu Spacing];
	[B plus 2] = [E plus vector Menu Option OS X];
	[B plus 2] + [E plus vector Menu Option OS W];
	[B plus 2] - [Menu Padding];
	[B plus 2] - [Menu Borders];
	[B plus 3] = [E plus vector Menu Option OS Y];
	[B plus 3] + [E plus vector Menu Option OS H];
	[Region To Normalize] = vector FSTF;
	=> Normalize Region;
	A = vector FSTF;
	B = vector Menu Option Bounds;
	[B plus 0] = [A plus 0];
	[B plus 0] - [Menu Padding];
	[B plus 1] = [A plus 1];
	[B plus 1] - [Menu Spacing];
	[B plus 2] = [A plus 2];
	[B plus 2] + [Menu Padding];
	[B plus 3] = [B plus 1];
	[Rectangle Effect] = service FX Raw;
	[Rectangle Gradients] = vector Standard Black Gradients;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector Menu Option Bounds;
	[Rectangle Target Layer] = Backdrop Layer;
	=> Rectangle;
	[OnScreen Menu Options]+;
	[Text Field Data] = vector FSTF;
	[Text Field Buffer] = vector File name box buffer;
	[Is Active Text Field] = YES;
	[Text Field Behavior] = TXF NOUPDATE;
	=> CTF Refresh;
	A = vector Menu Level Bounds;
	B = vector FS Body Bounds;
	[B plus 0] = [A plus 0];
	[B plus 1] = [A plus 1];
	[B plus 2] = [A plus 2];
	[B plus 3] = [A plus 3];
      "SFS Not really writing j2"
      ? [Text Ghost Mode] = ON -> SFS Not really writing j3;
	[vector FS Scroller plus 1] = [SML Left];
	[vector FS Scroller plus 1] + [SML Width];
	[vector FS Scroller plus 1] + [Menu Padding];
	[vector FS Scroller plus 1] - [File Selector Scrollbar Width];
	[vector FS Scroller plus 1] +;
	[vector FS Scroller plus 2] = [SML Top];
	[vector FS Scroller plus 2] - [Menu Spacing];
	[vector FS Scroller plus 3] = [vector FS Scroller plus 1];
	[vector FS Scroller plus 3] + [File Selector Scrollbar Width];
	[vector FS Scroller plus 3] -;
	[vector FS Scroller plus 4] = [SML Option Top];
	[vector FS Scroller plus 4] - [Menu Spacing];
	[vector FS Scroller plus 4] -;
	[vector FS Scroller plus SCROLLER WINDOW] = [Number of FS objects in show];
	B = vector FS Scroller plus 1;
	[B plus 2] -->;
	[B plus 0] -->;
	B -->;
	[B plus 2] = [B plus 0];
	[B plus 2] -;
	[B plus 0] -;
	[Rectangle Effect] = service FX Raw;
	[Rectangle Gradients] = vector Standard Black Gradients;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = B;
	[Rectangle Target Layer] = Backdrop Layer;
	=> Rectangle;
	<-- B;
	<-- [B plus 0];
	<-- [B plus 2];
	[Scroller Datascript] = vector FS Scroller;
	=> Draw Scroller;
      "SFS Not really writing j3"
	[SML Option Top] + [Menu Spacing];
	[SML Option Top] + [Height Of Latest Form];
	[SML Height] = [SML Option Top];
	[SML Height] - [SML Top];
	[SML Height] - [Menu Spacing];
	A = [SML Height]; A + [SML Top];
	A + [Menu Padding]; A + [Menu Borders];
	? A < [Display Height] -> SFS No bottom margin correction;
	[SML Top] = [Display Height];
	[SML Top] -;
	[SML Top] - [SML Height];
	[SML Top] - [Menu Padding];
	[SML Top] - [Menu Borders];
	B = 25; B + [Menu Padding]; B + [Menu Borders];
      ? [SML Top] >= B -> SFS No bottom margin correction;
	[SML Top] = B;
      "SFS No bottom margin correction"
	leave;

"Update Menu Option Appearence"
	A = [Examined Option];
	B = vector Menu Option Bounds;
	[B plus 0] = [A plus vector Menu Option OS X];
	[B plus 1] = [A plus vector Menu Option OS Y];
	[B plus 2] = [A plus vector Menu Option OS X];
	[B plus 3] = [A plus vector Menu Option OS Y];
	[B plus 2] + [A plus vector Menu Option OS W];
	[B plus 3] + [A plus vector Menu Option OS H];
	[B plus 3] + [Menu Spacing];
	? [A plus vector Menu Option OS Flags] - IS FIRST OPTION IN LEVEL -> UMOA Not 1st;
	[B plus 1] - [Menu Borders];
    "UMOA Not 1st"
	? [A plus vector Menu Option OS Flags] - IS LAST OPTION IN LEVEL -> UMOA Not last;
	[B plus 3] + [Menu Borders];
    "UMOA Not last"
	[Region To Normalize] = vector Menu Option Bounds;
	=> Normalize Region;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = vector Menu Option Bounds;
	[Rectangle Target Layer] = Backdrop Layer;
	=> Rectangle;
	[L2L Region] = vector Menu Option Bounds;
	-> Update Area;

"service While Hovering Menu Option"
	[Client Owns Mouse Pointer] = NO;
	leave;

"service When Hovering Menu Option"
	[Last Lit Option] = [Examined Option];
	[Rectangle Effect] = [Selected Option Effect];
	[Rectangle Gradients] = vector Selected Option Colors;
	=> Update Menu Option Appearence;
	A = [Examined Option];
	? [A plus vector Menu Option OS Attr] - OPTION TYPE FILENAME -> WHMO No balloon indication;
	B = [A plus vector Menu Option OS Code];
	[Balloon Text String] = [B plus vector File indexs table];
	[Balloon Text String] < 8;
	[Balloon Text String] + vector File names table;
	B = [Balloon Text String];
	? [B plus 0] != 47 -> WHMO Not the root directory;     (/)
	? [B plus 1] != 00 -> WHMO Not the root directory;    (null)
	[Balloon Text String] = Root Directory Description;
	-> WHMO Using expanded directory description;
      "WHMO Not the root directory"
	? [B plus 0] != 46 -> WHMO Not the startup directory;  (.)
	? [B plus 1] != 00 -> WHMO Not the startup directory; (null)
	[Balloon Text String] = Startup Directory Description;
	-> WHMO Using expanded directory description;
      "WHMO Not the startup directory"
	? [B plus 0] != 46 -> WHMO Not the parent directory;   (.)
	? [B plus 1] != 46 -> WHMO Not the parent directory;   (.)
	? [B plus 2] != 00 -> WHMO Not the parent directory;  (null)
	[Balloon Text String] = Parent Directory Description;
      "WHMO Not the parent directory" (or) "WHMO Using expanded directory description"
	[Is Menu Balloon] = YES;
	leave;
   "WHMO No balloon indication"
	[Balloon Text String] = NULL;
	[Is Menu Balloon] = NO;
	leave;

"service When No Longer Hovering Menu Option"
	? [Is Menu Balloon] = NO -> WNLHMO No balloon indication;
	[Balloon Text String] = NULL;
	[Is Menu Balloon] = NO;
    "WNLHMO No balloon indication"
	=> PBL Redraw menu;
	A = [Examined Option]; => WNLHMO Update appearence of option pointed by A;
	A = [Last Lit Option]; => WNLHMO Update appearence of option pointed by A;
	leave;
    "WNLHMO Update appearence of option pointed by A"
	? A = UNDEFINED -> WNLHMO Do nothing;
	B = vector Menu Option Bounds;
	[B plus 0] = [A plus vector Menu Option OS X];
	[B plus 1] = [A plus vector Menu Option OS Y];
	[B plus 2] = [A plus vector Menu Option OS X];
	[B plus 3] = [A plus vector Menu Option OS Y];
	[B plus 2] + [A plus vector Menu Option OS W];
	[B plus 3] + [A plus vector Menu Option OS H];
	[B plus 3] + [Menu Spacing];
	? [A plus vector Menu Option OS Flags] - IS FIRST OPTION IN LEVEL -> WNLHMO Not 1st;
	[B plus 1] - [Menu Borders];
    "WNLHMO Not 1st"
	? [A plus vector Menu Option OS Flags] - IS LAST OPTION IN LEVEL -> WNLHMO Not last;
	[B plus 3] + [Menu Borders];
    "WNLHMO Not last"
	[Region To Normalize] = vector Menu Option Bounds;
	=> Normalize Region;
	[L2L Region] = vector Menu Option Bounds;
	=> Update Area;
	isocall;
    "WNLHMO Do nothing"
	leave;

"service When Pushing Menu Option"
	[Rectangle Effect] = [Pushed Option Effect];
	[Rectangle Gradients] = vector Pushed Option Colors;
	-> Update Menu Option Appearence;

"service Menu Option Action"
	A = [Examined Option];
	? [A plus vector Menu Option OS Attr] - OPTION TYPE SUBMENU plus OPTION TYPE FILE SELECTOR
		-> GUI Not a submenu;
	? [OnScreen Menu Levels] >= MAX LEVELS IN SHOW
		-> GUI Cant warn application;
	B = ZERO;
	C = 01000000h;
	D = FF000000h;
	E = 00FFFFFFh;
    "GUI Submenu level search"
	? [A plus vector Menu Option OS Code] - D -> GUI Submenu level found;
	C > 8;
	D > 8;
	E > 8;
	B+; -> GUI Submenu level search;
    "GUI Submenu level found"
	? B = ZERO -> GUI Submenu declaration error;
	---->;
		A = [Examined Option];
	      ? [A plus vector Menu Option OS Man] = NULL -> GUI No option manager;
		=> [A plus vector Menu Option OS Man];
	      "GUI No option manager"
	<----;
	B-;
	[B plus vector Menu Level OS Attr] = [A plus vector Menu Option OS Attr];
	[B plus vector Menu Level OS Mask] = E;
	[B plus vector Menu Level OS Low]  = [A plus vector Menu Option OS Code];
	[B plus vector Menu Level OS Low]  + C;
	[B plus vector Menu Level OS High] = [A plus vector Menu Option OS Code];
	[B plus vector Menu Level OS High] + D;
	[B plus vector Menu Level OS X]    = [A plus vector Menu Option OS X];
	[B plus vector Menu Level OS X]    + [Menu Padding];
	[B plus vector Menu Level OS X]    + [Menu Borders];
	[B plus vector Menu Level OS X]    - [Menu Cell Padding];
	[B plus vector Menu Level OS X]    -;
	[B plus vector Menu Level OS Y]    = [A plus vector Menu Option OS Y];
	[B plus vector Menu Level OS Y]    - [Menu Borders];
	[B plus vector Menu Level OS Y]    + [Menu Cell Spacing];
	? [A plus vector Menu Option OS Attr] - OPTION TYPE FILE SELECTOR -> GUI Normal submenu;
	[Last Locked Scroller] = [SCROLLER IDENTITY relating vector FS scroller];
       (the above will cause the newly open file selector's scroller to capture mouse wheel
	input: this capture will be released upon closing the menu, where the subroutine
	"Reset Pulldown Menu" executes this same instrucion if it's called after setting
	[Menu On] = NO, that is, if it's called after closing the popup menu; upon opening
	the menu, instead, the focused scroller is left unchanged, to interfere as little
	as possible with the client application: in fact, it will still be possible, if the
	application wants to allow it, to scroll something in the work area even though the
	pulldown menu is on display: due to the iGUI's triple buffering this is perfectly
	possible, so why should I remove a possibility? if the client application wants to
	disallow that, it will be sufficient for it to check wether [Menu On] = YES before
	checking the relevant scrollers...)
	=> GUI Make file selector;
    "GUI Normal submenu"
	B+;
    "GUI Submenu declaration error"
	[OnScreen Menu Levels] = B;
	-> Refresh Display;
    "GUI Not a submenu"
	A = [Examined Option];
	C = vector File name box buffer;
	? [A plus vector Menu Option OS Attr] + OPTION TYPE FILENAMEBOX -> GUI Return path and file;
	? [A plus vector Menu Option OS Attr] - OPTION TYPE FILENAME -> GUI Normal option;
	B = [A plus vector Menu Option OS Code];
	C = [B plus vector File indexs table];
	C < 8; C + vector File names table;
	? B < [Number of dirs in table] -> GUI This is no file;
    "GUI Return path and file"
	[File Command] = GET DIR;
	[File Name] = vector Selected File Name;
	isocall;
	E = minus 1;
      "GUI Path scan loop"
	E+; ? [E plus vector Selected File Name] != NULL -> GUI Path scan loop;
	[E plus vector Selected File Name] = 47; E+;
      "GUI Copy file name"
	[E plus vector Selected File Name] = [C]; C+; E+;
	? [C minus 1] != ZERO -> GUI Copy file name;
	? [File Selector Filter] = NULL -> GUI No filter to append;
	A = [File Selector Filter];
	E -; (make E point to name's null terminator, not above)
      "GUI Find filter terminator"
	? [A] = NULL -> GUI Filter terminated;
	A+; -> GUI Find filter terminator;
      "GUI Filter terminated"
	C = A; C - [File Selector Filter];
	? C = ZERO -> GUI No filter to append; (void filter?!)
	A -->; E -->;
      "GUI Check for filter typed by user"
	[FT Char1] = [A minus 1];
	[FT Char2] = [E plus vector Selected File Name minus 1];
	? [FT Char1] < 97 -> GUI Filter compare ucase1;
	? [FT Char1] > 122 -> GUI Filter compare ucase1;
	[FT Char1] - 32;
      "GUI Filter compare ucase1"
	? [FT Char2] < 97 -> GUI Filter compare ucase2;
	? [FT Char2] > 122 -> GUI Filter compare ucase2;
	[FT Char2] - 32;
      "GUI Filter compare ucase2"
	? [FT Char1] = [FT Char2] -> GUI Filter go on checking;
	<-- E; <-- A; -> GUI Must append filter;
      "GUI Filter go on checking"
	A-; E-; C ^ GUI Check for filter typed by user;
	<-- E; <-- A; -> GUI No filter to append; (typed by user)
      "GUI Must append filter"
	A - [File Selector Filter]; B = 510; B - A;
	? E >= B -> GUI No filter to append; (no room)
	C = [File Selector Filter];
      "GUI Append file filter"
	[E plus vector Selected File Name] = [C]; C+; E+;
	? [C minus 1] != ZERO -> GUI Append file filter;
      "GUI No filter to append"
	? [On File Select] = NULL -> GUI Cant warn application;
	=> [On File Select];
	-> GUI Finished processing option;
    "GUI This is no file"
	? [C plus 0] != 46 -> GUI Not the startup directory;  (.)
	? [C plus 1] != 00 -> GUI Not the startup directory; (null)
	C = Startup Directory;
      "GUI Not the startup directory"
	? [Prefileselect Directory] != NULL -> GUI Prefileselect path already preserved;
	[File Command] = GET DIR;
	[File Name] = Prefileselect Directory;
	isocall;
      "GUI Prefileselect path already preserved"
	[File Command] = SET DIR;
	[File Name] = C;
	isocall;
	=> GUI Make file selector;
	-> Refresh Display;
    "GUI Normal option"
	? [A plus vector Menu Option OS Man] = NULL -> GUI Cant warn application;
	=> [A plus vector Menu Option OS Man];
    "GUI Cant warn application" (or) "GUI Finished processing option"
	[FS On] = NO;
	[Menu On] = NO;
	=> Reset Pulldown Menu;
	-> Refresh Display;

"GUI Make file selector"
	[Balloon Text String] = null; (clear eventual previous file selector's tooltip)
	A = ZERO;
	[FS Get First] = GET FIRST DIR;
	[FS Get Next] = GET NEXT DIR;
    "GUI FS Rescan"
	[File Command] = [FS Get First];
    "GUI Get files table"
	? A >= MAX FILES IN SELECTOR -> GUI End files table;
	[A plus vector File indexs table] = A;
	[File Name] = A; [File Name] < 8; [File Name] + vector File names table;
	isocall; ? failed -> GUI End files table;
	? [File Selector Filter] = NULL -> GUI GFT Filename matching selection criteria;
	? [FS Get First] = GET FIRST DIR -> GUI GFT Filename matching selection criteria;
	C = [File Name];
    "GUI GFT Find end of filename"
	? [C] = ZERO -> GUI GFT End filename;
	C+; -> GUI GFT Find end of filename;
    "GUI GFT End filename"
	D = [File Selector Filter];
    "GUI GFT Find end of FSF"
	? [D] = ZERO -> GUI GFT End FSF;
	D+; -> GUI GFT Find end of FSF;
    "GUI GFT End FSF"
	C-; ? C < [File Name] -> GUI GFT Filename not matching selection criteria;
	D-; ? D < [File Selector Filter] -> GUI GFT Filename matching selection criteria;
	[FT Char1] = [C];
	[FT Char2] = [D];
	? [FT Char1] < 97 -> GUI FT Filter compare ucase1;
	? [FT Char1] > 122 -> GUI FT Filter compare ucase1;
	[FT Char1] - 32;
    "GUI FT Filter compare ucase1"
	? [FT Char2] < 97 -> GUI FT Filter compare ucase2;
	? [FT Char2] > 122 -> GUI FT Filter compare ucase2;
	[FT Char2] - 32;
    "GUI FT Filter compare ucase2"
	? [FT Char1] != [FT Char2] -> GUI GFT Filename not matching selection criteria;
	-> GUI GFT End FSF;
    "GUI GFT Filename matching selection criteria"
	A+;
    "GUI GFT Filename not matching selection criteria"
	[File Command] = [FS Get Next];
	-> GUI Get files table;
    "GUI End files table"
	? [FS Get First] = GET FIRST FILE -> GUI End both runs;
	[Number of dirs in table] = A;
	[FS Get First] = GET FIRST FILE;
	[FS Get Next] = GET NEXT FILE;
	-> GUI FS Rescan;
    "GUI End both runs"
	[Number of files in table] = A;
	B -->;
	A = 3; (<--- avoid / . and ..) B = [Number of dirs in table]; => GUI FT Bubblesort run;
	A = [Number of dirs in table]; B = [Number of files in table]; => GUI FT Bubblesort run;
	<-- B;
	[vector FS Scroller plus SCROLLER PAD POSITION] = ZERO;
	[vector FS Scroller plus SCROLLER READOUT] = ZERO;
	[vector FS Scroller plus SCROLLER SCOPE] = [Number of files in table];
	[vector FSTF plus 4] = ZERO;
	[vector FSTF plus 5] = ZERO;
	[vector FSTF plus 6] = ZERO;
	[vector File name box buffer] = NULL;
	leave;
    "GUI FT Bubblesort run"
	A -->;
	C = A; C+;
	[FT Bubble Flag] = FALSE;
    "GUI FT Bubblesort inner loop"
	? C >= B -> GUI FT Bubblesort inner loop end;
	D = [A plus vector File indexs table]; D < 8; D + vector File names table;
	E = [C plus vector File indexs table]; E < 8; E + vector File names table;
    "GUI FT Bubblesort compare"
	[FT Char1] = [D];
	[FT Char2] = [E];
	? [FT Char1] < 97 -> GUI FT Bubblesort compare ucase1;
	? [FT Char1] > 122 -> GUI FT Bubblesort compare ucase1;
	[FT Char1] - 32;
    "GUI FT Bubblesort compare ucase1"
	? [FT Char2] < 97 -> GUI FT Bubblesort compare ucase2;
	? [FT Char2] > 122 -> GUI FT Bubblesort compare ucase2;
	[FT Char2] - 32;
    "GUI FT Bubblesort compare ucase2"
	? [FT Char1] = NULL -> GUI FT Bubblesort compare end;
	? [FT Char2] = NULL -> GUI FT Bubblesort compare end;
	? [FT Char2] > [FT Char1] -> GUI FT Bubblesort compare end;
	? [FT Char2] < [FT Char1] -> GUI FT Bubblesort compare exchange;
	D+;
	E+;
	-> GUI FT Bubblesort compare;
    "GUI FT Bubblesort compare exchange"
	[A plus vector File indexs table] <> [C plus vector File indexs table];
	[FT Bubble Flag] = TRUE;
    "GUI FT Bubblesort compare end"
	A+;
	C+;
	-> GUI FT Bubblesort inner loop;
    "GUI FT Bubblesort inner loop end"
	<-- A;
	? [FT Bubble Flag] = TRUE -> GUI FT Bubblesort run;
	leave;

"service When Hovering Title Bar"
	[Balloon Text String] = [Window Title];
	leave;

"service When No Longer Hovering Title Bar"
	? [Balloon Text String] != [Window Title]
		-> Title bar do not remove description;
	[Balloon Text String] = NULL;
    "Title bar do not remove description"
	leave;

"Internal Update Menu Button Appearence"
	[TGA Effect]			= service FX Raw;
	[TGA Target Layer]		= Backdrop Layer;
	[TGA Display Alignment] 	= [Display Width];
	[TGA Display Height]		= [Display Height];
	[TGA Picture Data]		= [p Logo Shape];
	[TGA Picture Left]		= [vector Menu Button plus 0];
	[TGA Picture Top]		= [vector Menu Button plus 1];
	=> Load TGA Picture;
	? [Write Caption Over Menu Button] = NO -> Witheld Menu Caption;
	[RMC String]			= [Menu Caption];
	[RMC Region]			= vector Menu Button;
	=> Rewrite Menu Caption;
    "Witheld Menu Caption"
	? [Rectangle Gradients] = NULL -> Menu Button Plain;
	[Rectangle Display Alignment]	= [Display Width];
	[Rectangle Bounds]		= vector Menu Button;
	[Rectangle Target Layer]	= Backdrop Layer;
	=> Rectangle;
    "Menu Button Plain"
	[L2L Region] = vector Menu Button;
	-> Update Area;

"Rewrite Menu Caption"
	[String]	      = [RMC String];
	[Ink]		      = [Title Bar Text Color];
	[Text Effect]	      = [Title Bar Text Effect];
	[Text Display Width]  = [Display Width];
	[Text Display Height] = [Display Height];
	[Text Display Origin] = Backdrop Layer;
	[Text Window]	      = NULL;
	[Text Word Wrap]      = OFF;
	A		      = [RMC Region];
	[Text X]	      = [A plus 0];
	[Text Y]	      = [A plus 1];
	[Text Region]	      = NULL;
	[Text Ghost Mode]     = ON;
	=> STD Write;
	A		      = [RMC Region];
	[Text X]	      = [A plus 2];
	[Text X]	      - [A plus 0];
	[Text X]	      - [Width of Latest Form];
	[Text X]	     >> 1;
	[Text X]	      + [A plus 0];
	[Text X]	      + [Menu Caption X Displacement];
	[Text Y]	      = [A plus 3];
	[Text Y]	      - [A plus 1];
	[Text Y]	      - [Height of Latest Form];
	[Text Y]	     >> 1;
	[Text Y]	      + [A plus 1];
	[Text Y]	      + [Menu Caption Y Displacement];
	[Text Region]	      = [RMC Region];
	[Text Ghost Mode]     = OFF;
	-> STD Write;

"service When Hovering Menu Button"
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
	=> Internal Update Menu Button Appearence;
	? [Menu On] = YES -> WHMB No balloon when menu is on;
	[Balloon Text String] = vector App Menu Description;
    "WHMB No balloon when menu is on"
	leave;

"service When No Longer Hovering Menu Button"
	? [Balloon Text String] != vector App Menu Description
		-> Menu do not remove description;
	[Balloon Text String] = NULL;
    "Menu do not remove description"
	[Rectangle Gradients] = NULL;
	-> Internal Update Menu Button Appearence;

"service When Pushing Menu Button"
	[Rectangle Gradients] = vector Pushed Button Colors;
	[Rectangle Effect] = [Pushed Button Effect];
	-> Internal Update Menu Button Appearence;

"service Menu Button Action"
	[Balloon Text String] = NULL;
	[FS On] = NO;
	[Menu On] # YES;
	=> Reset Pulldown Menu;
	-> Refresh Display;

"service F10 Menu Activation"
	=> service Menu Button Action;
      ? [Menu On] = NO -> F10MA Close;
	A = 0;
      "FMM To Option A"
	[FMM P] = A;
	[FMM X] = [A relating vector Menu Option OS X];
	[FMM X] + [A relating vector Menu Option OS W];
	[FMM X] - 12;
	[FMM Y] = [A relating vector Menu Option OS Y];
	[FMM Y] + [A relating vector Menu Option OS H];
	[FMM Y] - 6;
	=> Force Mouse Move;
      "F10MA Close"
	leave;

"service KDriven Menu Next"
      ? [Menu On] = NO -> KDMN Idle;
      ? [KEY CONTROL] = ON -> KDMN Considering file selector;
      ? [Onscreen Menu Options] <= ZERO -> KDMN Idle;
	A = [FMM P];
	A +;
	A % [Onscreen Menu Options];
	=> FMM To Option A;
      "KDMN Idle"
	leave;
      "KDMN Considering file selector"
      ? [FS On] = NO -> KDMCFS Idle;
	A = [SCROLLER SCOPE relating vector FS Scroller];
	A - [SCROLLER WINDOW relating vector FS Scroller];
      ? [SCROLLER READOUT relating vector FS Scroller] >= A -> KDMCFS Idle;
	[SCROLLER READOUT relating vector FS Scroller] +;
      "KDMCFS Common"
	[Scroller Datascript] = vector FS Scroller;
	=> Update Scroller Position From Readout;
	=> PBL Redraw menu;
	[L2L Region] = vector FS Body Bounds;
	=> Update Area;
      "KDMCFS Idle"
	leave;

"service KDriven Menu Prev"
      ? [Menu On] = NO -> KDMP Idle;
      ? [KEY CONTROL] = ON -> KDMP Considering file selector;
      ? [Onscreen Menu Options] <= ZERO -> KDMP Idle;
	A = [FMM P];
	A -;
      ? A >= ZERO -> KDMP Positive;
	A + [Onscreen Menu Options];
      "KDMP Positive"
	A % [Onscreen Menu Options];
	=> FMM To Option A;
      "KDMP Idle"
	leave;
      "KDMP Considering file selector"
      ? [FS On] = NO -> KDMCFS Idle;
      ? [SCROLLER READOUT relating vector FS Scroller] <= ZERO -> KDMCFS Idle;
	[SCROLLER READOUT relating vector FS Scroller] -;
	-> KDMCFS Common;

"service KDriven Menu Action"
      ? [Menu On] = NO -> KDMA Idle;
    (discard any ASCII keystrokes presumably generated pressing the ENTER key
     see EKEY library commentary, which details this operation very well, and
     note that such an operation on an ekey server subroutine is only needed
     when the server is associated to a TRUE CHARACTER keystroke, generating
     an ASCII code in the console input buffer: this server here is, in fact,
     connected to the RETURN key, generating ASCII code 13)
	[Console Command] = GET CONSOLE INPUT;
	isocall;
      ? failed -> service KDriven Menu Action;
	[Console Command] = CLEAR CONSOLE BUFFER;
	isocall;
    (proceed with interpretation of the keystroke in the menu's context)
	A = [FMM P];
      ? A < ZERO -> KDMA Idle;
      ? A >= [Onscreen Menu Options] -> KDMA Idle;
      ? [A plus vector Menu Option OS Attr] + OPTION TYPE DISABLED -> KDMA Idle;
	A -->;
	[Examined Option] = A;
	=> service Menu Option Action;
	<-- A;
      ? [A plus vector Menu Option OS Attr] - OPTION TYPE SUBMENU plus OPTION TYPE FILE SELECTOR -> KDMA Idle;
	A = [Last Level First Option Index];
	=> FMM To Option A;
      "KDMA Idle"
	leave;

"Force Mouse Move"
	[Pointer Mode] = BY DELTA;
	isocall;
	[Pointer X Coordinate] = [FMM X];
	[Pointer Y Coordinate] = [FMM Y];
	[Pointer Mode] = BY COORDINATE;
	isocall;
	leave;

"Update Generic Button Appearence"
	[Rectangle Bounds] = B;
	[TGA Effect] = service FX Raw;
	[TGA Target Layer] = Backdrop Layer;
	[TGA Display Alignment] = [Display Width];
	[TGA Display Height] = [Display Height];
	[TGA Picture Left] = [B plus 0];
	[TGA Picture Top] = [B plus 1];
	=> Load TGA Picture;
	? [Rectangle Gradients] = NULL -> Generic Button Plain;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Target Layer] = Backdrop Layer;
	=> Rectangle;
    "Generic Button Plain"
	[L2L Region] = [Rectangle Bounds];
	-> Update Area;

"Update Exit Button Appearence"
	B = vector Exit Button; [TGA Picture Data] = [p Exit Button Shape];
	-> Update Generic Button Appearence;

"service When Hovering Exit Button"
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
	=> Update Exit Button Appearence;
	[Balloon Text String] = Exit Button Description;
	leave;

"service When No Longer Hovering Exit Button"
	? [Balloon Text String] != Exit Button Description
		-> Exit do not remove description;
	[Balloon Text String] = NULL;
    "Exit do not remove description"
	[Rectangle Gradients] = NULL;
	-> Update Exit Button Appearence;

"service When Pushing Exit Button"
	[Rectangle Gradients] = vector Pushed Button Colors;
	[Rectangle Effect] = [Pushed Button Effect];
	-> Update Exit Button Appearence;

"service Exit Button Action"
	[Rectangle Gradients] = NULL;
	=> Update Exit Button Appearence;
	[Quit Now] = YES;
	leave;

"Update Slep Button Appearence"
	B = vector Slep Button; [TGA Picture Data] = [p Slep Button Shape];
	-> Update Generic Button Appearence;

"service When Hovering Slep Button"
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
	=> Update Slep Button Appearence;
	[Balloon Text String] = Slep Button Description;
	leave;

"service When No Longer Hovering Slep Button"
	? [Balloon Text String] != Slep Button Description
		-> Slep do not remove description;
	[Balloon Text String] = NULL;
    "Slep do not remove description"
	[Rectangle Gradients] = NULL;
	-> Update Slep Button Appearence;

"service When Pushing Slep Button"
	[Rectangle Gradients] = vector Pushed Button Colors;
	[Rectangle Effect] = [Pushed Button Effect];
	-> Update Slep Button Appearence;

"service Slep Button Action"
	? [Slep Is Active] = NO  -> Now Slep;
	? [Slep Is Active] = YES -> Now Unslep;
    "SlepUnslep Rendezvous"
	[Slep Is Active] # YES;
	[Rectangle Gradients] = NULL;
	=> Update Slep Button Appearence;
	=> Update Layers;
    "While sleeping"
	? [Slep Is Active] = NO -> No longer sleeping;
	=> Begin Control Loop;
	    ( Aligning iconified window to 126x25 grid)
		A = [Display X Position]; A % 126;
		B = [Display X Position]; B - A;
		C = [Display Y Position]; C % 25;
		D = [Display Y Position]; D - C;
		? A != B -> WS Realign;
		? C != D -> WS Realign;
		-> WS Aligned already;
	    "WS Realign"
		? A <= 126 div 2 -> WS X align by defect;
		B + 126; (X align in excess)
	      "WS X align by defect"
		[Display X Position] = B;
		? C <= 25 div 2 -> WS Y align by defect;
		D + 25; (Y align in excess)
	      "WS Y align by defect"
		[Display Y Position] = D;
		isocall;
		=> Find Sleepy Window Record;
		? failed -> WS Aligned already;
		C = [Display Y Position]; C / 25; C * 100000;
		D = [Display X Position]; D / 126; C + D;
		[A] = C;
		[Global K Command] = K WRITE;
		[Global K Name] = Sleepy Windows Key;
		[Global K Data] = Sleepy Windows Data;
		isocall;
		[Sleepy Display X Position] = [Display X Position];
		[Sleepy Display Y Position] = [Display Y Position];
	    "WS Aligned already"
	    ( Waiting to awake... )
		[Hot Spot Data] = vector Slep Button Hotspot;
		[While Hovering] = NULL;
		[When Hovering] = service When Hovering Slep Button;
		[When No Longer Hovering] = service When No Longer Hovering Slep Button;
		[When Pushing] = service When Pushing Slep Button;
		[When No Longer Pushing] = service Slep Button Action;
		=> Check Hot Spot;
		? [Sleepy Control Loop] = NULL -> No sleepy control loop specified;
		=> [Sleepy Control Loop];
	    "No sleepy control loop specified"
		[Balloon Text String] = NULL;
	=> End Control Loop;
	-> While sleeping;
    "No longer sleeping"
	leave;

"Find Sleepy Window Record"
	[Global K Command] = K READ;
	[Global K Name] = Sleepy Windows Key;
	[Global K Data] = Sleepy Windows Data;
	isocall;
	? failed -> No such sleepy window record;
	A = Sleepy Windows Data plus 1;
	B = [Sleepy Windows Data];
	? B = ZERO -> No such sleepy window record;
	C = [Sleepy Display Y Position]; C / 25; C * 100000;
	D = [Sleepy Display X Position]; D / 126; C + D;
      "FSWR Check other sleepies"
	? [A] = C -> Found sleepy window record;
	A+; B ^ FSWR Check other sleepies;
    "No such sleepy window record"
	fail;
    "Found sleepy window record"
	end;

"Update Fold Button Appearence"
	? [Fold Is Active] = NO -> Show As Unfold;
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
    "Show As Unfold"
	B = vector Fold Button; [TGA Picture Data] = [p Fold Button Shape];
	-> Update Generic Button Appearence;

"service When Hovering Fold Button"
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
	=> Update Fold Button Appearence;
	[Balloon Text String] = Fold Button Description;
	leave;

"service When No Longer Hovering Fold Button"
	? [Balloon Text String] != Fold Button Description
		-> Fold do not remove description;
	[Balloon Text String] = NULL;
    "Fold do not remove description"
	[Rectangle Gradients] = NULL;
	-> Update Fold Button Appearence;

"service When Pushing Fold Button"
	[Rectangle Gradients] = vector Pushed Button Colors;
	[Rectangle Effect] = [Pushed Button Effect];
	-> Update Fold Button Appearence;

"service Fold Button Action"
	? [Fold Is Active] = NO -> Now Fold; (else) -> Now Unfold;

"AutoUnfold"
	[Fold Is Active] = NO;
	[Rectangle Gradients] = NULL;
	=> Update Fold Button Appearence;
	[Display Height] = [Previous display height];
	isocall;
	leave;

"Update Maxi Button Appearence"
	B = vector Maxi Button; [TGA Picture Data] = [p Maxi Button Shape];
	-> Update Generic Button Appearence;

"service When Hovering Maxi Button"
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
	=> Update Maxi Button Appearence;
	[Balloon Text String] = Maxi Button Description;
	leave;

"service When No Longer Hovering Maxi Button"
	? [Balloon Text String] != Maxi Button Description
		-> Maxi do not remove description;
	[Balloon Text String] = NULL;
    "Maxi do not remove description"
	[Rectangle Gradients] = NULL;
	-> Update Maxi Button Appearence;

"service When Pushing Maxi Button"
	[Rectangle Gradients] = vector Pushed Button Colors;
	[Rectangle Effect] = [Pushed Button Effect];
	-> Update Maxi Button Appearence;

"Update Full Button Appearence"
	? [Display Status] - EXCLUSIVE -> Show As Unfull;
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
    "Show As Unfull"
	B = vector Full Button; [TGA Picture Data] = [p Full Button Shape];
	-> Update Generic Button Appearence;

"service When Hovering Full Button"
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
	=> Update Full Button Appearence;
	[Balloon Text String] = Full Button Description;
	leave;

"service When No Longer Hovering Full Button"
	? [Balloon Text String] != Full Button Description
		-> Full do not remove description;
	[Balloon Text String] = NULL;
    "Full do not remove description"
	[Rectangle Gradients] = NULL;
	-> Update Full Button Appearence;

"service When Pushing Full Button"
	[Rectangle Gradients] = vector Pushed Button Colors;
	[Rectangle Effect] = [Pushed Button Effect];
	-> Update Full Button Appearence;

"service Full Button Action"
	? [Display Status] + EXCLUSIVE -> Now Unfull;
	? [Display Status] - EXCLUSIVE -> Now Full;

"Update Size Button Appearence"
	A = MINIMUM WIDTH;
	B = MINIMUM HEIGHT;
	? A != MAXIMUM WIDTH  -> Size Button May Be Active;
	? B != MAXIMUM HEIGHT -> Size Button May Be Active;
	[Rectangle Gradients] = vector Inactive Button Colors;
	[Rectangle Effect] = [Inactive Button Effect];
    "Size Button May Be Active"
	B = vector Size Button; [TGA Picture Data] = [p Size Button Shape];
	-> Update Generic Button Appearence;

"service When Hovering Size Button"
	[Rectangle Gradients] = vector Active Button Colors;
	[Rectangle Effect] = [Active Button Effect];
	=> Update Size Button Appearence;
	[Balloon Text String] = Size Button Description;
	leave;

"service When No Longer Hovering Size Button"
	? [Balloon Text String] != Size Button Description
		-> Size do not remove description;
	[Balloon Text String] = NULL;
    "Size do not remove description"
	[Rectangle Gradients] = NULL;
	-> Update Size Button Appearence;

"service When Pushing Size Button"
	[Pointer Mode] = BY DELTA;
	isocall;
    "Wait for release of size button"
	[Pointer Command] = READ POINTER;
	isocall;
	=> Things To Do While Resizing;
	[Process Command] = SLEEP;
	[Sleep Timeout] = [Display Animation Rate]; (this is declared in allowdd.txt)
	isocall;
    ? [Pointer Status] + PD LEFT BUTTON DOWN -> Wait for release of size button;
	[Pointer Mode] = BY COORDINATE;
	isocall;
	leave;

"Things To Do While Resizing"
    (adding deltas, checking physical and logical limits)
	[Pointer Delta Y] +-;
	B = [Display Width]; [Display Width] + [Pointer Delta X];
	? [Display Width] >= MINIMUM WIDTH -> Min Display Width In Range;
	[Display Width] = MINIMUM WIDTH;
	[Pointer Delta X] = MINIMUM WIDTH;
	[Pointer Delta X] - B;
    "Min Display Width In Range"
	? [Display Width] <= MAXIMUM WIDTH -> Max Display Width In Range;
	[Display Width] = MAXIMUM WIDTH;
	[Pointer Delta X] = MAXIMUM WIDTH;
	[Pointer Delta X] - B;
    "Max Display Width In Range"
	? [Display Width] <= [Display Physical Width] -> Max Display Width Acceptable;
	[Display Width] = [Display Physical Width];
	[Pointer Delta X] = [Display Physical Width];
	[Pointer Delta X] - B;
    "Max Display Width Acceptable"
	B = [Display Height]; [Display Height] + [Pointer Delta Y];
	? [Display Height] >= MINIMUM HEIGHT -> Min Display Height In Range;
	[Display Height] = MINIMUM HEIGHT;
	[Pointer Delta Y] = MINIMUM HEIGHT;
	[Pointer Delta Y] - B;
    "Min Display Height In Range"
	? [Display Height] <= MAXIMUM HEIGHT -> Max Display Height In Range;
	[Display Height] = MAXIMUM HEIGHT;
	[Pointer Delta Y] = MAXIMUM HEIGHT;
	[Pointer Delta Y] - B;
    "Max Display Height In Range"
	? [Display Height] <= [Display Physical Height] -> Max Display Height Acceptable;
	[Display Height] = [Display Physical Height];
	[Pointer Delta Y] = [Display Physical Height];
	[Pointer Delta Y] - B;
    "Max Display Height Acceptable"
    (done checking limits, move display up 'cos size button is on top)
	[Display Y Position] - [Pointer Delta Y];
    (update bounds of all known areas - known to iGUI, that is)
	[Pointer Delta Y] +-;
	=> RES Update all bounds;
    (updating mouse cursor pos. to follow the button which is also moving)
	[Pointer X Coordinate] + [Pointer Delta X];
    (finally updating visible display to refit elements to the new size)
	=> Prepare Backdrop Layer;
	-> Update Layers;

"RES Update all bounds"
	[Pointer Delta Y] +-;
    (Updating all fixed elements' edges)
	[RIGHT	 MARGIN relating vector iGUI Caption Bar]	 + [Pointer Delta X];
	[BOTTOM  MARGIN relating vector iGUI Window Left Edge]	 + [Pointer Delta Y];
	[LEFT	 MARGIN relating vector iGUI Window Right Edge]  + [Pointer Delta X];
	[RIGHT	 MARGIN relating vector iGUI Window Right Edge]  + [Pointer Delta X];
	[BOTTOM  MARGIN relating vector iGUI Window Right Edge]  + [Pointer Delta Y];
	[RIGHT	 MARGIN relating vector iGUI Window Bottom Edge] + [Pointer Delta X];
	[TOP	 MARGIN relating vector iGUI Window Bottom Edge] + [Pointer Delta Y];
	[BOTTOM  MARGIN relating vector iGUI Window Bottom Edge] + [Pointer Delta Y];
	[RIGHT	 MARGIN relating vector Title Bar Bounds]	 + [Pointer Delta X];
	[RIGHT	 MARGIN relating vector Work Area]		 + [Pointer Delta X];
	[BOTTOM  MARGIN relating vector Work Area]		 + [Pointer Delta Y];
	[LEFT	 MARGIN relating vector Size Button]		 + [Pointer Delta X];
	[RIGHT	 MARGIN relating vector Size Button]		 + [Pointer Delta X];
	[LEFT	 MARGIN relating vector Size Button Hotspot]	 + [Pointer Delta X];
	[RIGHT	 MARGIN relating vector Size Button Hotspot]	 + [Pointer Delta X];
	[LEFT	 MARGIN relating vector Menu Button]		 + [Pointer Delta X];
	[RIGHT	 MARGIN relating vector Menu Button]		 + [Pointer Delta X];
	[LEFT	 MARGIN relating vector Menu Button Hotspot]	 + [Pointer Delta X];
	[RIGHT	 MARGIN relating vector Menu Button Hotspot]	 + [Pointer Delta X];
	[TOP	 MARGIN relating vector Tools Bar Bounds]	 + [Pointer Delta Y];
	[RIGHT	 MARGIN relating vector Tools Bar Bounds]	 + [Pointer Delta X];
	[BOTTOM  MARGIN relating vector Tools Bar Bounds]	 + [Pointer Delta Y];
    (Eventually updating submenus left/right edges)
	A = ZERO;
      "RES Next submenu"
	? A >= [OnScreen Menu Levels] -> RES End submenus;
	[A plus vector Menu Level OS X] + [Pointer Delta X];
	A+; -> RES Next submenu;
      "RES End submenus"
	[Pointer Delta Y] +-;
	leave;

"Find Opt Logical ID From Code"
	A = ZERO;
	E = MAX MENU OPTIONS minus 1;
    "FOC Search"
	? A >= [Installed Menu Options] -> FOC Error;
	? [A plus vector Menu Option Code] = [Option Code] -> FOC Found;
	A+; -> FOC Search;
    "FOC Found"
	E = A;
	end;
    "FOC Error"
	fail;

"service When Hovering Question Option"
"service When No Longer Hovering Question Option"
	A = [Q Current option to check for];
	[A plus 0]-; [A plus 1]-; [A plus 2]+; [A plus 3]+;
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Bounds] = [Q Current option to check for];
	[Rectangle Gradients] = vector Standard Black Gradients;
	[Rectangle Effect] = service FX Negate;
	=> Rectangle;
	A = [Q Current option to check for];
	[A plus 0]+; [A plus 1]+; [A plus 2]-; [A plus 3]-;
	=> Rectangle;
	A = [Q Current option to check for];
	[A plus 0]-; [A plus 1]-; [A plus 2]+; [A plus 3]+;
	[L2L Region] = [Q Current option to check for];
	=> Update Area;
	A = [Q Current option to check for];
	[A plus 0]+; [A plus 1]+; [A plus 2]-; [A plus 3]-;
	leave;

"service Q Apply Default Option"
	(selects the very first option's data set, as the default option)
	[Q Current option to check for] = vector Q Options Data;
	(...and this entry point goes on as...)
"service Question Option Action"
	=> Refresh Display;
	A = [Q Current option to check for];
	A = [A plus 6];
	? [A] = NULL -> QOA Nothing to do;
	=> [A];
    "QOA Nothing to do"
	[Q Quit] = YES;
	leave;

"service Q Next Text Field"
    (as bugfixed in February 2003 by Peterpaul Klein Haneveld: thank you! :)
	A -->;
	[Is Active Text Field] = NO;
	=> Q Refresh Field;
    "QNTF Next"
	[Q Selected Field]+; [Q Selected Field] % [Q Fields Count];
	A = [Q Selected Field];
	? [A plus vector Q Field Classification] = 83 -> QNTF Next;
	[Is Active Text Field] = YES;
	=> Q Refresh Field;
	<-- A;
	leave;

"service Question Field Selection"
	[Is Active Text Field] = NO; => Q Refresh Field;
	[Q Selected Field] = [Q Examined Field];
	[Is Active Text Field] = YES; => Q Refresh Field;
	leave;

"service On Change of question text field"
	[Q Field To Retrace] = [Q Selected Field];
	-> Q Retrace Field;

"Q Retrace Field"
	[Rectangle Bounds] = 5;
	[Rectangle Bounds] * [Q Field To Retrace];
	[Rectangle Bounds] + vector Q Fields Hotspot;
	[Rectangle Target Layer] = Backdrop Layer;
	[Rectangle Display Alignment] = [Display Width];
	[Rectangle Gradients] = vector Question Field Body Colors;
	[Rectangle Effect] = [Question Field Body Effect];
	-> Rectangle;

"Q Refresh Field"
	[Q Field To Retrace] = [Q Selected Field];
	=> Q Retrace Field;
	[Text Field Data] = 7;
	[Text Field Data] * [Q Selected Field];
	[Text Field Data] + vector Q Fields Data;
	A = [Q Selected Field]; [Text Field Buffer] = [A plus vector Q Field Buffer];
	[Text Field Behavior] = NULL;
	-> CTF Refresh;

"Q Overscan"
	? [Question Datascript] = On Question Overscan -> Question;
	[Q Datascript Before Overscan] = [Question Datascript];
	[Question Datascript] = On Question Overscan;
	-> Question;

"Q Maximize"
	=> Now Maxi;
	[Question Datascript] = [Q Datascript Before Overscan];
	-> Question;

"Update Tool"
	[Rectangle Display Alignment]	= [Display Width];
	[Rectangle Bounds]		= UT Bounds;
	[Rectangle Target Layer]	= Backdrop Layer;
	[Rectangle Effect]		-->;
	[Rectangle Gradients]		-->;
	[Rectangle Effect]		= service FX Raw;
	[Rectangle Gradients]		= vector Standard Black Gradients;
	=> Rectangle;
	[Rectangle Gradients]		<--;
	[Rectangle Effect]		<--;
	[TGA Display Width] -->;
	[TGA Effect]			= service FX Raw;
	[TGA Target Layer]		= Backdrop Layer;
	[TGA Display Alignment] 	= [Display Width];
	[TGA Display Width]		= [Display Width];
	[TGA Display Height]		= [Display Height];
	[TGA Picture Data]		= [p Tools Bar Button];
	[TGA Picture Left]		= [UT Bounds plus 0];
	[TGA Picture Top]		= [UT Bounds plus 1];
	=> Load TGA Picture;
	<-- [TGA Display Width];
	? [Rectangle Gradients] = NULL -> UT Plain;
	[UT Bounds plus 1] +; [UT Bounds plus 2] -; [UT Bounds plus 3] -;
	=> Rectangle;
	[UT Bounds plus 1] -; [UT Bounds plus 2] +; [UT Bounds plus 3] +;
    "UT Plain"
	A = [UT Datascript pointer]; A+;
	B = ZERO;
    "UT Copy tool tip"
	? [UT Copy tip] = NO -> UT STT;
	? B > 62 -> UT STT;
	[B plus vector Tool Tip] = [A];
      "UT STT"
	? [A] = NULL -> UT ETT;
	A+; B+; -> UT Copy tool tip;
    "UT ETT"
	A+;
	[UT Color] = [A plus 23];
	[UT Effect] = [A plus 24];
	[UT Pixel Pointer] = [UT Bounds plus 1];
	[UT Pixel Pointer] * [Display Width];
	[UT Pixel Pointer] + [UT Bounds plus 0];
	[UT Pixel Pointer] + Backdrop Layer;
	[UT Scanlines] = 23;
    "UT Scanline"
	B = 10000000000000000000000b;
      "UT Pixels"
	  ? [A] - B -> UT No pixel here;
	  A -->;
	  B -->;
	  A = [UT Pixel Pointer];
	  B = [UT Color];
	  => [UT Effect];
	  <-- B;
	  <-- A;
      "UT No pixel here"
	[UT Pixel Pointer] +;
	  B > 1; ? B > ZERO -> UT Pixels;
	  [UT Pixel Pointer] - 23;
	[UT Pixel Pointer] + [Display Width];
	A+; [UT Scanlines] ^ UT Scanline;
	A = [UT Datascript pointer];
	? [A] != NULL -> UT Dont grey;
	[Rectangle Gradients]		= vector Inactive Button Colors;
	[Rectangle Display Alignment]	= [Display Width];
	[Rectangle Bounds]		= UT Bounds;
	[Rectangle Target Layer]	= Backdrop Layer;
	[Rectangle Effect]		= [Inactive Button Effect];
	[UT Bounds plus 1] +; [UT Bounds plus 2] -; [UT Bounds plus 3] -;
	=> Rectangle;
	[UT Bounds plus 1] -; [UT Bounds plus 2] +; [UT Bounds plus 3] +;
    "UT Dont grey"
	[L2L Region] = UT Bounds;
	-> Update Area;

"Compute Scroller Dimensions"
	D = [Scroller Datascript];
	C = [D plus 3]; C - [D plus 1]; (width, track length)
	E = [D plus 4]; E - [D plus 2]; (height, scrollbar thickness)
	? C >= E -> CSD Horiz;
	[TR Picture Data] = [p H Scroller Track];
	[Scroller Direction] = VERTICAL;
	-> CSD Vert;
    "CSD Horiz"
	[TR Picture Data] = [p V Scroller Track];
	[Scroller Direction] = HORIZONTAL;
	C -->; E -->; <-- C; <-- E; (C = always thickness, E = always track length)
    "CSD Vert"
	[CSD Pad Update Flag] = OFF;
	? E = [D plus 9] -> CSD Same track length;
	[D plus 9] = E; [CSD Pad Update Flag] = ON;
      "CSD Same track length"
	? [D plus 6] = [D plus 10] -> CSD Same scope;
	[D plus 10] = [D plus 6]; [CSD Pad Update Flag] = ON;
      "CSD Same scope"
	? [CSD Pad Update Flag] = OFF -> CSD Skip Pad Position Update;
	[TR Picture Data] -->;
	=> Update Scroller Position From Readout;
	<-- [TR Picture Data];
      "CSD Skip Pad Position Update"
	leave;

"Compute Scrollpad Dimensions"
	A = E; A * [D plus 7];
	? [D plus 6] = ZERO -> CSPD DBZ Guard;
	A / [D plus 6];
    "CSPD DBZ Guard"
	? A >= C -> CSPD Pad is large enough; A = C; "CSPD Pad is large enough"
	? A <= E -> CSPD Pad is small enough; A = E; "CSPD Pad is small enough"
	[CS Range] = E; [CS Range] - A; (Range = track length - pad length)
	[CS Gap] = [D plus 6]; [CS Gap] - [D plus 7]; (Gap = scope - window)
	[Scrollpad Bounds plus 0] = [D plus 1];
	[Scrollpad Bounds plus 1] = [D plus 2];
	? [Scroller Direction] = HORIZONTAL -> CSPD Horiz;
	[Scrollpad Bounds plus 1] + [D plus 5];
	[Scrollpad Bounds plus 2] = [Scrollpad Bounds plus 0]; [Scrollpad Bounds plus 2] + C;
	[Scrollpad Bounds plus 3] = [Scrollpad Bounds plus 1]; [Scrollpad Bounds plus 3] + A;
	[TR Picture Data] = [p V Scroller Pad];
	[DS Pad Hole] = [p H Scroller Track];
	[DS Pad Hole Shadow] = [p Menu Shadow Horizontal];
	-> CSPD Vert;
    "CSPD Horiz"
	[Scrollpad Bounds plus 0] + [D plus 5];
	[Scrollpad Bounds plus 2] = [Scrollpad Bounds plus 0]; [Scrollpad Bounds plus 2] + A;
	[Scrollpad Bounds plus 3] = [Scrollpad Bounds plus 1]; [Scrollpad Bounds plus 3] + C;
	[TR Picture Data] = [p H Scroller Pad];
	[DS Pad Hole] = [p V Scroller Track];
	[DS Pad Hole Shadow] = [p Menu Shadow Vertical];
    "CSPD Vert"
	leave;
